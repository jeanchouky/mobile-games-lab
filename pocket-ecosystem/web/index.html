<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Pocket Ecosystem</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #f5f0e6;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  font-family: 'Georgia', 'Times New Roman', serif;
}
canvas {
  display: block;
  width: 100%; height: 100%;
  image-rendering: auto;
}
</style>
</head>
<body>
<canvas id="ecosystem"></canvas>
<script>
'use strict';

// ============================================================
// POCKET ECOSYSTEM ‚Äî A Living Terrarium
// ============================================================

const canvas = document.getElementById('ecosystem');
const ctx = canvas.getContext('2d');

// --- GLOBALS ---
let W, H, scale, centerX, centerY;
let gameTime = 0, deltaTime = 0, lastTime = 0;
let simulationTime = 0; // tracks ecosystem age in seconds
let daysSurvived = 0;

// Ecosystem state
let creatures = [];
let plants = [];
let particles = [];
let weather = 'clear'; // clear, rain, storm, sunny
let timeOfDay = 'day'; // dawn, day, dusk, night
let ecosystemHealth = 100;
let lastSaveTime = 0;

// Input
let inputEvents = [];
let dragState = { active: false, startX: 0, startY: 0, x: 0, y: 0, target: null };

// Audio
let audioCtx = null;
let masterGain = null;
let ambienceGain = null;
let sfxGain = null;
let audioMuted = false;
let ambienceNodes = [];
let ambienceTimeoutIds = [];

// UI state
let showingJournal = false;
let journalEntries = [];
let muteButtonBounds = null;
let lastMouseX = 0, lastMouseY = 0;

// Seasons: change every 5 days (5 minutes real time)
let currentSeason = 'spring'; // spring, summer, autumn, winter
let seasonTimer = 0;
const SEASON_DURATION = 300; // 5 min per season

// Time-lapse mode
let timeLapseActive = false;
let timeLapseSpeed = 1; // multiplier

// Phone usage simulation (since we can't access real data in web)
let simulatedUsage = {
  screenTimeToday: 0, // hours
  stepsToday: 0,
  musicMinutes: 0,
  phoneFreeMins: 0,
  lastUpdateTime: Date.now()
};

// --- RESIZE ---
function resize() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  scale = Math.min(W / 400, H / 700);
  centerX = W / 2;
  centerY = H / 2;
}
window.addEventListener('resize', resize);
resize();

// ============================================================
// AUDIO ENGINE
// ============================================================
function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    masterGain = audioCtx.createGain();
    masterGain.gain.value = audioMuted ? 0 : 0.3;
    masterGain.connect(audioCtx.destination);
    
    ambienceGain = audioCtx.createGain();
    ambienceGain.gain.value = 0.4;
    ambienceGain.connect(masterGain);
    
    sfxGain = audioCtx.createGain();
    sfxGain.gain.value = 0.6;
    sfxGain.connect(masterGain);
    
    startAmbience();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function toggleMute() {
  audioMuted = !audioMuted;
  if (audioCtx && masterGain) {
    masterGain.gain.setValueAtTime(audioMuted ? 0 : 0.3, audioCtx.currentTime);
  }
  if (audioMuted) {
    stopAmbience();
  } else {
    startAmbience();
  }
}

// Nature ambience - layered soundscape
function startAmbience() {
  if (!audioCtx || audioMuted) return;
  stopAmbience();
  
  // Water trickling (filtered white noise)
  const waterNoise = audioCtx.createBufferSource();
  const bufSize = audioCtx.sampleRate * 4;
  const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) {
    data[i] = (Math.random() * 2 - 1) * 0.3;
  }
  waterNoise.buffer = buf;
  waterNoise.loop = true;
  
  const waterFilter = audioCtx.createBiquadFilter();
  waterFilter.type = 'bandpass';
  waterFilter.frequency.value = 800;
  waterFilter.Q.value = 0.5;
  
  const waterGain = audioCtx.createGain();
  waterGain.gain.value = 0.15;
  
  waterNoise.connect(waterFilter);
  waterFilter.connect(waterGain);
  waterGain.connect(ambienceGain);
  waterNoise.start();
  
  ambienceNodes.push({ node: waterNoise, type: 'water' });
  
  // Wind (low frequency noise)
  const windNoise = audioCtx.createBufferSource();
  const windBuf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const windData = windBuf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) {
    windData[i] = (Math.random() * 2 - 1) * 0.2;
  }
  windNoise.buffer = windBuf;
  windNoise.loop = true;
  
  const windFilter = audioCtx.createBiquadFilter();
  windFilter.type = 'lowpass';
  windFilter.frequency.value = 300;
  
  const windGain = audioCtx.createGain();
  windGain.gain.value = 0.08;
  
  windNoise.connect(windFilter);
  windFilter.connect(windGain);
  windGain.connect(ambienceGain);
  windNoise.start();
  
  ambienceNodes.push({ node: windNoise, type: 'wind' });
  
  // Bird chirps (periodic)
  startBirdChirps();
  
  // Insect buzzing (periodic)
  startInsectBuzz();
}

function startBirdChirps() {
  if (!audioCtx || audioMuted) return;

  const chirp = () => {
    if (audioMuted || timeOfDay === 'night') {
      ambienceTimeoutIds.push(setTimeout(chirp, 5000));
      return;
    }

    const birdCount = creatures.filter(c => c.type === 'bird').length;
    if (birdCount > 0 && Math.random() < 0.4) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      const freq = 800 + Math.random() * 800;
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(freq * 1.5, audioCtx.currentTime + 0.05);
      osc.frequency.exponentialRampToValueAtTime(freq, audioCtx.currentTime + 0.1);

      osc.type = 'sine';

      gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);

      osc.connect(gain);
      gain.connect(ambienceGain);

      osc.start();
      osc.stop(audioCtx.currentTime + 0.15);
    }

    ambienceTimeoutIds.push(setTimeout(chirp, 3000 + Math.random() * 5000));
  };
  chirp();
}

function startInsectBuzz() {
  if (!audioCtx || audioMuted) return;

  const buzz = () => {
    if (audioMuted || timeOfDay === 'night') {
      ambienceTimeoutIds.push(setTimeout(buzz, 8000));
      return;
    }

    const insectCount = creatures.filter(c => c.type === 'insect').length;
    if (insectCount > 0 && Math.random() < 0.3) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.frequency.value = 200 + Math.random() * 100;
      osc.type = 'sawtooth';

      gain.gain.setValueAtTime(0, audioCtx.currentTime);
      gain.gain.linearRampToValueAtTime(0.04, audioCtx.currentTime + 0.2);
      gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1);

      osc.connect(gain);
      gain.connect(ambienceGain);

      osc.start();
      osc.stop(audioCtx.currentTime + 1);
    }

    ambienceTimeoutIds.push(setTimeout(buzz, 5000 + Math.random() * 10000));
  };
  buzz();
}

function stopAmbience() {
  ambienceNodes.forEach(node => {
    try {
      node.node.stop();
    } catch(e) {}
  });
  ambienceNodes = [];
  ambienceTimeoutIds.forEach(id => clearTimeout(id));
  ambienceTimeoutIds = [];
}

// SFX
function playTone(freq, duration, type = 'sine', vol = 0.15) {
  if (audioMuted || !audioCtx) return;
  ensureAudio();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(sfxGain);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function sfxTap() { playTone(600, 0.05, 'sine', 0.1); }
function sfxPlant() { playTone(400, 0.2, 'sine', 0.12); }
function sfxFeed() { playTone(800, 0.15, 'sine', 0.1); }
function sfxBirth() {
  playTone(523, 0.1, 'sine', 0.12);
  setTimeout(() => playTone(659, 0.1, 'sine', 0.1), 100);
}
function sfxDeath() {
  playTone(300, 0.15, 'sine', 0.1);
  setTimeout(() => playTone(200, 0.2, 'sine', 0.08), 150);
}

// Ambient bird chirps
let lastChirpTime = 0;
function maybeChirp() {
  if (!audioCtx || audioMuted) return;
  const now = gameTime;
  if (now - lastChirpTime < 4 + Math.random() * 8) return;
  if (creatures.filter(c => c.type === 'bird').length === 0) return;
  lastChirpTime = now;
  
  const baseFreq = 1200 + Math.random() * 800;
  const vol = 0.03;
  playTone(baseFreq, 0.06, 'sine', vol);
  setTimeout(() => playTone(baseFreq * 1.2, 0.04, 'sine', vol * 0.8), 80);
  setTimeout(() => playTone(baseFreq * 0.9, 0.05, 'sine', vol * 0.6), 180);
}

// ============================================================
// DRAWING HELPERS ‚Äî Watercolor aesthetic
// ============================================================
function wobble(amt = 1.5) { return (Math.random() - 0.5) * amt * scale; }

// Soft watercolor circle ‚Äî reduced layers when many entities on screen
function watercolorCircle(cx, cy, r, color, alpha = 0.3) {
  ctx.save();

  // Reduce layers when performance matters (many entities)
  const entityCount = creatures.length + plants.length;
  const layers = entityCount > 30 ? 1 : entityCount > 15 ? 2 : 3;
  const pts = entityCount > 30 ? 12 : 16;
  for (let i = 0; i < layers; i++) {
    ctx.beginPath();
    for (let j = 0; j <= pts; j++) {
      const a = (j / pts) * Math.PI * 2;
      const rr = r + (Math.random() - 0.5) * r * 0.15;
      const px = cx + Math.cos(a) * rr + wobble(1);
      const py = cy + Math.sin(a) * rr + wobble(1);
      if (j === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();

    ctx.fillStyle = color;
    ctx.globalAlpha = alpha / layers;
    ctx.fill();
  }

  ctx.restore();
}

// Organic blob shape
function organicBlob(cx, cy, r, color, alpha = 0.25) {
  ctx.save();
  ctx.beginPath();
  
  const pts = 12;
  const angles = [];
  for (let i = 0; i < pts; i++) {
    angles.push((i / pts) * Math.PI * 2 + (Math.random() - 0.5) * 0.3);
  }
  angles.sort((a, b) => a - b);
  
  for (let i = 0; i <= pts; i++) {
    const a = angles[i % pts];
    const rr = r * (0.7 + Math.random() * 0.6);
    const px = cx + Math.cos(a) * rr;
    const py = cy + Math.sin(a) * rr;
    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.closePath();
  
  ctx.fillStyle = color;
  ctx.globalAlpha = alpha;
  ctx.fill();
  
  ctx.restore();
}

// Soft line
function softLine(x1, y1, x2, y2, color, width = 2, alpha = 0.6) {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = width * scale;
  ctx.lineCap = 'round';
  ctx.globalAlpha = alpha;
  ctx.beginPath();
  ctx.moveTo(x1 + wobble(0.3), y1 + wobble(0.3));
  const steps = Math.max(2, Math.floor(Math.hypot(x2 - x1, y2 - y1) / (15 * scale)));
  for (let i = 1; i <= steps; i++) {
    const t = i / steps;
    ctx.lineTo(
      x1 + (x2 - x1) * t + wobble(0.5),
      y1 + (y2 - y1) * t + wobble(0.5)
    );
  }
  ctx.stroke();
  ctx.restore();
}

// Text with natural style
function drawText(text, x, y, size = 14, color = '#3d5a3d', align = 'center', alpha = 1) {
  ctx.save();
  ctx.fillStyle = color;
  ctx.font = `${size * scale}px Georgia, serif`;
  ctx.textAlign = align;
  ctx.textBaseline = 'middle';
  ctx.globalAlpha = alpha;
  ctx.fillText(text, x, y);
  ctx.restore();
}

// ============================================================
// PARTICLES
// ============================================================
function spawnParticles(x, y, count, color, spread = 2) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * spread * scale,
      vy: (Math.random() - 0.5) * spread * scale - scale,
      life: 1,
      decay: 0.015 + Math.random() * 0.015,
      size: (2 + Math.random() * 3) * scale,
      color
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1 * scale;
    p.life -= p.decay;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = p.life * 0.6;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ============================================================
// TIME & WEATHER SYSTEM
// ============================================================
function updateTimeOfDay() {
  const now = new Date();
  const hour = now.getHours();
  
  if (hour >= 5 && hour < 7) timeOfDay = 'dawn';
  else if (hour >= 7 && hour < 17) timeOfDay = 'day';
  else if (hour >= 17 && hour < 19) timeOfDay = 'dusk';
  else timeOfDay = 'night';
}

function updateWeather() {
  // Simple weather simulation based on ecosystem health and randomness
  const rand = Math.random();
  
  if (ecosystemHealth > 80) {
    weather = rand < 0.7 ? 'sunny' : 'clear';
  } else if (ecosystemHealth > 50) {
    weather = rand < 0.5 ? 'clear' : (rand < 0.8 ? 'rain' : 'sunny');
  } else {
    weather = rand < 0.4 ? 'storm' : (rand < 0.7 ? 'rain' : 'clear');
  }
}

function getTimeColor() {
  switch(timeOfDay) {
    case 'dawn': return { sky: '#ffd89b', skyLow: '#ffe4c4', tint: 'rgba(255, 216, 155, 0.2)', ground: '#d6e8c0', water: '#a3c8c8' };
    case 'day': return { sky: '#87CEEB', skyLow: '#c8e6f0', tint: 'rgba(135, 206, 235, 0.1)', ground: '#c8e6c9', water: '#b3d9d9' };
    case 'dusk': return { sky: '#ff8c69', skyLow: '#ffb088', tint: 'rgba(255, 140, 105, 0.25)', ground: '#c4c098', water: '#9ab5b5' };
    case 'night': return { sky: '#1a2a3a', skyLow: '#2c3e50', tint: 'rgba(20, 30, 50, 0.45)', ground: '#5a6e5a', water: '#4a6a7a' };
  }
}

// Pre-generate star positions (deterministic)
const stars = [];
for (let i = 0; i < 60; i++) {
  stars.push({ x: (Math.sin(i * 127.1) * 0.5 + 0.5), y: (Math.cos(i * 311.7) * 0.3 + 0.15), size: 0.5 + (i % 3) * 0.5, twinklePhase: i * 1.7 });
}

// ============================================================
// ECOSYSTEM SIMULATION
// ============================================================

// Species definitions
const SPECIES = {
  // PLANTS
  grass: { type: 'plant', color: '#7cb342', growthRate: 0.8, maxSize: 25, shape: 'stem' },
  bush: { type: 'plant', color: '#558b2f', growthRate: 0.5, maxSize: 35, shape: 'bushy' },
  reed: { type: 'plant', color: '#9ccc65', growthRate: 0.6, maxSize: 45, shape: 'tall' },
  
  // FISH
  minnow: { type: 'fish', color: '#ff8a65', speed: 1.5, size: 8, diet: 'plant', predator: false },
  carp: { type: 'fish', color: '#ffb74d', speed: 1.0, size: 12, diet: 'plant', predator: false },
  pike: { type: 'fish', color: '#d84315', speed: 2.0, size: 16, diet: 'meat', predator: true },
  
  // BIRDS
  sparrow: { type: 'bird', color: '#8d6e63', speed: 2.5, size: 6, diet: 'seed', predator: false },
  hawk: { type: 'bird', color: '#5d4037', speed: 3.0, size: 10, diet: 'meat', predator: true },
  
  // INSECTS
  butterfly: { type: 'insect', color: '#f48fb1', speed: 1.2, size: 4, diet: 'plant', predator: false },
  dragonfly: { type: 'insect', color: '#64b5f6', speed: 2.0, size: 5, diet: 'insect', predator: true },

  // AMPHIBIANS
  frog: { type: 'amphibian', color: '#66bb6a', speed: 0.8, size: 10, diet: 'insect', predator: true },

  // MOLLUSKS
  snail: { type: 'mollusk', color: '#a1887f', speed: 0.2, size: 7, diet: 'plant', predator: false }
};

function spawnCreature(speciesName, x, y) {
  const spec = SPECIES[speciesName];
  if (!spec) return null;
  
  const creature = {
    id: Date.now() + Math.random(),
    species: speciesName,
    type: spec.type,
    x: x || Math.random() * W,
    y: y || Math.random() * H * 0.7 + H * 0.1,
    vx: (Math.random() - 0.5) * spec.speed * scale,
    vy: (Math.random() - 0.5) * spec.speed * scale,
    size: spec.size * scale * (0.8 + Math.random() * 0.4), // variation
    color: spec.color,
    hue: Math.random() * 20 - 10, // color variation
    speed: spec.speed,
    age: 0,
    maxAge: 120 + Math.random() * 180, // 2-5 minutes lifespan
    hunger: 0,
    health: 100,
    reproductionCooldown: 30,
    diet: spec.diet,
    predator: spec.predator || false,
    targetX: null,
    targetY: null,
    phase: Math.random() * Math.PI * 2
  };
  
  creatures.push(creature);
  sfxBirth();
  addJournalEntry(`${capitalize(speciesName)} arrived!`);
  return creature;
}

function spawnPlant(speciesName, x, y) {
  const spec = SPECIES[speciesName];
  if (!spec || spec.type !== 'plant') return null;
  
  const plant = {
    id: Date.now() + Math.random(),
    species: speciesName,
    type: 'plant',
    x: x || Math.random() * W,
    y: y || H * 0.75 + Math.random() * H * 0.2,
    size: 5 * scale, // starts small
    maxSize: spec.maxSize * scale * (0.8 + Math.random() * 0.4),
    growthRate: spec.growthRate,
    color: spec.color,
    hue: Math.random() * 30 - 15,
    age: 0,
    maxAge: 240 + Math.random() * 240, // 4-8 minutes
    health: 100,
    shape: spec.shape,
    watered: false,
    lastWater: 0
  };
  
  plants.push(plant);
  sfxPlant();
  return plant;
}

function updateCreatures() {
  for (let i = creatures.length - 1; i >= 0; i--) {
    const c = creatures[i];
    
    // Age and hunger
    c.age += deltaTime;
    c.hunger += deltaTime * 0.5;
    c.phase += deltaTime * 2;
    c.reproductionCooldown -= deltaTime;
    
    // Death from old age or starvation
    if (c.age > c.maxAge || c.hunger > 60) {
      creatures.splice(i, 1);
      spawnParticles(c.x, c.y, 5, '#666', 1);
      sfxDeath();
      ecosystemHealth = Math.max(0, ecosystemHealth - 2);
      continue;
    }
    
    // Movement behavior
    if (!c.targetX || Math.hypot(c.x - c.targetX, c.y - c.targetY) < 20 * scale) {
      // Pick new random target
      c.targetX = Math.random() * W;
      if (c.type === 'fish') {
        c.targetY = H * 0.4 + Math.random() * H * 0.3; // water zone
      } else if (c.type === 'bird') {
        c.targetY = H * 0.1 + Math.random() * H * 0.3; // sky zone
      } else if (c.type === 'amphibian') {
        c.targetY = H * 0.5 + Math.random() * H * 0.3; // water/ground edge
      } else if (c.type === 'mollusk') {
        c.targetY = H * 0.7 + Math.random() * H * 0.2; // ground zone
      } else {
        c.targetY = H * 0.3 + Math.random() * H * 0.5; // mid zone
      }
    }
    
    // Move toward target
    const dx = c.targetX - c.x;
    const dy = c.targetY - c.y;
    const dist = Math.hypot(dx, dy);
    if (dist > 1) {
      c.vx = (dx / dist) * c.speed * scale;
      c.vy = (dy / dist) * c.speed * scale;
    }
    
    c.x += c.vx * deltaTime * 10;
    c.y += c.vy * deltaTime * 10;
    
    // Bounds wrap
    if (c.x < 0) c.x = W;
    if (c.x > W) c.x = 0;
    c.y = Math.max(H * 0.05, Math.min(H * 0.95, c.y));
    
    // Feeding behavior
    if (c.hunger > 20 && Math.random() < 0.01) {
      if (c.diet === 'plant') {
        // Look for plants
        const nearbyPlant = plants.find(p => Math.hypot(p.x - c.x, p.y - c.y) < 40 * scale && p.size > 10 * scale);
        if (nearbyPlant) {
          nearbyPlant.size *= 0.9; // nibble
          c.hunger -= 5;
          spawnParticles(c.x, c.y, 2, '#9ccc65', 0.5);
        }
      } else if (c.diet === 'meat' && c.predator) {
        // Hunt prey
        const prey = creatures.find(other => 
          other.id !== c.id && 
          !other.predator && 
          Math.hypot(other.x - c.x, other.y - c.y) < 50 * scale
        );
        if (prey) {
          creatures.splice(creatures.indexOf(prey), 1);
          c.hunger -= 20;
          spawnParticles(prey.x, prey.y, 8, '#d84315', 2);
          sfxDeath();
          ecosystemHealth = Math.max(0, ecosystemHealth - 1);
        }
      }
    }
    
    // Reproduction
    if (c.age > 20 && c.hunger < 30 && c.reproductionCooldown <= 0 && creatures.length < 50) {
      const mate = creatures.find(other => 
        other.species === c.species && 
        other.id !== c.id && 
        Math.hypot(other.x - c.x, other.y - c.y) < 60 * scale &&
        other.reproductionCooldown <= 0
      );
      if (mate) {
        spawnCreature(c.species, (c.x + mate.x) / 2, (c.y + mate.y) / 2);
        c.reproductionCooldown = 60;
        mate.reproductionCooldown = 60;
        ecosystemHealth = Math.min(100, ecosystemHealth + 1);
      }
    }
  }
}

function updatePlants() {
  for (let i = plants.length - 1; i >= 0; i--) {
    const p = plants[i];
    
    p.age += deltaTime;
    p.lastWater += deltaTime;
    
    // Growth
    if (p.size < p.maxSize) {
      let growth = p.growthRate * deltaTime * scale * 0.5;
      if (p.watered && p.lastWater < 30) growth *= 2; // watered boost
      p.size += growth;
    }
    
    // Death from age
    if (p.age > p.maxAge) {
      plants.splice(i, 1);
      spawnParticles(p.x, p.y, 4, '#7cb342', 1);
      continue;
    }
  }
}

function updateEcosystem() {
  // Natural spawning based on ecosystem balance
  if (Math.random() < 0.001 && plants.length < 30) {
    const plantTypes = ['grass', 'bush', 'reed'];
    spawnPlant(plantTypes[Math.floor(Math.random() * plantTypes.length)]);
  }
  
  // Calculate ecosystem health
  const plantCount = plants.length;
  const herbivoreCount = creatures.filter(c => !c.predator && c.diet !== 'meat').length;
  const predatorCount = creatures.filter(c => c.predator).length;
  
  // Frog spawning: attracted by insects
  const insectCount = creatures.filter(c => c.type === 'insect').length;
  const frogCount = creatures.filter(c => c.type === 'amphibian').length;
  if (insectCount >= 3 && frogCount < 3 && Math.random() < 0.0005) {
    spawnCreature('frog');
    addJournalEntry('Insects attracted a frog!');
  }

  // Snail spawning: attracted by plants
  const snailCount = creatures.filter(c => c.type === 'mollusk').length;
  if (plantCount > 8 && snailCount < 4 && Math.random() < 0.0004) {
    spawnCreature('snail');
    addJournalEntry('Plants attracted a snail!');
  }

  // Ideal ratios: plants > herbivores > predators
  let healthDelta = 0;
  if (plantCount > 10) healthDelta += 0.1;
  if (herbivoreCount > 5 && herbivoreCount < 20) healthDelta += 0.1;
  if (predatorCount < herbivoreCount * 0.3) healthDelta += 0.05;
  if (predatorCount > herbivoreCount) healthDelta -= 0.3;
  
  ecosystemHealth = Math.max(0, Math.min(100, ecosystemHealth + healthDelta * deltaTime));
  
  // Days survived
  daysSurvived = Math.floor(simulationTime / 60); // 1 day = 1 minute
}

// ============================================================
// PHONE USAGE SIMULATION
// ============================================================
function updateSimulatedUsage() {
  const now = Date.now();
  const elapsed = (now - simulatedUsage.lastUpdateTime) / 1000;
  simulatedUsage.lastUpdateTime = now;
  
  // Simulate passive accumulation
  simulatedUsage.screenTimeToday += elapsed / 3600 * 0.5; // slow accumulation
  simulatedUsage.phoneFreeMins += elapsed / 60; // counts up when page is open
  
  // Apply usage effects to ecosystem
  if (simulatedUsage.screenTimeToday > 2 && Math.random() < 0.0005) {
    // Spawn predator
    const predators = ['pike', 'hawk'];
    spawnCreature(predators[Math.floor(Math.random() * predators.length)]);
    addJournalEntry('Screen time spawned a predator');
  }
  
  if (simulatedUsage.phoneFreeMins > 10 && Math.random() < 0.001) {
    // Spawn herbivore or passive creature
    const herbivores = ['minnow', 'carp', 'sparrow', 'butterfly', 'snail'];
    spawnCreature(herbivores[Math.floor(Math.random() * herbivores.length)]);
    addJournalEntry('Peaceful time attracted wildlife');
  }
  
  if (simulatedUsage.musicMinutes > 30 && Math.random() < 0.0008) {
    // Spawn bird
    const birds = ['sparrow'];
    spawnCreature(birds[0]);
    addJournalEntry('Music attracted birds');
  }
}

// ============================================================
// SEASONS
// ============================================================
function updateSeason() {
  seasonTimer += deltaTime * timeLapseSpeed;
  if (seasonTimer >= SEASON_DURATION) {
    seasonTimer = 0;
    const seasons = ['spring', 'summer', 'autumn', 'winter'];
    const idx = seasons.indexOf(currentSeason);
    currentSeason = seasons[(idx + 1) % 4];
    addJournalEntry(`Season changed to ${capitalize(currentSeason)}`);

    // Season effects on ecosystem
    if (currentSeason === 'spring') {
      // Plants grow faster, spawn new ones
      for (let i = 0; i < 3; i++) {
        if (plants.length < 40) {
          spawnPlant(['grass', 'bush', 'reed'][Math.floor(Math.random() * 3)]);
        }
      }
      ecosystemHealth = Math.min(100, ecosystemHealth + 5);
    } else if (currentSeason === 'winter') {
      // Slower growth, some creatures may not survive
      ecosystemHealth = Math.max(0, ecosystemHealth - 5);
    }
  }
}

function getSeasonTint() {
  switch(currentSeason) {
    case 'spring': return { tint: 'rgba(144, 238, 144, 0.08)', groundHue: '#c8e6c9' };
    case 'summer': return { tint: 'rgba(255, 235, 59, 0.06)', groundHue: '#a5d6a7' };
    case 'autumn': return { tint: 'rgba(255, 152, 0, 0.1)', groundHue: '#ffe0b2' };
    case 'winter': return { tint: 'rgba(200, 220, 240, 0.15)', groundHue: '#e0e0e0' };
  }
}

// ============================================================
// BIODIVERSITY INDEX (Shannon-Wiener inspired)
// ============================================================
function getBiodiversityIndex() {
  const allOrganisms = [...creatures, ...plants];
  if (allOrganisms.length === 0) return 0;

  const counts = {};
  for (const org of allOrganisms) {
    const sp = org.species;
    counts[sp] = (counts[sp] || 0) + 1;
  }

  const total = allOrganisms.length;
  const speciesCount = Object.keys(counts).length;
  if (speciesCount <= 1) return 0;

  // Shannon index: H = -sum(pi * ln(pi))
  let H = 0;
  for (const sp in counts) {
    const pi = counts[sp] / total;
    if (pi > 0) H -= pi * Math.log(pi);
  }

  // Normalize to 0-100 based on max possible (ln of species count)
  const maxH = Math.log(speciesCount);
  return maxH > 0 ? Math.round((H / maxH) * 100) : 0;
}

// ============================================================
// DRAWING
// ============================================================
function drawBackground() {
  // Paper texture
  ctx.fillStyle = '#f5f0e6';
  ctx.fillRect(0, 0, W, H);

  const timeColor = getTimeColor();

  // Sky layer (top 40%) ‚Äî richer gradient
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.45);
  skyGrad.addColorStop(0, timeColor.sky);
  skyGrad.addColorStop(0.6, timeColor.skyLow);
  skyGrad.addColorStop(1, 'rgba(245, 240, 230, 0.3)');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H * 0.45);

  // Stars at night / dusk
  if (timeOfDay === 'night' || timeOfDay === 'dusk') {
    const starAlpha = timeOfDay === 'night' ? 0.8 : 0.25;
    ctx.save();
    ctx.fillStyle = '#fff';
    for (const s of stars) {
      const twinkle = 0.5 + 0.5 * Math.sin(gameTime * 1.5 + s.twinklePhase);
      ctx.globalAlpha = starAlpha * twinkle;
      ctx.beginPath();
      ctx.arc(s.x * W, s.y * H, s.size * scale, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  // Sun or moon
  const celestialX = W * 0.8;
  const celestialY = H * 0.1;
  if (timeOfDay === 'day' || timeOfDay === 'dawn') {
    // Sun
    ctx.save();
    ctx.globalAlpha = timeOfDay === 'dawn' ? 0.5 : 0.7;
    const sunR = 18 * scale;
    const sunGlow = ctx.createRadialGradient(celestialX, celestialY, sunR * 0.3, celestialX, celestialY, sunR * 2.5);
    sunGlow.addColorStop(0, 'rgba(255,230,100,0.6)');
    sunGlow.addColorStop(1, 'rgba(255,230,100,0)');
    ctx.fillStyle = sunGlow;
    ctx.fillRect(celestialX - sunR * 3, celestialY - sunR * 3, sunR * 6, sunR * 6);
    ctx.fillStyle = '#ffe066';
    ctx.beginPath();
    ctx.arc(celestialX, celestialY, sunR, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  } else if (timeOfDay === 'night') {
    // Moon
    ctx.save();
    ctx.globalAlpha = 0.75;
    const moonR = 14 * scale;
    const moonGlow = ctx.createRadialGradient(celestialX, celestialY, moonR * 0.5, celestialX, celestialY, moonR * 2);
    moonGlow.addColorStop(0, 'rgba(200,220,255,0.3)');
    moonGlow.addColorStop(1, 'rgba(200,220,255,0)');
    ctx.fillStyle = moonGlow;
    ctx.fillRect(celestialX - moonR * 3, celestialY - moonR * 3, moonR * 6, moonR * 6);
    ctx.fillStyle = '#e8eef5';
    ctx.beginPath();
    ctx.arc(celestialX, celestialY, moonR, 0, Math.PI * 2);
    ctx.fill();
    // Crescent shadow
    ctx.globalCompositeOperation = 'destination-out';
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(celestialX + moonR * 0.4, celestialY - moonR * 0.2, moonR * 0.85, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();
  }

  // Sky blobs (clouds) ‚Äî fewer at night
  const cloudCount = timeOfDay === 'night' ? 5 : 12;
  const cloudAlpha = timeOfDay === 'night' ? 0.12 : 0.3;
  for (let i = 0; i < cloudCount; i++) {
    const x = (i / cloudCount) * W + (Math.sin(gameTime * 0.3 + i) * 30 * scale);
    const y = H * 0.15 + Math.sin(i * 2) * H * 0.1;
    const r = (30 + Math.random() * 40) * scale;
    organicBlob(x, y, r, timeOfDay === 'night' ? '#4a5a6a' : '#d4e9f7', cloudAlpha);
  }

  // Water layer (middle 30%)
  for (let i = 0; i < 15; i++) {
    const x = (i / 15) * W * 1.2 - W * 0.1;
    const y = H * 0.45 + Math.sin(gameTime * 0.5 + i * 0.5) * 10 * scale;
    const r = (40 + Math.random() * 60) * scale;
    organicBlob(x, y, r, timeColor.water, 0.25);
  }

  // Ground layer (bottom 30%) - season-tinted
  const seasonStyle = getSeasonTint();
  for (let i = 0; i < 20; i++) {
    const x = (i / 20) * W * 1.3 - W * 0.15;
    const y = H * 0.75 + Math.sin(i * 1.5) * 20 * scale;
    const r = (35 + Math.random() * 50) * scale;
    organicBlob(x, y, r, seasonStyle.groundHue, 0.28);
  }

  // Time of day tint
  ctx.save();
  ctx.fillStyle = timeColor.tint;
  ctx.fillRect(0, 0, W, H);
  ctx.restore();

  // Season tint overlay
  ctx.save();
  ctx.fillStyle = seasonStyle.tint;
  ctx.fillRect(0, 0, W, H);
  ctx.restore();

  // Seasonal particles
  if (currentSeason === 'spring') {
    // Floating blossom petals
    for (let i = 0; i < 6; i++) {
      const px = ((gameTime * 20 + i * 70) % (W + 40)) - 20;
      const py = ((gameTime * 15 + i * 90 + Math.sin(gameTime + i) * 30) % (H * 0.7));
      ctx.save();
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#ffb7c5';
      ctx.beginPath();
      ctx.ellipse(px, py, 3 * scale, 2 * scale, gameTime + i, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  } else if (currentSeason === 'autumn') {
    // Falling leaves
    for (let i = 0; i < 8; i++) {
      const px = ((gameTime * 12 + i * 55) % (W + 40)) - 20;
      const py = ((gameTime * 25 + i * 80) % (H * 0.8));
      const leafColors = ['#ff8a65', '#ffb74d', '#d84315', '#c62828'];
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = leafColors[i % leafColors.length];
      ctx.beginPath();
      ctx.ellipse(px, py, 4 * scale, 2.5 * scale, Math.sin(gameTime * 2 + i) * 0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  } else if (currentSeason === 'winter') {
    // Snowflakes
    for (let i = 0; i < 12; i++) {
      const px = ((gameTime * 8 + i * 40 + Math.sin(gameTime * 0.5 + i) * 20) % (W + 20)) - 10;
      const py = ((gameTime * 18 + i * 60) % (H + 20)) - 10;
      ctx.save();
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(px, py, (1.5 + Math.sin(i) * 0.5) * scale, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }


  // Weather effects
  if (weather === 'rain' || weather === 'storm') {
    drawRain(weather === 'storm' ? 80 : 40);
  }
}

function drawRain(drops) {
  ctx.save();
  ctx.strokeStyle = 'rgba(200, 220, 240, 0.4)';
  ctx.lineWidth = 1;
  for (let i = 0; i < drops; i++) {
    const x = ((gameTime * 100 + i * 50) % (W + 100)) - 50;
    const y = ((gameTime * 200 + i * 30) % (H + 50)) - 25;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + 3 * scale, y + 15 * scale);
    ctx.stroke();
  }
  ctx.restore();
}

function drawPlants() {
  for (const p of plants) {
    ctx.save();
    
    // Color with hue shift
    const baseHue = p.color;
    
    if (p.shape === 'stem') {
      // Simple grass stem
      const stemH = p.size * 1.5;
      // Gentle sway
      const sway = Math.sin(gameTime * 1.5 + p.x * 0.01) * 3 * scale;
      softLine(p.x, p.y, p.x + sway, p.y - stemH, p.color, 1.5, 0.7);
      
      // Leaves
      const leafCount = Math.floor(p.size / (8 * scale));
      for (let i = 0; i < leafCount; i++) {
        const leafY = p.y - (i / leafCount) * stemH;
        const leafR = p.size * 0.3;
        const leafSway = sway * (i / leafCount);
        watercolorCircle(p.x + leafSway - leafR * 0.5, leafY, leafR, p.color, 0.5);
        watercolorCircle(p.x + leafSway + leafR * 0.5, leafY, leafR, p.color, 0.5);
      }
      // Flower on tall plants
      if (p.size > 20 * scale) {
        const flowerColors = ['#ff8a9b', '#ffb347', '#ff6b8a', '#e88aff', '#ffda6b'];
        const fc = flowerColors[Math.floor(p.x * 7) % flowerColors.length];
        const fTop = p.y - stemH;
        watercolorCircle(p.x + sway, fTop - 2*scale, p.size * 0.25, fc, 0.6);
        // Petals
        for (let j = 0; j < 4; j++) {
          const pa = j * Math.PI / 2 + gameTime * 0.2;
          watercolorCircle(
            p.x + sway + Math.cos(pa) * p.size * 0.18,
            fTop - 2*scale + Math.sin(pa) * p.size * 0.18,
            p.size * 0.15, fc, 0.4);
        }
      }
    } else if (p.shape === 'bushy') {
      // Clustered circles
      const clusters = Math.floor(p.size / (10 * scale));
      for (let i = 0; i < clusters; i++) {
        const angle = (i / clusters) * Math.PI * 2;
        const offsetX = Math.cos(angle) * p.size * 0.3;
        const offsetY = Math.sin(angle) * p.size * 0.3;
        watercolorCircle(p.x + offsetX, p.y - p.size * 0.5 + offsetY, p.size * 0.4, p.color, 0.4);
      }
    } else if (p.shape === 'tall') {
      // Tall reed
      const stemH = p.size * 2;
      softLine(p.x, p.y, p.x + wobble(3), p.y - stemH, p.color, 2, 0.6);
      
      // Top tuft
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI - Math.PI / 2;
        const tX = p.x + Math.cos(angle) * p.size * 0.4;
        const tY = p.y - stemH + Math.sin(angle) * p.size * 0.2;
        softLine(p.x, p.y - stemH, tX, tY, p.color, 1, 0.5);
      }
    }
    
    ctx.restore();
  }
}

function drawCreatures() {
  for (const c of creatures) {
    ctx.save();
    
    if (c.type === 'fish') {
      // Simple fish shape: body + tail
      const bodyR = c.size * 0.8;
      const tailL = c.size * 0.6;
      
      // Body
      watercolorCircle(c.x, c.y, bodyR, c.color, 0.6);
      
      // Direction indicator
      const dirX = Math.sign(c.vx) || 1;
      
      // Tail triangle
      ctx.beginPath();
      ctx.moveTo(c.x - dirX * bodyR * 0.8, c.y);
      ctx.lineTo(c.x - dirX * (bodyR + tailL), c.y - tailL * 0.5);
      ctx.lineTo(c.x - dirX * (bodyR + tailL), c.y + tailL * 0.5);
      ctx.closePath();
      ctx.fillStyle = c.color;
      ctx.globalAlpha = 0.5;
      ctx.fill();
      
      // Eye
      ctx.fillStyle = '#333';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(c.x + dirX * bodyR * 0.3, c.y - bodyR * 0.2, bodyR * 0.15, 0, Math.PI * 2);
      ctx.fill();
      
    } else if (c.type === 'bird') {
      // Oval body
      const bodyW = c.size * 1.2;
      const bodyH = c.size * 0.8;
      
      ctx.beginPath();
      ctx.ellipse(c.x, c.y, bodyW, bodyH, 0, 0, Math.PI * 2);
      ctx.fillStyle = c.color;
      ctx.globalAlpha = 0.6;
      ctx.fill();
      
      // Wing flap
      const wingFlap = Math.sin(c.phase * 4) * c.size * 0.5;
      const dirX = Math.sign(c.vx) || 1;
      
      // Wings
      ctx.beginPath();
      ctx.moveTo(c.x, c.y);
      ctx.lineTo(c.x - bodyW * 1.2, c.y + wingFlap);
      ctx.strokeStyle = c.color;
      ctx.lineWidth = 2 * scale;
      ctx.globalAlpha = 0.5;
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(c.x, c.y);
      ctx.lineTo(c.x + bodyW * 1.2, c.y - wingFlap);
      ctx.stroke();
      
      // Head
      watercolorCircle(c.x + dirX * bodyW * 0.5, c.y - bodyH * 0.3, c.size * 0.4, c.color, 0.7);
      
      // Beak
      ctx.beginPath();
      ctx.moveTo(c.x + dirX * bodyW * 0.7, c.y - bodyH * 0.3);
      ctx.lineTo(c.x + dirX * bodyW * 1.1, c.y - bodyH * 0.2);
      ctx.strokeStyle = '#ff8a50';
      ctx.lineWidth = 1.5 * scale;
      ctx.globalAlpha = 0.8;
      ctx.stroke();
      
    } else if (c.type === 'insect') {
      // Body segments
      const segR = c.size * 0.3;
      watercolorCircle(c.x, c.y, segR, c.color, 0.5);
      watercolorCircle(c.x - segR * 1.5, c.y, segR * 0.8, c.color, 0.5);
      watercolorCircle(c.x + segR * 1.5, c.y, segR * 1.2, c.color, 0.5);

      // Wings (fluttering)
      const wingFlap = Math.abs(Math.sin(c.phase * 6)) * c.size * 0.8;

      ctx.beginPath();
      ctx.ellipse(c.x, c.y - wingFlap, c.size * 0.6, c.size * 1.2, -Math.PI / 6, 0, Math.PI * 2);
      ctx.fillStyle = c.color;
      ctx.globalAlpha = 0.3;
      ctx.fill();

      ctx.beginPath();
      ctx.ellipse(c.x, c.y - wingFlap, c.size * 0.6, c.size * 1.2, Math.PI / 6, 0, Math.PI * 2);
      ctx.fill();

    } else if (c.type === 'amphibian') {
      // Frog: squat body with big eyes and legs
      const bodyW = c.size * 1.2;
      const bodyH = c.size * 0.7;
      const dirX = Math.sign(c.vx) || 1;

      // Body
      ctx.beginPath();
      ctx.ellipse(c.x, c.y, bodyW, bodyH, 0, 0, Math.PI * 2);
      ctx.fillStyle = c.color;
      ctx.globalAlpha = 0.6;
      ctx.fill();

      // Belly (lighter)
      ctx.beginPath();
      ctx.ellipse(c.x, c.y + bodyH * 0.2, bodyW * 0.7, bodyH * 0.5, 0, 0, Math.PI * 2);
      ctx.fillStyle = '#a5d6a7';
      ctx.globalAlpha = 0.4;
      ctx.fill();

      // Eyes (two big circles on top)
      const eyeOffX = bodyW * 0.5;
      const eyeY = c.y - bodyH * 0.7;
      const eyeR = c.size * 0.3;
      // Left eye
      watercolorCircle(c.x - eyeOffX * 0.5, eyeY, eyeR, '#fff', 0.8);
      ctx.fillStyle = '#333';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.arc(c.x - eyeOffX * 0.5 + dirX * eyeR * 0.2, eyeY, eyeR * 0.5, 0, Math.PI * 2);
      ctx.fill();
      // Right eye
      watercolorCircle(c.x + eyeOffX * 0.5, eyeY, eyeR, '#fff', 0.8);
      ctx.fillStyle = '#333';
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.arc(c.x + eyeOffX * 0.5 + dirX * eyeR * 0.2, eyeY, eyeR * 0.5, 0, Math.PI * 2);
      ctx.fill();

      // Back legs
      const legBend = Math.sin(c.phase * 3) * c.size * 0.3;
      ctx.strokeStyle = c.color;
      ctx.lineWidth = 2 * scale;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(c.x - bodyW * 0.6, c.y + bodyH * 0.5);
      ctx.lineTo(c.x - bodyW * 1.0, c.y + bodyH + legBend);
      ctx.lineTo(c.x - bodyW * 1.3, c.y + bodyH * 0.3 + legBend);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(c.x + bodyW * 0.6, c.y + bodyH * 0.5);
      ctx.lineTo(c.x + bodyW * 1.0, c.y + bodyH + legBend);
      ctx.lineTo(c.x + bodyW * 1.3, c.y + bodyH * 0.3 + legBend);
      ctx.stroke();

    } else if (c.type === 'mollusk') {
      // Snail: spiral shell + soft body
      const bodyLen = c.size * 1.5;
      const bodyH = c.size * 0.4;
      const dirX = Math.sign(c.vx) || 1;

      // Body (elongated blob)
      ctx.beginPath();
      ctx.ellipse(c.x + dirX * bodyLen * 0.2, c.y + bodyH * 0.3, bodyLen * 0.7, bodyH, 0, 0, Math.PI * 2);
      ctx.fillStyle = '#bcaaa4';
      ctx.globalAlpha = 0.5;
      ctx.fill();

      // Shell (spiral circle)
      const shellX = c.x - dirX * bodyLen * 0.1;
      const shellY = c.y - c.size * 0.3;
      const shellR = c.size * 0.7;
      watercolorCircle(shellX, shellY, shellR, c.color, 0.6);
      // Spiral lines
      ctx.strokeStyle = '#8d6e63';
      ctx.lineWidth = 1 * scale;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      for (let t = 0; t < Math.PI * 4; t += 0.2) {
        const sr = shellR * (1 - t / (Math.PI * 5));
        if (sr < 1) break;
        const sx = shellX + Math.cos(t) * sr;
        const sy = shellY + Math.sin(t) * sr;
        if (t === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
      }
      ctx.stroke();

      // Antennae (two stalks with eyes)
      const headX = c.x + dirX * bodyLen * 0.6;
      const headY = c.y;
      ctx.strokeStyle = '#bcaaa4';
      ctx.lineWidth = 1.5 * scale;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.moveTo(headX, headY);
      ctx.lineTo(headX + dirX * c.size * 0.3, headY - c.size * 0.6);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(headX, headY);
      ctx.lineTo(headX + dirX * c.size * 0.5, headY - c.size * 0.5);
      ctx.stroke();
      // Eye dots
      ctx.fillStyle = '#333';
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(headX + dirX * c.size * 0.3, headY - c.size * 0.6, 1.5 * scale, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(headX + dirX * c.size * 0.5, headY - c.size * 0.5, 1.5 * scale, 0, Math.PI * 2);
      ctx.fill();

      // Slime trail
      ctx.fillStyle = 'rgba(200, 220, 200, 0.15)';
      ctx.beginPath();
      ctx.ellipse(c.x - dirX * bodyLen * 0.3, c.y + bodyH * 0.5, bodyLen * 0.4, bodyH * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }
}

function drawUI() {
  // Header
  const headerH = 60 * scale;
  ctx.save();
  ctx.fillStyle = 'rgba(245, 240, 230, 0.9)';
  ctx.fillRect(0, 0, W, headerH);
  ctx.strokeStyle = 'rgba(100, 100, 100, 0.2)';
  ctx.lineWidth = 1;
  ctx.strokeRect(0, 0, W, headerH);
  ctx.restore();
  
  // Title
  drawText('Pocket Ecosystem', centerX, headerH * 0.35, 20, '#3d5a3d', 'center');
  
  // Day counter, time-of-day icon, season, and status
  const status = ecosystemHealth > 80 ? 'Thriving' : ecosystemHealth > 50 ? 'Balanced' : ecosystemHealth > 20 ? 'Struggling' : 'Critical';
  const statusColor = ecosystemHealth > 80 ? '#4caf50' : ecosystemHealth > 50 ? '#ff9800' : '#f44336';
  const todIcon = timeOfDay === 'dawn' ? 'üåÖ' : timeOfDay === 'day' ? '‚òÄÔ∏è' : timeOfDay === 'dusk' ? 'üåá' : 'üåô';
  const seasonIcon = currentSeason === 'spring' ? 'üå∏' : currentSeason === 'summer' ? '‚òÄÔ∏è' : currentSeason === 'autumn' ? 'üçÇ' : '‚ùÑÔ∏è';
  drawText(`${todIcon} Day ${daysSurvived} ‚Ä¢ ${seasonIcon} ${capitalize(currentSeason)} ‚Ä¢ ${status}`, centerX, headerH * 0.7, 11, statusColor, 'center', 0.8);

  // Ecosystem health meter (bottom info panel)
  const panelH = 95 * scale;
  const panelY = H - panelH;

  ctx.save();
  ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
  ctx.fillRect(0, panelY, W, panelH);
  ctx.strokeStyle = 'rgba(100, 100, 100, 0.2)';
  ctx.lineWidth = 1;
  ctx.strokeRect(0, panelY, W, panelH);
  ctx.restore();

  // Per-species creature counts
  const speciesCounts = {};
  creatures.forEach(c => { speciesCounts[c.species] = (speciesCounts[c.species] || 0) + 1; });

  // Stats - 3 rows
  const leftX = 15 * scale;
  const rightX = W - 15 * scale;
  const line1Y = panelY + 15 * scale;
  const line2Y = panelY + 33 * scale;
  const line3Y = panelY + 51 * scale;

  // Left side: species counts with detail
  drawText(`üå± ${plants.length}`, leftX, line1Y, 10, '#7cb342', 'left');
  drawText(`üêü ${creatures.filter(c => c.type === 'fish').length}`, leftX + 45 * scale, line1Y, 10, '#ff8a65', 'left');
  drawText(`ü¶Ö ${creatures.filter(c => c.type === 'bird').length}`, leftX + 80 * scale, line1Y, 10, '#8d6e63', 'left');

  drawText(`ü¶ã ${creatures.filter(c => c.type === 'insect').length}`, leftX, line2Y, 10, '#f48fb1', 'left');
  drawText(`üê∏ ${creatures.filter(c => c.type === 'amphibian').length}`, leftX + 45 * scale, line2Y, 10, '#66bb6a', 'left');
  drawText(`üêå ${creatures.filter(c => c.type === 'mollusk').length}`, leftX + 80 * scale, line2Y, 10, '#a1887f', 'left');

  drawText(`${creatures.length} creatures total`, leftX, line3Y, 8, '#999', 'left');

  // Health bar (right side)
  const barW = 100 * scale;
  const barH = 7 * scale;
  const barX = rightX - barW;
  const barY1 = line1Y - 3 * scale;

  ctx.save();
  ctx.fillStyle = '#e0e0e0';
  ctx.fillRect(barX, barY1, barW, barH);
  const healthColor = ecosystemHealth > 60 ? '#4caf50' : ecosystemHealth > 30 ? '#ff9800' : '#f44336';
  ctx.fillStyle = healthColor;
  ctx.fillRect(barX, barY1, barW * (ecosystemHealth / 100), barH);
  ctx.strokeStyle = 'rgba(0,0,0,0.2)';
  ctx.lineWidth = 1;
  ctx.strokeRect(barX, barY1, barW, barH);
  ctx.restore();
  drawText(`Health: ${Math.floor(ecosystemHealth)}%`, rightX, line1Y + 10 * scale, 9, '#666', 'right');

  // Biodiversity index
  const bioIdx = getBiodiversityIndex();
  const bioColor = bioIdx > 70 ? '#4caf50' : bioIdx > 40 ? '#ff9800' : '#f44336';
  drawText(`Biodiversity: ${bioIdx}%`, rightX, line2Y, 10, bioColor, 'right');

  // Time-lapse button
  const tlBtnX = centerX;
  const tlBtnY = line3Y;
  const tlBtnW = 80 * scale;
  const tlBtnH = 22 * scale;

  ctx.save();
  ctx.fillStyle = timeLapseActive ? 'rgba(76, 175, 80, 0.2)' : 'rgba(200, 200, 200, 0.3)';
  ctx.fillRect(tlBtnX - tlBtnW / 2, tlBtnY - tlBtnH / 2, tlBtnW, tlBtnH);
  ctx.strokeStyle = timeLapseActive ? '#4caf50' : '#999';
  ctx.lineWidth = 1;
  ctx.strokeRect(tlBtnX - tlBtnW / 2, tlBtnY - tlBtnH / 2, tlBtnW, tlBtnH);
  ctx.restore();
  drawText(timeLapseActive ? '‚è© x5 FAST' : '‚è© Time-lapse', tlBtnX, tlBtnY, 9, timeLapseActive ? '#4caf50' : '#666', 'center');


  // Mute button
  drawMuteButton();

  // Journal button
  drawJournalButton();
}

function drawMuteButton() {
  const btnX = W - 30 * scale;
  const btnY = 30 * scale;
  const btnSize = 24 * scale;
  
  const isHovering = Math.hypot(lastMouseX - btnX, lastMouseY - btnY) < btnSize;
  
  ctx.save();
  ctx.font = `${14 * scale}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = isHovering ? (audioMuted ? '#cc3333' : '#4caf50') : '#999';
  ctx.fillText(audioMuted ? 'üîá' : 'üîä', btnX, btnY);
  ctx.restore();
  
  muteButtonBounds = { x: btnX, y: btnY, size: btnSize };
}

function drawJournalButton() {
  const btnX = W - 65 * scale;
  const btnY = 30 * scale;
  const btnSize = 24 * scale;
  
  const isHovering = Math.hypot(lastMouseX - btnX, lastMouseY - btnY) < btnSize;
  
  ctx.save();
  ctx.font = `${14 * scale}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = isHovering ? '#4caf50' : '#999';
  ctx.fillText('üìñ', btnX, btnY);
  ctx.restore();
}

// ============================================================
// JOURNAL SYSTEM
// ============================================================
function addJournalEntry(text) {
  journalEntries.unshift({
    time: Date.now(),
    text: text,
    day: daysSurvived
  });
  
  // Keep last 20 entries
  if (journalEntries.length > 20) journalEntries.pop();
}

function drawJournal() {
  if (!showingJournal) return;
  
  // Overlay
  ctx.save();
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(0, 0, W, H);
  ctx.restore();
  
  // Journal panel
  const panelW = Math.min(W * 0.85, 400 * scale);
  const panelH = H * 0.7;
  const panelX = centerX - panelW / 2;
  const panelY = centerY - panelH / 2;
  
  ctx.save();
  ctx.fillStyle = '#faf8f3';
  ctx.fillRect(panelX, panelY, panelW, panelH);
  ctx.strokeStyle = '#8d7a5e';
  ctx.lineWidth = 2;
  ctx.strokeRect(panelX, panelY, panelW, panelH);
  ctx.restore();
  
  // Title
  drawText('Ecosystem Journal', centerX, panelY + 30 * scale, 18, '#3d5a3d', 'center');
  
  // Entries
  const entryStartY = panelY + 60 * scale;
  const entryH = 35 * scale;
  const maxVisible = Math.floor((panelH - 80 * scale) / entryH);
  
  for (let i = 0; i < Math.min(journalEntries.length, maxVisible); i++) {
    const entry = journalEntries[i];
    const entryY = entryStartY + i * entryH;
    
    // Entry box
    ctx.save();
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.fillRect(panelX + 10 * scale, entryY, panelW - 20 * scale, entryH - 5 * scale);
    ctx.strokeStyle = 'rgba(100, 100, 100, 0.2)';
    ctx.lineWidth = 1;
    ctx.strokeRect(panelX + 10 * scale, entryY, panelW - 20 * scale, entryH - 5 * scale);
    ctx.restore();
    
    // Day label
    drawText(`Day ${entry.day}`, panelX + 20 * scale, entryY + 12 * scale, 11, '#999', 'left');
    
    // Entry text
    drawText(entry.text, panelX + 20 * scale, entryY + 24 * scale, 11, '#333', 'left');
  }
  
  // Close button
  const closeX = panelX + panelW - 20 * scale;
  const closeY = panelY + 20 * scale;
  drawText('‚úï', closeX, closeY, 18, '#999', 'center');
}

// ============================================================
// INTERACTION
// ============================================================
// Ripple effects
let ripples = [];

function spawnRipple(x, y) {
  ripples.push({ x, y, r: 0, maxR: 40 * scale, life: 1, speed: 60 * scale });
}

function updateRipples() {
  for (let i = ripples.length - 1; i >= 0; i--) {
    const r = ripples[i];
    r.r += r.speed * deltaTime;
    r.life = 1 - r.r / r.maxR;
    if (r.life <= 0) ripples.splice(i, 1);
  }
}

function drawRipples() {
  for (const r of ripples) {
    ctx.save();
    ctx.globalAlpha = r.life * 0.4;
    ctx.strokeStyle = '#64b5f6';
    ctx.lineWidth = 2 * scale * r.life;
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);
    ctx.stroke();
    // Inner ring
    ctx.globalAlpha = r.life * 0.2;
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.r * 0.6, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }
}

function handleTap(x, y) {
  ensureAudio();
  sfxTap();
  spawnRipple(x, y);
  
  // Check mute button
  if (muteButtonBounds && Math.hypot(x - muteButtonBounds.x, y - muteButtonBounds.y) < muteButtonBounds.size) {
    toggleMute();
    return;
  }
  
  // Check journal button
  const journalBtnX = W - 65 * scale;
  const journalBtnY = 30 * scale;
  if (Math.hypot(x - journalBtnX, y - journalBtnY) < 20 * scale) {
    showingJournal = !showingJournal;
    return;
  }
  
  // Close journal if open
  if (showingJournal) {
    const panelW = Math.min(W * 0.85, 400 * scale);
    const panelH = H * 0.7;
    const panelX = centerX - panelW / 2;
    const panelY = centerY - panelH / 2;
    
    // Close button
    const closeX = panelX + panelW - 20 * scale;
    const closeY = panelY + 20 * scale;
    if (Math.hypot(x - closeX, y - closeY) < 15 * scale) {
      showingJournal = false;
      return;
    }
    
    // Click outside closes
    if (x < panelX || x > panelX + panelW || y < panelY || y > panelY + panelH) {
      showingJournal = false;
      return;
    }
  }
  
  // Check time-lapse button
  const panelH = 95 * scale;
  const panelY = H - panelH;
  const tlBtnX = centerX;
  const tlBtnY = panelY + 51 * scale;
  const tlBtnW = 80 * scale;
  const tlBtnH = 22 * scale;
  if (x >= tlBtnX - tlBtnW / 2 && x <= tlBtnX + tlBtnW / 2 &&
      y >= tlBtnY - tlBtnH / 2 && y <= tlBtnY + tlBtnH / 2) {
    timeLapseActive = !timeLapseActive;
    timeLapseSpeed = timeLapseActive ? 5 : 1;
    addJournalEntry(timeLapseActive ? 'Time-lapse activated (5x)' : 'Time-lapse deactivated');
    return;
  }

  // Tap on plant to water
  for (const p of plants) {
    if (Math.hypot(x - p.x, y - p.y) < p.size) {
      p.watered = true;
      p.lastWater = 0;
      p.size *= 1.05;
      spawnParticles(p.x, p.y, 8, '#64b5f6', 1);
      sfxFeed();
      ecosystemHealth = Math.min(100, ecosystemHealth + 0.5);
      return;
    }
  }
  
  // Tap on creature to feed
  for (const c of creatures) {
    if (Math.hypot(x - c.x, y - c.y) < c.size * 2) {
      c.hunger = Math.max(0, c.hunger - 10);
      spawnParticles(c.x, c.y, 5, '#ffeb3b', 1);
      sfxFeed();
      return;
    }
  }
  
  // Tap empty space: spawn seed/plant
  if (y > H * 0.6 && plants.length < 40) {
    const plantTypes = ['grass', 'bush', 'reed'];
    spawnPlant(plantTypes[Math.floor(Math.random() * plantTypes.length)], x, y);
  }
}

// ============================================================
// INPUT HANDLING
// ============================================================
function getEventPos(e) {
  if (e.touches) {
    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
  return { x: e.clientX, y: e.clientY };
}

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const pos = getEventPos(e);
  lastMouseX = pos.x;
  lastMouseY = pos.y;
  inputEvents.push({ type: 'tap', x: pos.x, y: pos.y });
  dragState.active = true;
  dragState.startX = pos.x;
  dragState.startY = pos.y;
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (dragState.active) {
    const pos = getEventPos(e);
    lastMouseX = pos.x;
    lastMouseY = pos.y;
  }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  dragState.active = false;
});

canvas.addEventListener('mousedown', (e) => {
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
  inputEvents.push({ type: 'tap', x: e.clientX, y: e.clientY });
  dragState.active = true;
  dragState.startX = e.clientX;
  dragState.startY = e.clientY;
});

canvas.addEventListener('mousemove', (e) => {
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
});

canvas.addEventListener('mouseup', (e) => {
  dragState.active = false;
});

// ============================================================
// PERSISTENCE (localStorage)
// ============================================================
function saveState() {
  const state = {
    creatures: creatures.map(c => ({...c})),
    plants: plants.map(p => ({...p})),
    ecosystemHealth,
    simulationTime,
    daysSurvived,
    journalEntries,
    simulatedUsage,
    currentSeason,
    seasonTimer,
    timestamp: Date.now()
  };
  
  try {
    localStorage.setItem('pocketEcosystem', JSON.stringify(state));
  } catch(e) {
    console.warn('Failed to save:', e);
  }
}

function loadState() {
  try {
    const saved = localStorage.getItem('pocketEcosystem');
    if (!saved) return false;
    
    const state = JSON.parse(saved);
    
    // Check if save is recent (< 24 hours)
    const age = Date.now() - state.timestamp;
    if (age > 24 * 60 * 60 * 1000) {
      console.log('Save too old, starting fresh');
      return false;
    }
    
    creatures = state.creatures || [];
    plants = state.plants || [];
    ecosystemHealth = state.ecosystemHealth || 100;
    simulationTime = state.simulationTime || 0;
    daysSurvived = state.daysSurvived || 0;
    journalEntries = state.journalEntries || [];
    simulatedUsage = state.simulatedUsage || simulatedUsage;
    currentSeason = state.currentSeason || 'spring';
    seasonTimer = state.seasonTimer || 0;

    // Simulate time passed while away
    const timePassed = age / 1000; // seconds
    simulationTime += timePassed;
    
    // Age creatures and plants
    for (const c of creatures) {
      c.age += timePassed;
    }
    for (const p of plants) {
      p.age += timePassed;
    }
    
    addJournalEntry(`Welcome back! ${Math.floor(timePassed / 60)} minutes passed.`);
    
    return true;
  } catch(e) {
    console.warn('Failed to load:', e);
    return false;
  }
}

// ============================================================
// INITIALIZATION
// ============================================================
function initEcosystem() {
  const loaded = loadState();
  
  if (!loaded) {
    // Fresh start
    addJournalEntry('Ecosystem created');
    
    // Starter plants
    for (let i = 0; i < 5; i++) {
      spawnPlant('grass', Math.random() * W, H * 0.8 + Math.random() * H * 0.15);
    }
    
    // Starter creatures
    spawnCreature('minnow');
    spawnCreature('sparrow');
    spawnCreature('butterfly');
  }
  
  updateTimeOfDay();
  updateWeather();
}

// ============================================================
// MAIN LOOP
// ============================================================
function update() {
  const now = performance.now() / 1000;
  deltaTime = Math.min(0.1, now - lastTime);
  lastTime = now;
  gameTime = now;
  simulationTime += deltaTime * timeLapseSpeed;
  
  // Process input
  for (const ev of inputEvents) {
    if (ev.type === 'tap') {
      handleTap(ev.x, ev.y);
    }
  }
  inputEvents = [];
  
  // Apply time-lapse speed to deltaTime for simulation
  const simDelta = deltaTime * timeLapseSpeed;
  const savedDelta = deltaTime;

  // Update simulation
  if (!showingJournal) {
    deltaTime = simDelta;
    updateSimulatedUsage();
    updateCreatures();
    updatePlants();
    updateEcosystem();
    updateSeason();
    deltaTime = savedDelta;
    updateParticles();
    maybeChirp();
  }
  
  // Update time of day every 10 seconds
  if (Math.floor(gameTime) % 10 === 0 && Math.floor(gameTime - deltaTime) % 10 !== 0) {
    updateTimeOfDay();
  }
  
  // Update weather every 30 seconds
  if (Math.floor(gameTime) % 30 === 0 && Math.floor(gameTime - deltaTime) % 30 !== 0) {
    updateWeather();
  }
  
  // Auto-save every 10 seconds
  if (now - lastSaveTime > 10) {
    saveState();
    lastSaveTime = now;
  }
}

function draw() {
  ctx.clearRect(0, 0, W, H);
  
  drawBackground();
  drawPlants();
  drawCreatures();
  drawParticles();
  updateRipples();
  drawRipples();
  drawUI();
  drawJournal();
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// Helper
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// ============================================================
// START
// ============================================================
initEcosystem();
gameLoop();

// Save on page unload
window.addEventListener('beforeunload', () => {
  saveState();
});

</script>
</body>
</html>
