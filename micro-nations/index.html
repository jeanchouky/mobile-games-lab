<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Micro Nations</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #1a3a52;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}
canvas {
  display: block;
  width: 100%; height: 100%;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}
#ui {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 10;
}
.panel {
  pointer-events: auto;
  background: rgba(245, 240, 230, 0.95);
  border: 2px solid #8B4513;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.btn {
  background: #4a90e2;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  font-size: 14px;
  cursor: pointer;
  margin: 4px;
}
.btn:active { background: #357abd; }
.btn.danger { background: #e74c3c; }
.btn.success { background: #27ae60; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui"></div>
<script>
'use strict';

// ============================================================
// MICRO NATIONS - God-game where every citizen is visible
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const ui = document.getElementById('ui');

// --- GLOBALS ---
let W, H, dpr;
let gameTime = 0, deltaTime = 0, lastTime = 0;
let gameSpeed = 1; // Can be increased to 2x, 4x
let gamePaused = false;

// Camera
let camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };
const TILE_SIZE = 16; // Base isometric tile size

// Game state
let state = {
  day: 0,
  timeOfDay: 0, // 0-1, where 0.5 is noon
  population: 12,
  resources: { food: 50, wood: 30, stone: 20, knowledge: 0 },
  citizens: [],
  buildings: [],
  events: [],
  selectedCitizen: null,
  selectedBuilding: null,
  buildMode: null,
  diplomacyUnlocked: false,
  neighboringIslands: [],
  milestones: { pop50: false, pop100: false }
};

// Input
let inputEvents = [];
let dragState = { active: false, startX: 0, startY: 0, x: 0, y: 0, lastDist: 0 };
let lastTap = 0;

// Audio
let audioCtx = null;
let masterGain = null;
let audioMuted = false;

// Island grid (50x50 tiles)
const GRID_SIZE = 50;
const grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill({ type: 'water', elevation: 0 }));

// Names database
const FIRST_NAMES = [
  'Emma', 'Marcus', 'Sofia', 'Priya', 'Chen', 'Amara', 'Kai', 'Luna', 'Diego', 'Zara',
  'Yuki', 'Jamal', 'Nora', 'Omar', 'Lily', 'Mateo', 'Isla', 'Ravi', 'Aria', 'Felix',
  'Maya', 'Leo', 'Nia', 'Sven', 'Rosa', 'Akira', 'Ivy', 'Theo', 'Zuri', 'Luca'
];

const LAST_NAMES = [
  'Smith', 'Chen', 'Kumar', 'Johnson', 'Nguyen', 'Kim', 'Garcia', 'Rodriguez', 'Brown', 'Lee',
  'Wilson', 'Patel', 'Martinez', 'Davis', 'Sato', 'Cohen', 'Ali', 'Santos', 'Berg', 'O\'Brien'
];

const PERSONALITY_TRAITS = [
  'ambitious', 'lazy', 'friendly', 'grumpy', 'curious', 'cautious', 'brave', 'shy',
  'optimistic', 'pessimistic', 'creative', 'practical', 'generous', 'selfish', 'patient', 'hasty'
];

const JOB_TYPES = ['farmer', 'builder', 'fisher', 'guard', 'scholar', 'gatherer'];

// ============================================================
// INITIALIZATION
// ============================================================
function resize() {
  dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resize);
resize();

function init() {
  // Load saved state
  const saved = localStorage.getItem('microNationsSave');
  if (saved) {
    try {
      state = JSON.parse(saved);
      console.log('Loaded save:', state);
    } catch (e) {
      console.warn('Failed to load save, starting fresh');
      initNewGame();
    }
  } else {
    initNewGame();
  }
  
  // Center camera on island
  // Center on island center (GRID_SIZE/2, GRID_SIZE/2)
  const ctr = isoToWorld(GRID_SIZE / 2, GRID_SIZE / 2);
  camera.x = -ctr.x;
  camera.y = -ctr.y;
  
  // Start game loop
  requestAnimationFrame(loop);
  
  // Auto-save every 30 seconds
  setInterval(saveGame, 30000);
}

function initNewGame() {
  // Generate island terrain
  const centerX = GRID_SIZE / 2;
  const centerY = GRID_SIZE / 2;
  const islandRadius = 12;
  
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      const dx = x - centerX;
      const dy = y - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < islandRadius) {
        const elevation = 1 - (dist / islandRadius) + (Math.random() - 0.5) * 0.3;
        if (elevation > 0.7) {
          grid[y][x] = { type: 'grass', elevation };
        } else if (elevation > 0.3) {
          grid[y][x] = { type: 'sand', elevation };
        } else {
          grid[y][x] = { type: 'water', elevation: 0 };
        }
      }
    }
  }
  
  // Create 12 starting citizens
  state.citizens = [];
  for (let i = 0; i < 12; i++) {
    const citizen = createCitizen();
    // Place near center
    const angle = (i / 12) * Math.PI * 2;
    citizen.x = centerX + Math.cos(angle) * 3;
    citizen.y = centerY + Math.sin(angle) * 3;
    state.citizens.push(citizen);
  }
  
  // Starting buildings
  state.buildings = [
    { type: 'campfire', x: centerX, y: centerY, built: true }
  ];
  
  state.day = 0;
  state.timeOfDay = 0.25; // Morning
  state.population = 12;
}

function createCitizen() {
  const usedNames = new Set(state.citizens.map(c => c.name));
  let name;
  do {
    name = FIRST_NAMES[Math.floor(Math.random() * FIRST_NAMES.length)] + ' ' +
           LAST_NAMES[Math.floor(Math.random() * LAST_NAMES.length)];
  } while (usedNames.has(name));
  
  return {
    id: Math.random().toString(36),
    name,
    age: 18 + Math.floor(Math.random() * 40),
    job: 'gatherer',
    happiness: 0.7 + Math.random() * 0.2,
    personality: PERSONALITY_TRAITS[Math.floor(Math.random() * PERSONALITY_TRAITS.length)],
    x: 25,
    y: 25,
    targetX: 25,
    targetY: 25,
    state: 'idle', // idle, walking, working, sleeping, eating
    stateTimer: 0,
    workTimer: 0,
    hunger: 0.3,
    energy: 0.8,
    relationships: {}
  };
}

function saveGame() {
  try {
    localStorage.setItem('microNationsSave', JSON.stringify(state));
    console.log('Game saved');
  } catch (e) {
    console.error('Failed to save:', e);
  }
}

// ============================================================
// AUDIO
// ============================================================
function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = audioMuted ? 0 : 0.3;
    masterGain.connect(audioCtx.destination);
    startAmbientSound();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function startAmbientSound() {
  // Gentle ocean waves
  const noise = audioCtx.createBufferSource();
  const bufSize = audioCtx.sampleRate * 4;
  const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  
  for (let i = 0; i < bufSize; i++) {
    data[i] = (Math.random() * 2 - 1) * 0.1 * Math.sin(i / 8000);
  }
  
  noise.buffer = buf;
  noise.loop = true;
  
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = 300;
  
  const gain = audioCtx.createGain();
  gain.gain.value = 0.15;
  
  noise.connect(filter);
  filter.connect(gain);
  gain.connect(masterGain);
  
  noise.start();
}

function playTone(freq, duration = 0.1, type = 'sine', vol = 0.2) {
  if (audioMuted || !audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(masterGain);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function sfxClick() { playTone(600, 0.05, 'square', 0.15); }
function sfxBuild() { playTone(300, 0.15, 'square', 0.2); setTimeout(() => playTone(400, 0.15), 50); }
function sfxChime() { playTone(880, 0.2); setTimeout(() => playTone(1100, 0.2), 100); }
function sfxEvent() { playTone(440, 0.1); playTone(550, 0.1); }

// ============================================================
// INPUT
// ============================================================
function screenToWorld(sx, sy) {
  const wx = (sx - W / 2) / camera.zoom - camera.x;
  const wy = (sy - H / 2) / camera.zoom - camera.y;
  return { x: wx, y: wy };
}

function worldToIso(wx, wy) {
  // Convert world coords to isometric tile coords
  const ix = (wx / TILE_SIZE + wy / (TILE_SIZE / 2)) / 2;
  const iy = (wy / (TILE_SIZE / 2) - wx / TILE_SIZE) / 2;
  return { x: ix, y: iy };
}

function isoToWorld(ix, iy) {
  const wx = (ix - iy) * TILE_SIZE;
  const wy = (ix + iy) * (TILE_SIZE / 2);
  return { x: wx, y: wy };
}

canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('mouseup', handleMouseUp);
canvas.addEventListener('wheel', handleWheel, { passive: false });

function handleTouchStart(e) {
  e.preventDefault();
  ensureAudio();
  
  if (e.touches.length === 1) {
    const t = e.touches[0];
    dragState.active = true;
    dragState.startX = t.clientX;
    dragState.startY = t.clientY;
    dragState.x = t.clientX;
    dragState.y = t.clientY;
    
    // Check for double-tap
    const now = Date.now();
    if (now - lastTap < 300) {
      inputEvents.push({ type: 'doubletap', x: t.clientX, y: t.clientY });
    } else {
      inputEvents.push({ type: 'tap', x: t.clientX, y: t.clientY });
    }
    lastTap = now;
  } else if (e.touches.length === 2) {
    // Pinch zoom
    const t1 = e.touches[0], t2 = e.touches[1];
    const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    dragState.lastDist = dist;
  }
}

function handleTouchMove(e) {
  e.preventDefault();
  
  if (e.touches.length === 1 && dragState.active) {
    const t = e.touches[0];
    const dx = t.clientX - dragState.x;
    const dy = t.clientY - dragState.y;
    camera.x += dx / camera.zoom;
    camera.y += dy / camera.zoom;
    dragState.x = t.clientX;
    dragState.y = t.clientY;
  } else if (e.touches.length === 2) {
    const t1 = e.touches[0], t2 = e.touches[1];
    const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    if (dragState.lastDist > 0) {
      const delta = dist - dragState.lastDist;
      camera.targetZoom = Math.max(0.5, Math.min(3, camera.targetZoom + delta * 0.01));
    }
    dragState.lastDist = dist;
  }
}

function handleTouchEnd(e) {
  e.preventDefault();
  dragState.active = false;
  dragState.lastDist = 0;
}

function handleMouseDown(e) {
  ensureAudio();
  dragState.active = true;
  dragState.startX = e.clientX;
  dragState.startY = e.clientY;
  dragState.x = e.clientX;
  dragState.y = e.clientY;
  inputEvents.push({ type: 'tap', x: e.clientX, y: e.clientY });
}

function handleMouseMove(e) {
  if (dragState.active) {
    const dx = e.clientX - dragState.x;
    const dy = e.clientY - dragState.y;
    camera.x += dx / camera.zoom;
    camera.y += dy / camera.zoom;
    dragState.x = e.clientX;
    dragState.y = e.clientY;
  }
}

function handleMouseUp(e) {
  dragState.active = false;
}

function handleWheel(e) {
  e.preventDefault();
  const delta = -e.deltaY * 0.001;
  camera.targetZoom = Math.max(0.5, Math.min(3, camera.targetZoom + delta));
}

// ============================================================
// GAME LOOP
// ============================================================
function loop(time) {
  requestAnimationFrame(loop);
  
  deltaTime = Math.min((time - lastTime) / 1000, 0.1);
  lastTime = time;
  
  if (!gamePaused) {
    gameTime += deltaTime * gameSpeed;
    update(deltaTime * gameSpeed);
  }
  
  render();
}

function update(dt) {
  // Time progression: 1 game day = 2 minutes (120 seconds)
  state.timeOfDay += dt / 120;
  if (state.timeOfDay >= 1) {
    state.timeOfDay -= 1;
    state.day++;
    
    // Daily events
    if (Math.random() < 0.15) spawnRandomEvent();
    
    // Population growth check
    if (state.resources.food > state.population * 2 && Math.random() < 0.3) {
      attemptBirth();
    }
  }
  
  // Update camera zoom smoothly
  camera.zoom += (camera.targetZoom - camera.zoom) * dt * 5;
  
  // Update citizens
  for (const citizen of state.citizens) {
    updateCitizen(citizen, dt);
  }
  
  // Check milestones
  if (state.population >= 50 && !state.milestones.pop50) {
    state.milestones.pop50 = true;
    spawnNeighboringIsland();
    sfxChime();
  }
  if (state.population >= 100 && !state.milestones.pop100) {
    state.milestones.pop100 = true;
    state.diplomacyUnlocked = true;
    sfxChime();
  }
  
  // Process input
  processInput();
}

function updateCitizen(c, dt) {
  c.stateTimer += dt;
  c.workTimer += dt;
  
  // Needs decay
  c.hunger += dt * 0.005;
  c.energy -= dt * 0.003;
  
  const timeOfDay = state.timeOfDay;
  const isNight = timeOfDay < 0.25 || timeOfDay > 0.75;
  
  // State machine
  switch (c.state) {
    case 'idle':
      if (isNight && c.energy < 0.5) {
        c.state = 'sleeping';
        c.stateTimer = 0;
      } else if (c.hunger > 0.7) {
        c.state = 'eating';
        c.stateTimer = 0;
      } else if (c.workTimer > 5 && !isNight) {
        c.state = 'working';
        c.workTimer = 0;
        c.stateTimer = 0;
        // Pick work location based on job
        const workSpot = findWorkLocation(c);
        if (workSpot) {
          c.targetX = workSpot.x;
          c.targetY = workSpot.y;
        }
      } else {
        // Random wander
        if (c.stateTimer > 3) {
          c.targetX = c.x + (Math.random() - 0.5) * 5;
          c.targetY = c.y + (Math.random() - 0.5) * 5;
          c.targetX = Math.max(15, Math.min(35, c.targetX));
          c.targetY = Math.max(15, Math.min(35, c.targetY));
          c.stateTimer = 0;
        }
      }
      break;
      
    case 'working':
      if (c.stateTimer > 8) {
        produceResources(c);
        c.state = 'idle';
        c.stateTimer = 0;
      }
      break;
      
    case 'eating':
      if (c.stateTimer > 2) {
        if (state.resources.food > 0) {
          state.resources.food--;
          c.hunger = Math.max(0, c.hunger - 0.5);
          c.happiness = Math.min(1, c.happiness + 0.05);
        }
        c.state = 'idle';
        c.stateTimer = 0;
      }
      break;
      
    case 'sleeping':
      if (c.stateTimer > 5 || !isNight) {
        c.energy = Math.min(1, c.energy + 0.4);
        c.state = 'idle';
        c.stateTimer = 0;
      }
      break;
  }
  
  // Movement
  const dx = c.targetX - c.x;
  const dy = c.targetY - c.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  
  if (dist > 0.1 && c.state !== 'sleeping') {
    const speed = 1.5 * dt;
    c.x += (dx / dist) * speed;
    c.y += (dy / dist) * speed;
  }
  
  // Happiness decay
  if (c.hunger > 0.8) c.happiness = Math.max(0, c.happiness - dt * 0.01);
  if (c.energy < 0.3) c.happiness = Math.max(0, c.happiness - dt * 0.01);
}

function findWorkLocation(citizen) {
  const centerX = 25, centerY = 25;
  switch (citizen.job) {
    case 'farmer':
      const farm = state.buildings.find(b => b.type === 'farm');
      return farm ? { x: farm.x + 1, y: farm.y + 1 } : { x: centerX + 5, y: centerY };
    case 'fisher':
      // Find water edge
      return { x: centerX + 10, y: centerY + 10 };
    case 'builder':
      return { x: centerX - 5, y: centerY };
    case 'gatherer':
      return { x: centerX + (Math.random() - 0.5) * 8, y: centerY + (Math.random() - 0.5) * 8 };
    default:
      return { x: centerX, y: centerY };
  }
}

function produceResources(citizen) {
  switch (citizen.job) {
    case 'farmer':
      state.resources.food += 3;
      break;
    case 'fisher':
      state.resources.food += 2;
      break;
    case 'builder':
      state.resources.wood += 1;
      state.resources.stone += 1;
      break;
    case 'gatherer':
      state.resources.wood += 2;
      break;
    case 'scholar':
      state.resources.knowledge += 1;
      break;
  }
  sfxClick();
}

function attemptBirth() {
  // Find happy couple
  const adults = state.citizens.filter(c => c.age >= 20 && c.age < 50 && c.happiness > 0.6);
  if (adults.length >= 2) {
    const baby = createCitizen();
    baby.age = 0;
    baby.x = adults[0].x;
    baby.y = adults[0].y;
    state.citizens.push(baby);
    state.population++;
    sfxChime();
    addEvent(`${baby.name} was born!`, 'birth');
  }
}

function spawnRandomEvent() {
  const eventTypes = ['dispute', 'storm', 'marriage', 'death'];
  const type = eventTypes[Math.floor(Math.random() * eventTypes.length)];
  
  switch (type) {
    case 'dispute':
      if (state.citizens.length >= 2) {
        const c1 = state.citizens[Math.floor(Math.random() * state.citizens.length)];
        const c2 = state.citizens[Math.floor(Math.random() * state.citizens.length)];
        if (c1 !== c2) {
          addEvent(`${c1.name} and ${c2.name} are arguing about resources.`, 'dispute', { c1, c2 });
        }
      }
      break;
    case 'storm':
      state.resources.food = Math.max(0, state.resources.food - 5);
      addEvent('A storm damaged crops!', 'storm');
      sfxEvent();
      break;
    case 'marriage':
      if (state.citizens.length >= 2) {
        const c1 = state.citizens.find(c => c.age >= 18 && c.happiness > 0.7);
        const c2 = state.citizens.find(c => c !== c1 && c.age >= 18 && c.happiness > 0.7);
        if (c1 && c2) {
          addEvent(`${c1.name} and ${c2.name} got married!`, 'marriage');
          c1.happiness = Math.min(1, c1.happiness + 0.2);
          c2.happiness = Math.min(1, c2.happiness + 0.2);
        }
      }
      break;
    case 'death':
      const old = state.citizens.find(c => c.age > 70 && Math.random() < 0.3);
      if (old) {
        addEvent(`${old.name} passed away at age ${old.age}.`, 'death');
        state.citizens = state.citizens.filter(c => c !== old);
        state.population--;
      }
      break;
  }
}

function addEvent(message, type, data = {}) {
  state.events.push({ message, type, data, time: gameTime, resolved: false });
  sfxEvent();
}

function spawnNeighboringIsland() {
  state.neighboringIslands.push({
    name: 'Island of ' + FIRST_NAMES[Math.floor(Math.random() * FIRST_NAMES.length)],
    population: 30 + Math.floor(Math.random() * 40),
    relationship: 'neutral', // neutral, allied, enemy
    x: 80,
    y: 20
  });
  addEvent('A neighboring island appeared on the horizon!', 'discovery');
}

function processInput() {
  for (const ev of inputEvents) {
    if (ev.type === 'tap') {
      handleTap(ev.x, ev.y);
    }
  }
  inputEvents = [];
}

function handleTap(sx, sy) {
  const world = screenToWorld(sx, sy);
  const iso = worldToIso(world.x, world.y);
  
  // Check if tapping UI first
  if (sy < 120) {
    // Top UI bar
    if (sx > W - 60 && sy < 40) {
      // Menu button
      toggleMenu();
      return;
    }
  }
  
  // Check citizens
  for (const citizen of state.citizens) {
    const cWorld = isoToWorld(citizen.x, citizen.y);
    const dx = world.x - cWorld.x;
    const dy = world.y - cWorld.y;
    if (Math.sqrt(dx * dx + dy * dy) < TILE_SIZE) {
      selectCitizen(citizen);
      sfxClick();
      return;
    }
  }
  
  // Check buildings
  for (const building of state.buildings) {
    const bWorld = isoToWorld(building.x, building.y);
    const dx = world.x - bWorld.x;
    const dy = world.y - bWorld.y;
    if (Math.sqrt(dx * dx + dy * dy) < TILE_SIZE * 2) {
      selectBuilding(building);
      sfxClick();
      return;
    }
  }
  
  // Empty land - build mode
  if (state.buildMode) {
    placeBuilding(Math.floor(iso.x), Math.floor(iso.y));
  } else {
    // Deselect
    state.selectedCitizen = null;
    state.selectedBuilding = null;
    updateUI();
  }
}

function selectCitizen(citizen) {
  state.selectedCitizen = citizen;
  state.selectedBuilding = null;
  updateUI();
}

function selectBuilding(building) {
  state.selectedBuilding = building;
  state.selectedCitizen = null;
  updateUI();
}

function placeBuilding(x, y) {
  const buildingType = state.buildMode;
  const costs = {
    house: { wood: 10, stone: 5 },
    farm: { wood: 15, stone: 0 },
    dock: { wood: 20, stone: 5 },
    watchtower: { wood: 10, stone: 15 },
    school: { wood: 25, stone: 20 }
  };
  
  const cost = costs[buildingType];
  if (cost) {
    let canBuild = true;
    for (const [res, amt] of Object.entries(cost)) {
      if (state.resources[res] < amt) canBuild = false;
    }
    
    if (canBuild) {
      for (const [res, amt] of Object.entries(cost)) {
        state.resources[res] -= amt;
      }
      state.buildings.push({ type: buildingType, x, y, built: true });
      sfxBuild();
      state.buildMode = null;
      updateUI();
    }
  }
}

function toggleMenu() {
  gamePaused = !gamePaused;
  updateUI();
}

// ============================================================
// UI MANAGEMENT
// ============================================================
function updateUI() {
  ui.innerHTML = '';
  
  // Top bar - resources
  const topBar = document.createElement('div');
  topBar.style.cssText = 'position:absolute;top:10px;left:10px;right:10px;display:flex;gap:12px;flex-wrap:wrap;';
  topBar.innerHTML = `
    <div class="panel" style="flex:1;min-width:140px;">
      <div style="font-size:12px;color:#666;">Day ${state.day} ‚Ä¢ Pop: ${state.population}</div>
      <div style="font-size:11px;margin-top:4px;">
        üåæ ${state.resources.food} | ü™µ ${state.resources.wood} | ü™® ${state.resources.stone} | üìö ${state.resources.knowledge}
      </div>
    </div>
    <button class="btn" onclick="gameSpeed = gameSpeed === 1 ? 2 : 1; updateUI();" style="padding:6px 12px;">
      ${gameSpeed === 1 ? '1x' : '2x'}
    </button>
    <button class="btn" onclick="toggleMenu();" style="padding:6px 12px;">‚ò∞</button>
  `;
  ui.appendChild(topBar);
  
  // Selected citizen panel
  if (state.selectedCitizen) {
    const c = state.selectedCitizen;
    const panel = document.createElement('div');
    panel.className = 'panel';
    panel.style.cssText = 'position:absolute;bottom:20px;left:50%;transform:translateX(-50%);width:90%;max-width:350px;';
    panel.innerHTML = `
      <div style="font-weight:600;margin-bottom:8px;">${c.name}, ${c.age}</div>
      <div style="font-size:12px;color:#555;margin-bottom:8px;">
        ${c.personality} ‚Ä¢ Happiness: ${Math.floor(c.happiness * 100)}%
      </div>
      <div style="font-size:11px;margin-bottom:8px;">
        Hunger: ${Math.floor(c.hunger * 100)}% | Energy: ${Math.floor(c.energy * 100)}%
      </div>
      <div style="display:flex;gap:6px;flex-wrap:wrap;">
        ${JOB_TYPES.map(job => `
          <button class="btn ${c.job === job ? 'success' : ''}" 
                  onclick="assignJob('${c.id}', '${job}')" 
                  style="font-size:11px;padding:6px 10px;">
            ${job}
          </button>
        `).join('')}
      </div>
    `;
    ui.appendChild(panel);
  }
  
  // Build menu
  if (!state.selectedCitizen && !state.selectedBuilding) {
    const buildBtn = document.createElement('div');
    buildBtn.style.cssText = 'position:absolute;bottom:20px;right:20px;';
    buildBtn.innerHTML = `
      <button class="btn success" onclick="showBuildMenu()" style="font-size:14px;padding:12px 20px;">
        üèóÔ∏è Build
      </button>
    `;
    ui.appendChild(buildBtn);
  }
  
  // Events panel
  if (state.events.filter(e => !e.resolved).length > 0) {
    const evPanel = document.createElement('div');
    evPanel.className = 'panel';
    evPanel.style.cssText = 'position:absolute;top:80px;left:10px;max-width:280px;';
    const recentEvents = state.events.filter(e => !e.resolved).slice(-3);
    evPanel.innerHTML = `
      <div style="font-weight:600;margin-bottom:6px;">Events</div>
      ${recentEvents.map(e => `
        <div style="font-size:11px;padding:6px;background:rgba(255,200,100,0.2);border-radius:4px;margin-bottom:4px;">
          ${e.message}
          ${e.type === 'dispute' ? `
            <div style="margin-top:4px;">
              <button class="btn" onclick="resolveDispute('${e.data.c1.id}', '${e.data.c2.id}', 0)" style="font-size:12px;padding:8px 12px;min-height:36px;">Support ${e.data.c1.name.split(' ')[0]}</button>
              <button class="btn" onclick="resolveDispute('${e.data.c1.id}', '${e.data.c2.id}', 1)" style="font-size:12px;padding:8px 12px;min-height:36px;">Support ${e.data.c2.name.split(' ')[0]}</button>
              <button class="btn" onclick="resolveDispute('${e.data.c1.id}', '${e.data.c2.id}', 2)" style="font-size:12px;padding:8px 12px;min-height:36px;">Compromise</button>
            </div>
          ` : `
            <button class="btn" onclick="dismissEvent(${state.events.indexOf(e)})" style="font-size:12px;padding:8px 12px;min-height:36px;margin-top:4px;">Dismiss</button>
          `}
        </div>
      `).join('')}
    `;
    ui.appendChild(evPanel);
  }
  
  // Diplomacy panel (if unlocked)
  if (state.diplomacyUnlocked && state.neighboringIslands.length > 0) {
    const dipPanel = document.createElement('div');
    dipPanel.style.cssText = 'position:absolute;top:80px;right:10px;';
    dipPanel.innerHTML = `
      <button class="btn" onclick="showDiplomacy()" style="font-size:12px;padding:8px 12px;">
        üåç Diplomacy
      </button>
    `;
    ui.appendChild(dipPanel);
  }
  
  // Pause menu
  if (gamePaused) {
    const pauseMenu = document.createElement('div');
    pauseMenu.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;';
    pauseMenu.innerHTML = `
      <div class="panel" style="max-width:300px;">
        <h2 style="margin-bottom:16px;">Micro Nations</h2>
        <button class="btn success" onclick="toggleMenu()" style="width:100%;margin-bottom:8px;">Resume</button>
        <button class="btn" onclick="saveGame()" style="width:100%;margin-bottom:8px;">Save Game</button>
        <button class="btn danger" onclick="if(confirm('Reset game?')){localStorage.removeItem('microNationsSave');location.reload();}" style="width:100%;">New Game</button>
        <div style="margin-top:16px;font-size:11px;color:#666;text-align:center;">
          Day ${state.day} ‚Ä¢ Population: ${state.population}<br>
          Deaths: ${state.citizens.filter(c => c.age > 70).length}
        </div>
      </div>
    `;
    ui.appendChild(pauseMenu);
  }
}

// Global functions for UI callbacks
window.assignJob = (citizenId, job) => {
  const citizen = state.citizens.find(c => c.id === citizenId);
  if (citizen) {
    citizen.job = job;
    sfxClick();
    updateUI();
  }
};

window.showBuildMenu = () => {
  const menu = document.createElement('div');
  menu.id = 'buildMenu';
  menu.className = 'panel';
  menu.style.cssText = 'position:absolute;bottom:80px;right:20px;';
  menu.innerHTML = `
    <div style="font-weight:600;margin-bottom:8px;">Build Structure</div>
    <button class="btn" onclick="setBuildMode('house')" style="width:100%;margin-bottom:4px;text-align:left;font-size:11px;">
      üè† House (ü™µ10 ü™®5)
    </button>
    <button class="btn" onclick="setBuildMode('farm')" style="width:100%;margin-bottom:4px;text-align:left;font-size:11px;">
      üåæ Farm (ü™µ15)
    </button>
    <button class="btn" onclick="setBuildMode('dock')" style="width:100%;margin-bottom:4px;text-align:left;font-size:11px;">
      ‚öì Dock (ü™µ20 ü™®5)
    </button>
    <button class="btn" onclick="setBuildMode('watchtower')" style="width:100%;margin-bottom:4px;text-align:left;font-size:11px;">
      üóº Watchtower (ü™µ10 ü™®15)
    </button>
    <button class="btn" onclick="setBuildMode('school')" style="width:100%;margin-bottom:4px;text-align:left;font-size:11px;">
      üè´ School (ü™µ25 ü™®20)
    </button>
    <button class="btn danger" onclick="closeBuildMenu()" style="width:100%;margin-top:8px;font-size:11px;">
      Cancel
    </button>
  `;
  ui.appendChild(menu);
};

window.setBuildMode = (type) => {
  state.buildMode = type;
  closeBuildMenu();
  sfxClick();
};

window.closeBuildMenu = () => {
  const menu = document.getElementById('buildMenu');
  if (menu) menu.remove();
};

window.dismissEvent = (index) => {
  if (state.events[index]) {
    state.events[index].resolved = true;
    updateUI();
  }
};

window.resolveDispute = (c1id, c2id, choice) => {
  const c1 = state.citizens.find(c => c.id === c1id);
  const c2 = state.citizens.find(c => c.id === c2id);
  
  if (choice === 0) {
    c1.happiness = Math.min(1, c1.happiness + 0.1);
    c2.happiness = Math.max(0, c2.happiness - 0.15);
  } else if (choice === 1) {
    c2.happiness = Math.min(1, c2.happiness + 0.1);
    c1.happiness = Math.max(0, c1.happiness - 0.15);
  } else {
    c1.happiness = Math.min(1, c1.happiness + 0.05);
    c2.happiness = Math.min(1, c2.happiness + 0.05);
  }
  
  const event = state.events.find(e => e.type === 'dispute' && e.data.c1 === c1);
  if (event) event.resolved = true;
  
  sfxChime();
  updateUI();
};

window.showDiplomacy = () => {
  const panel = document.createElement('div');
  panel.id = 'diplomacyPanel';
  panel.className = 'panel';
  panel.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);max-width:350px;width:90%;';
  panel.innerHTML = `
    <h3 style="margin-bottom:12px;">Diplomacy</h3>
    ${state.neighboringIslands.map((island, i) => `
      <div style="padding:10px;background:rgba(200,220,240,0.3);border-radius:6px;margin-bottom:8px;">
        <div style="font-weight:600;">${island.name}</div>
        <div style="font-size:11px;color:#666;margin:4px 0;">
          Population: ${island.population} ‚Ä¢ ${island.relationship}
        </div>
        <div style="display:flex;gap:4px;margin-top:6px;">
          <button class="btn" onclick="diplomacyAction(${i},'trade')" style="font-size:12px;padding:8px 12px;min-height:36px;">üì¶ Trade</button>
          <button class="btn" onclick="diplomacyAction(${i},'ally')" style="font-size:12px;padding:8px 12px;min-height:36px;">ü§ù Alliance</button>
          <button class="btn danger" onclick="diplomacyAction(${i},'war')" style="font-size:12px;padding:8px 12px;min-height:36px;">‚öîÔ∏è War</button>
        </div>
      </div>
    `).join('')}
    <button class="btn" onclick="closeDiplomacy()" style="width:100%;margin-top:12px;">Close</button>
  `;
  ui.appendChild(panel);
};

window.closeDiplomacy = () => {
  const panel = document.getElementById('diplomacyPanel');
  if (panel) panel.remove();
};

window.diplomacyAction = (islandIndex, action) => {
  const island = state.neighboringIslands[islandIndex];
  
  switch (action) {
    case 'trade':
      state.resources.food += 10;
      state.resources.wood -= 5;
      addEvent(`Trade agreement with ${island.name}!`, 'trade');
      island.relationship = 'friendly';
      break;
    case 'ally':
      island.relationship = 'allied';
      addEvent(`Alliance formed with ${island.name}!`, 'alliance');
      break;
    case 'war':
      island.relationship = 'enemy';
      addEvent(`War declared on ${island.name}!`, 'war');
      // War casualties
      const casualties = Math.floor(Math.random() * 3) + 1;
      state.population = Math.max(1, state.population - casualties);
      state.citizens = state.citizens.slice(0, state.population);
      break;
  }
  
  sfxChime();
  closeDiplomacy();
  updateUI();
};

// ============================================================
// RENDERING
// ============================================================
function render() {
  // Clear
  ctx.fillStyle = '#87CEEB'; // Sky blue
  ctx.fillRect(0, 0, W, H);
  
  // Apply camera transform
  ctx.save();
  ctx.translate(W / 2, H / 2);
  ctx.scale(camera.zoom, camera.zoom);
  ctx.translate(camera.x, camera.y);
  
  // Draw water background with shimmer
  ctx.fillStyle = '#2B5F8F';
  ctx.fillRect(-2000, -2000, 4000, 4000);
  // Water highlights
  ctx.fillStyle = 'rgba(100,180,255,0.04)';
  const wt = Date.now() / 1000;
  for (let i = 0; i < 8; i++) {
    const wx = Math.sin(wt * 0.2 + i * 2.5) * 500;
    const wy = Math.cos(wt * 0.3 + i * 2.0) * 400;
    ctx.beginPath();
    ctx.ellipse(wx, wy, 50 + Math.sin(wt + i) * 15, 20, wt * 0.08 + i, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Draw island tiles (isometric)
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      const tile = grid[y][x];
      if (tile.type !== 'water') {
        drawIsoTile(x, y, tile);
      }
    }
  }
  
  // Draw buildings
  for (const building of state.buildings) {
    drawBuilding(building);
  }
  
  // Draw citizens
  for (const citizen of state.citizens) {
    drawCitizen(citizen);
  }
  
  // Draw neighboring islands (simplified)
  for (const island of state.neighboringIslands) {
    const wpos = isoToWorld(island.x, island.y);
    ctx.fillStyle = '#8B7355';
    ctx.fillRect(wpos.x - 20, wpos.y - 10, 40, 20);
    ctx.fillStyle = '#fff';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(island.name, wpos.x, wpos.y - 15);
  }
  
  ctx.restore();
  
  // Day/night overlay
  const timeOfDay = state.timeOfDay;
  let darkness = 0;
  if (timeOfDay < 0.25) darkness = 0.5 - timeOfDay * 2;
  else if (timeOfDay > 0.75) darkness = (timeOfDay - 0.75) * 2;
  
  if (darkness > 0) {
    ctx.fillStyle = `rgba(0, 10, 30, ${darkness * 0.4})`;
    ctx.fillRect(0, 0, W, H);
  }
}

function drawIsoTile(x, y, tile) {
  const wpos = isoToWorld(x, y);
  const w = TILE_SIZE;
  const h = TILE_SIZE / 2;
  
  // Isometric diamond
  ctx.fillStyle = tile.type === 'grass' ? '#7cb342' : '#d4a574';
  ctx.beginPath();
  ctx.moveTo(wpos.x, wpos.y - h);
  ctx.lineTo(wpos.x + w, wpos.y);
  ctx.lineTo(wpos.x, wpos.y + h);
  ctx.lineTo(wpos.x - w, wpos.y);
  ctx.closePath();
  ctx.fill();
  
  // Subtle outline
  ctx.strokeStyle = 'rgba(0,0,0,0.1)';
  ctx.lineWidth = 0.5;
  ctx.stroke();
}

function drawCitizen(c) {
  const wpos = isoToWorld(c.x, c.y);
  const size = 4;
  // Walk bob
  const bob = c.state === 'walking' ? Math.sin(Date.now() / 120 + c.id.charCodeAt(0)) * 1.5 : 0;
  wpos.y += bob;
  
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(wpos.x, wpos.y + 2 - bob, size, size / 2, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Body
  const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c'];
  const colorIndex = c.id.charCodeAt(0) % colors.length;
  ctx.fillStyle = colors[colorIndex];
  ctx.fillRect(wpos.x - size / 2, wpos.y - size * 2, size, size * 1.5);
  
  // Head
  ctx.fillStyle = '#f5deb3';
  ctx.beginPath();
  ctx.arc(wpos.x, wpos.y - size * 2.5, size / 1.5, 0, Math.PI * 2);
  ctx.fill();
  
  // Sleeping zzz
  if (c.state === 'sleeping') {
    ctx.fillStyle = '#666';
    ctx.font = '6px sans-serif';
    ctx.fillText('z', wpos.x + 4, wpos.y - size * 3);
  }
  
  // Working animation
  if (c.state === 'working') {
    ctx.fillStyle = '#ffd700';
    ctx.font = '11px sans-serif';
    const tools = { farmer: 'üåæ', fisher: 'üé£', builder: 'üî®', scholar: 'üìñ', gatherer: 'ü™ì' };
    const tool = tools[c.job] || '‚öôÔ∏è';
    ctx.fillText(tool, wpos.x + 6, wpos.y - size * 2);
  }
  
  // Selection indicator
  if (state.selectedCitizen === c) {
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(wpos.x, wpos.y - size, size * 2, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  // Name label (on hover or selection)
  if (state.selectedCitizen === c) {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(wpos.x - 20, wpos.y - size * 4, 40, 10);
    ctx.fillStyle = '#fff';
    ctx.font = '6px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(c.name.split(' ')[0], wpos.x, wpos.y - size * 4 + 7);
  }
}

function drawBuilding(b) {
  const wpos = isoToWorld(b.x, b.y);
  const size = TILE_SIZE;
  
  // Building sprites (simplified)
  switch (b.type) {
    case 'campfire': {
      const ft = Date.now() / 200;
      // Glow
      ctx.fillStyle = 'rgba(255,100,0,0.15)';
      ctx.beginPath();
      ctx.arc(wpos.x, wpos.y - 2, 10 + Math.sin(ft) * 2, 0, Math.PI * 2);
      ctx.fill();
      // Flame
      ctx.fillStyle = '#ff6b35';
      ctx.beginPath();
      ctx.moveTo(wpos.x + Math.sin(ft * 1.3) * 1, wpos.y - 6 - Math.abs(Math.sin(ft)) * 3);
      ctx.lineTo(wpos.x - 3, wpos.y);
      ctx.lineTo(wpos.x + 3, wpos.y);
      ctx.closePath();
      ctx.fill();
      // Inner flame
      ctx.fillStyle = '#ffcc00';
      ctx.beginPath();
      ctx.moveTo(wpos.x, wpos.y - 4 - Math.abs(Math.sin(ft * 1.5)));
      ctx.lineTo(wpos.x - 1.5, wpos.y);
      ctx.lineTo(wpos.x + 1.5, wpos.y);
      ctx.closePath();
      ctx.fill();
      // Smoke particles
      ctx.fillStyle = 'rgba(100,100,100,0.2)';
      for (let s = 0; s < 3; s++) {
        const sy = wpos.y - 10 - s * 5 - (ft % 8);
        const sx = wpos.x + Math.sin(ft + s * 2) * 3;
        ctx.beginPath();
        ctx.arc(sx, sy, 2 + s * 0.5, 0, Math.PI * 2);
        ctx.fill();
      }
      break;
    }
    case 'house':
      // Base
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(wpos.x - size / 2, wpos.y - size / 2, size, size);
      // Roof
      ctx.fillStyle = '#d2691e';
      ctx.beginPath();
      ctx.moveTo(wpos.x, wpos.y - size * 1.2);
      ctx.lineTo(wpos.x - size * 0.7, wpos.y - size / 2);
      ctx.lineTo(wpos.x + size * 0.7, wpos.y - size / 2);
      ctx.closePath();
      ctx.fill();
      break;
      
    case 'farm':
      ctx.fillStyle = '#d4a574';
      ctx.fillRect(wpos.x - size, wpos.y - size / 2, size * 2, size);
      // Crops
      ctx.fillStyle = '#7cb342';
      for (let i = 0; i < 4; i++) {
        ctx.fillRect(wpos.x - size + i * 8, wpos.y - 2, 6, 4);
      }
      break;
      
    case 'dock':
      ctx.fillStyle = '#8B7355';
      ctx.fillRect(wpos.x - size / 2, wpos.y, size, size * 2);
      // Water around
      ctx.fillStyle = 'rgba(43,95,143,0.5)';
      ctx.fillRect(wpos.x - size, wpos.y + size, size * 2, size);
      break;
      
    case 'watchtower':
      ctx.fillStyle = '#696969';
      ctx.fillRect(wpos.x - 4, wpos.y - size * 2, 8, size * 2);
      // Top
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(wpos.x - 6, wpos.y - size * 2.5, 12, 6);
      break;
      
    case 'school':
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(wpos.x - size * 0.8, wpos.y - size * 0.6, size * 1.6, size * 1.2);
      // Door
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(wpos.x - 3, wpos.y + size * 0.2, 6, 8);
      // Bell
      ctx.fillStyle = '#ff6b35';
      ctx.beginPath();
      ctx.arc(wpos.x, wpos.y - size * 0.8, 2, 0, Math.PI * 2);
      ctx.fill();
      break;
  }
  
  // Selection indicator
  if (state.selectedBuilding === b) {
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(wpos.x - size, wpos.y - size, size * 2, size * 2);
  }
}

// ============================================================
// START GAME
// ============================================================
init();
updateUI();
</script>
</body>
</html>
