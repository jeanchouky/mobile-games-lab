<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>HAUNTED</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #000;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  font-family: -apple-system, 'Segoe UI', system-ui, sans-serif;
}
canvas {
  display: block;
  width: 100%; height: 100%;
  position: absolute;
  top: 0; left: 0;
}

/* Fake phone notification */
#notification {
  position: fixed;
  top: -120px;
  left: 8px;
  right: 8px;
  background: rgba(30,30,30,0.97);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border-radius: 16px;
  padding: 14px 16px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.6);
  z-index: 200;
  transition: top 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
  max-width: 400px;
  margin: 0 auto;
  border: 1px solid rgba(255,255,255,0.08);
}
#notification.show { top: 12px; }
#notification .notif-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
}
#notification .notif-icon {
  font-size: 18px;
  width: 24px;
  text-align: center;
}
#notification .notif-app {
  font-size: 12px;
  font-weight: 600;
  color: rgba(255,255,255,0.5);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  flex: 1;
}
#notification .notif-time {
  font-size: 11px;
  color: rgba(255,255,255,0.3);
}
#notification .notif-title {
  font-size: 15px;
  font-weight: 600;
  color: #fff;
  margin-bottom: 2px;
  padding-left: 32px;
}
#notification .notif-body {
  font-size: 14px;
  color: rgba(255,255,255,0.7);
  line-height: 1.35;
  padding-left: 32px;
}

/* Camera recording indicator */
#camera-indicator {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: #00ff00;
  z-index: 150;
  opacity: 0;
  transition: opacity 0.3s;
  box-shadow: 0 0 12px #00ff00;
}
#camera-indicator.active {
  opacity: 1;
  animation: cam-pulse 1s infinite;
}
@keyframes cam-pulse {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 0.4; }
}

/* Toast */
#toast {
  position: fixed;
  bottom: -80px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(50,50,50,0.95);
  backdrop-filter: blur(10px);
  color: #fff;
  padding: 10px 24px;
  border-radius: 24px;
  font-size: 13px;
  z-index: 200;
  transition: bottom 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
  white-space: nowrap;
}
#toast.show { bottom: 50px; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="notification">
  <div class="notif-header">
    <span class="notif-icon" id="n-icon">ðŸ“±</span>
    <span class="notif-app" id="n-app">Messages</span>
    <span class="notif-time" id="n-time">now</span>
  </div>
  <div class="notif-title" id="n-title"></div>
  <div class="notif-body" id="n-body"></div>
</div>
<div id="camera-indicator"></div>
<div id="toast"></div>

<script>
'use strict';

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W, H, scale;
let gameTime = 0, deltaTime = 0, lastTime = 0;
let gameState = 'menu'; // menu, playing, solved
let hauntLevel = 0; // 0-3
let survivalTime = 0;
let shakeAmount = 0;
let staticNoise = 0;
let rgbShift = 0;
let colorInvert = false;
let inputEvents = [];
let particles = [];
let fogParticles = [];
let hauntSchedule = [];
let tapHistory = [];
let solved = false;
let hauntDifficulty = 'normal'; // 'mild', 'normal', 'extreme'

// Creepy text that fades in/out
let creepyTexts = [];

// Ambient breathing
let breathPhase = 0;

// Fake phone "apps"
const fakeApps = [
  { icon: 'ðŸ“±', name: 'Messages', color: '#34c759' },
  { icon: 'ðŸ“·', name: 'Camera', color: '#ff9500' },
  { icon: 'ðŸŽµ', name: 'Music', color: '#ff2d55' },
  { icon: 'âš™ï¸', name: 'Settings', color: '#8e8e93' },
  { icon: 'ðŸŒ', name: 'Safari', color: '#007aff' },
  { icon: 'ðŸ“§', name: 'Mail', color: '#007aff' },
  { icon: 'ðŸ“ž', name: 'Phone', color: '#34c759' },
  { icon: 'ðŸ“¸', name: 'Photos', color: '#ff9500' },
  { icon: 'ðŸ—“ï¸', name: 'Calendar', color: '#ff3b30' },
  { icon: 'ðŸ•', name: 'Clock', color: '#000' },
  { icon: 'ðŸ—ºï¸', name: 'Maps', color: '#34c759' },
  { icon: 'ðŸ’°', name: 'Wallet', color: '#000' },
];

// Secret code to escape
const correctCode = ['top-left', 'bottom-right', 'center', 'top-right'];
const regions = {
  'top-left': { x: 0, y: 0, w: 0.33, h: 0.33 },
  'top-right': { x: 0.67, y: 0, w: 0.33, h: 0.33 },
  'center': { x: 0.33, y: 0.33, w: 0.34, h: 0.34 },
  'bottom-right': { x: 0.67, y: 0.67, w: 0.33, h: 0.33 },
};

// --- RESIZE ---
function resize() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  scale = Math.min(W / 400, H / 700);
  initFog();
}
window.addEventListener('resize', resize);
resize();

// ============================================================
// AUDIO
// ============================================================
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){} }
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
}

function playTone(freq, dur, type = 'sine', vol = 0.1) {
  ensureAudio();
  if (!audioCtx) return;
  const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.setValueAtTime(vol, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur);
  o.connect(g).connect(audioCtx.destination);
  o.start(t); o.stop(t + dur);
}

function playNoise(dur, vol = 0.06, fOpts = null) {
  ensureAudio();
  if (!audioCtx) return;
  const t = audioCtx.currentTime;
  const sz = audioCtx.sampleRate * dur;
  const buf = audioCtx.createBuffer(1, sz, audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < sz; i++) d[i] = Math.random() * 2 - 1;
  const s = audioCtx.createBufferSource(); s.buffer = buf;
  const g = audioCtx.createGain();
  g.gain.setValueAtTime(vol, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur);
  s.connect(g);
  if (fOpts) {
    const f = audioCtx.createBiquadFilter();
    f.type = fOpts.type || 'lowpass'; f.frequency.value = fOpts.freq || 800;
    if (fOpts.q) f.Q.value = fOpts.q;
    g.connect(f).connect(audioCtx.destination);
  } else g.connect(audioCtx.destination);
  s.start(t);
}

// Ambient drone (very low, creepy)
let droneNodes = [];
function startDrone() {
  ensureAudio();
  if (!audioCtx || droneNodes.length) return;
  const t = audioCtx.currentTime;
  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0, t);
  g.gain.linearRampToValueAtTime(0.025, t + 3);
  const f = audioCtx.createBiquadFilter();
  f.type = 'lowpass'; f.frequency.value = 150;
  
  // Two slightly detuned oscillators for beating
  for (const freq of [48, 48.7]) {
    const o = audioCtx.createOscillator();
    o.type = 'sine'; o.frequency.value = freq;
    o.connect(g);
    o.start(t);
    droneNodes.push(o);
  }
  // Sub bass
  const sub = audioCtx.createOscillator();
  sub.type = 'sine'; sub.frequency.value = 24;
  const subG = audioCtx.createGain(); subG.gain.value = 0.015;
  sub.connect(subG).connect(f);
  sub.start(t);
  droneNodes.push(sub);
  
  g.connect(f).connect(audioCtx.destination);
}

function sfxHeartbeat() {
  playTone(55, 0.12, 'sine', 0.2);
  setTimeout(() => playTone(50, 0.1, 'sine', 0.15), 130);
}
function sfxWhisper() { playNoise(0.6, 0.04, { type: 'bandpass', freq: 600, q: 3 }); }
function sfxStatic() { playNoise(0.25, 0.1); }
function sfxCreepy() { playTone(180 + Math.random() * 80, 1.5, 'triangle', 0.06); }
function sfxJumpscare() {
  playNoise(0.4, 0.2);
  playTone(90, 0.5, 'sawtooth', 0.25);
}
function sfxNotif() { playTone(1100, 0.06, 'sine', 0.08); setTimeout(() => playTone(1300, 0.06, 'sine', 0.06), 80); }
function sfxWin() {
  playTone(523, 0.1, 'sine', 0.12);
  setTimeout(() => playTone(659, 0.1, 'sine', 0.12), 100);
  setTimeout(() => playTone(784, 0.2, 'sine', 0.12), 200);
}
function sfxTap() { playTone(400, 0.02, 'sine', 0.04); }
function sfxWrongTap() { playTone(150, 0.08, 'square', 0.04); }

// ============================================================
// FAKE NOTIFICATIONS
// ============================================================
const notifEl = document.getElementById('notification');
let notifTimeout = null;

function showNotif(app, title, body, icon = 'ðŸ“±', duration = 4500) {
  document.getElementById('n-icon').textContent = icon;
  document.getElementById('n-app').textContent = app;
  document.getElementById('n-title').textContent = title;
  document.getElementById('n-body').textContent = body;
  document.getElementById('n-time').textContent = 'now';
  
  if (notifTimeout) clearTimeout(notifTimeout);
  notifEl.classList.add('show');
  sfxNotif();
  
  notifTimeout = setTimeout(() => notifEl.classList.remove('show'), duration);
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2500);
}

function showCamera() {
  document.getElementById('camera-indicator').classList.add('active');
  showToast('ðŸ“· Camera accessed by unknown app');
  setTimeout(() => document.getElementById('camera-indicator').classList.remove('active'), 6000);
}

// ============================================================
// FOG / PARTICLES
// ============================================================
function initFog() {
  fogParticles = [];
  for (let i = 0; i < 25; i++) {
    fogParticles.push({
      x: Math.random() * W,
      y: Math.random() * H,
      size: (30 + Math.random() * 60) * scale,
      speed: 0.2 + Math.random() * 0.5,
      alpha: 0.02 + Math.random() * 0.04,
      phase: Math.random() * Math.PI * 2
    });
  }
}

function drawFog(tint = 0) {
  for (const f of fogParticles) {
    f.x += Math.sin(gameTime * 0.3 + f.phase) * f.speed;
    f.y += Math.cos(gameTime * 0.2 + f.phase) * f.speed * 0.5;
    if (f.x > W + f.size) f.x = -f.size;
    if (f.x < -f.size) f.x = W + f.size;
    if (f.y > H + f.size) f.y = -f.size;
    if (f.y < -f.size) f.y = H + f.size;
    
    const grad = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.size);
    const r = tint > 0 ? Math.min(40, tint * 80) : 15;
    grad.addColorStop(0, `rgba(${r},${r},${Math.max(r, 20)},${f.alpha * (1 + hauntLevel * 0.3)})`);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(f.x - f.size, f.y - f.size, f.size * 2, f.size * 2);
  }
}

function spawnParticles(x, y, count, color = '#f44') {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const spd = (1 + Math.random() * 3) * scale;
    particles.push({
      x, y, vx: Math.cos(a) * spd, vy: Math.sin(a) * spd,
      life: 1, decay: 0.015 + Math.random() * 0.02,
      size: (1.5 + Math.random() * 3) * scale, color
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.08 * scale;
    p.life -= p.decay;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    ctx.restore();
  }
}

// ============================================================
// CREEPY TEXT
// ============================================================
function addCreepyText(text, x, y, size = 14, color = '#600', duration = 4) {
  creepyTexts.push({ text, x, y, size, color, life: duration, maxLife: duration });
}

function drawCreepyTexts() {
  for (let i = creepyTexts.length - 1; i >= 0; i--) {
    const t = creepyTexts[i];
    t.life -= deltaTime;
    if (t.life <= 0) { creepyTexts.splice(i, 1); continue; }
    
    const fadeIn = Math.min(1, (t.maxLife - t.life) * 3);
    const fadeOut = Math.min(1, t.life * 2);
    const alpha = fadeIn * fadeOut * 0.6;
    
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.font = `${t.size * scale}px 'Courier New', monospace`;
    ctx.fillStyle = t.color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // Slight jitter
    ctx.fillText(t.text, t.x + (Math.random()-0.5)*2*scale, t.y + (Math.random()-0.5)*2*scale);
    ctx.restore();
  }
}

// ============================================================
// GLITCH EFFECTS
// ============================================================
function triggerGlitch(type, intensity = 0.3, dur = 0.5) {
  if (type === 'static') {
    staticNoise = intensity;
    sfxStatic();
    setTimeout(() => staticNoise *= 0.3, dur * 500);
    setTimeout(() => staticNoise = 0, dur * 1000);
  } else if (type === 'invert') {
    colorInvert = true;
    setTimeout(() => colorInvert = false, dur * 1000);
  } else if (type === 'rgb') {
    rgbShift = intensity * 8 * scale;
    setTimeout(() => rgbShift *= 0.3, dur * 500);
    setTimeout(() => rgbShift = 0, dur * 1000);
  } else if (type === 'shake') {
    shakeAmount = intensity * 15 * scale;
  }
}

function applyGlitch() {
  if (shakeAmount > 0.5) {
    ctx.translate((Math.random()-0.5) * shakeAmount, (Math.random()-0.5) * shakeAmount);
    shakeAmount *= 0.88;
  }
  
  if (staticNoise > 0) {
    ctx.save();
    ctx.globalAlpha = staticNoise;
    for (let i = 0; i < 150; i++) {
      ctx.fillStyle = Math.random() > 0.5 ? '#fff' : '#000';
      ctx.fillRect(Math.random()*W, Math.random()*H, Math.random()*4*scale, Math.random()*2*scale);
    }
    ctx.restore();
  }
  
  if (rgbShift > 0.5) {
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = '#f00'; ctx.fillRect(rgbShift, 0, W, H);
    ctx.fillStyle = '#0ff'; ctx.fillRect(-rgbShift, 0, W, H);
    ctx.restore();
  }
  
  if (colorInvert) {
    ctx.save();
    ctx.globalCompositeOperation = 'difference';
    ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, W, H);
    ctx.restore();
  }
}

function drawScanlines() {
  ctx.save();
  ctx.globalAlpha = 0.04 + hauntLevel * 0.015;
  for (let y = 0; y < H; y += 3) {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, y, W, 1);
  }
  ctx.restore();
}

// ============================================================
// HAUNT SCHEDULE
// ============================================================
function scheduleHaunts() {
  const sp = hauntDifficulty === 'mild' ? 1.5 : hauntDifficulty === 'extreme' ? 0.6 : 1;
  function t(s) { return s * sp; }

  hauntSchedule = [
    // Level 0 â€” Subtle
    { t: t(4), fn: () => sfxWhisper() },
    { t: t(8), fn: () => addCreepyText('...hello?', W*0.3, H*0.6, 11, '#400') },
    { t: t(10), fn: () => showNotif('Tips', '', 'Tip: Tap screen corners to interact. Pay attention to symbols.', 'ðŸ’¡', 4000) },
    { t: t(13), fn: () => triggerGlitch('static', 0.08, 0.3) },
    { t: t(18), fn: () => showNotif('Messages', 'Unknown Number', 'I can see your screen right now.', 'ðŸ’¬') },
    { t: t(24), fn: () => sfxCreepy() },
    { t: t(26), fn: () => addCreepyText('is someone else here?', W*0.7, H*0.3, 10, '#430') },
    { t: t(28), fn: () => addCreepyText('don\'t turn around', W*0.6, H*0.4, 10, '#400') },

    // Level 1 â€” Unsettling
    { t: t(32), fn: () => { hauntLevel = 1; showCamera(); } },
    { t: t(35), fn: () => showNotif('Reminders', '', 'Remember: You are not alone in this room.', 'ðŸ””', 4000) },
    { t: t(37), fn: () => showNotif('Mom', '', 'Why did you leave me there?', 'ðŸ‘©', 5000) },
    { t: t(42), fn: () => { triggerGlitch('rgb', 0.4, 1); sfxWhisper(); } },
    { t: t(45), fn: () => addCreepyText('the walls are listening', W*0.4, H*0.55, 10, '#530') },
    { t: t(48), fn: () => showNotif('Battery', 'Low Battery', 'Battery at 3% â€” but you\'re plugged in.', 'ðŸ”‹') },
    { t: t(52), fn: () => { addCreepyText('IT KNOWS', W*0.5, H*0.7, 16, '#800'); sfxHeartbeat(); } },
    { t: t(55), fn: () => { triggerGlitch('shake', 0.5, 0.3); sfxCreepy(); } },
    { t: t(57), fn: () => showNotif('Screen Time', '', 'You\'ve been watched for 57 seconds.', 'ðŸ“Š') },

    // Level 2 â€” Nightmare
    { t: t(62), fn: () => { hauntLevel = 2; triggerGlitch('invert', 1, 1.5); sfxJumpscare(); } },
    { t: t(65), fn: () => addCreepyText('do you hear that breathing?', W*0.5, H*0.25, 11, '#600') },
    { t: t(67), fn: () => showNotif('\u26a0\ufe0f SYSTEM', 'WARNING', 'An unknown entity has accessed your device.', '\u26a0\ufe0f', 6000) },
    { t: t(72), fn: () => addCreepyText('Y\u0334O\u0336U\u0337 \u0336C\u0335A\u0337N\u0335\'\u0336T\u0335 \u0338L\u0336E\u0335A\u0338V\u0336E\u0336', W*0.5, H*0.5, 18, '#a00') },
    { t: t(76), fn: () => { sfxHeartbeat(); sfxWhisper(); } },
    { t: t(78), fn: () => { showCamera(); triggerGlitch('shake', 1.5, 0.8); } },
    { t: t(81), fn: () => showNotif('Notes', 'New Note', 'A note was created: "HELP ME HELP ME HELP ME"', 'ðŸ“', 5000) },
    { t: t(83), fn: () => showNotif('Photos', 'New Memory', 'A photo was taken just now. You didn\'t take it.', 'ðŸ“¸') },
    { t: t(86), fn: () => addCreepyText('it\'s inside the screen', W*0.3, H*0.65, 12, '#800') },
    { t: t(88), fn: () => { addCreepyText('BEHIND YOU', W*0.5, H*0.3, 22, '#f00'); sfxJumpscare(); triggerGlitch('shake', 2, 0.5); } },

    // Level 3 â€” Terror
    { t: t(92), fn: () => { hauntLevel = 3; sfxJumpscare(); triggerGlitch('static', 0.6, 2); } },
    { t: t(95), fn: () => { addCreepyText('YOUR EYES ARE BLEEDING', W*0.5, H*0.45, 16, '#c00'); triggerGlitch('rgb', 0.6, 1); } },
    { t: t(97), fn: () => showNotif('Unknown', '', 'I\u0338 \u0337A\u0338M\u0336 \u0334I\u0337N\u0336S\u0337I\u0338D\u0335E\u0335 \u0336Y\u0334O\u0335U\u0337R\u0337 \u0337P\u0335H\u0337O\u0338N\u0335E\u0335', 'ðŸ‘¹', 6000) },
    { t: t(100), fn: () => { sfxHeartbeat(); triggerGlitch('shake', 1, 0.5); } },
    { t: t(103), fn: () => addCreepyText('THERE IS NO ESCAPE', W*0.5, H*0.6, 20, '#f00') },
    { t: t(106), fn: () => showNotif('Voicemail', '1 New Message', 'Transcription: [heavy breathing for 47 seconds]', 'ðŸ“ž', 5000) },
    { t: t(108), fn: () => { triggerGlitch('invert', 1, 3); sfxHeartbeat(); } },
    { t: t(112), fn: () => addCreepyText('THE MIRROR KNOWS', W*0.6, H*0.35, 14, '#a00') },
    { t: t(115), fn: () => showNotif('System', 'CRITICAL', 'Device will self-destruct. Say goodbye.', 'ðŸ’£', 8000) },
    { t: t(120), fn: () => { addCreepyText('...unless you know the pattern', W*0.5, H*0.8, 10, '#060'); } },

    // Extended terror (120s+)
    { t: t(125), fn: () => showNotif('Location', 'Tracking', 'Your exact location has been shared with... something.', 'ðŸ“', 5000) },
    { t: t(130), fn: () => addCreepyText('counting down', W*0.4, H*0.7, 12, '#800') },
    { t: t(132), fn: () => { triggerGlitch('static', 0.8, 1); triggerGlitch('shake', 2, 1); sfxJumpscare(); } },
    { t: t(136), fn: () => showNotif('Calendar', 'Event', 'Funeral scheduled for today. Attendee: YOU.', 'ðŸ—“ï¸', 6000) },
    { t: t(138), fn: () => addCreepyText('I\u0336T\u0335 \u0337F\u0336E\u0335E\u0334D\u0338S\u0335 \u0334O\u0337N\u0335 \u0337F\u0334E\u0336A\u0335R\u0335', W*0.5, H*0.4, 24, '#f00') },
    { t: t(142), fn: () => { sfxJumpscare(); triggerGlitch('invert', 1, 0.5); triggerGlitch('shake', 3, 0.5); } },
    { t: t(145), fn: () => showNotif('Contacts', 'Alert', 'All your contacts have been replaced with "HIM".', 'ðŸ‘¤', 6000) },
    { t: t(150), fn: () => addCreepyText('3', W*0.5, H*0.5, 40, '#f00') },
    { t: t(152), fn: () => { triggerGlitch('invert', 1, 2); triggerGlitch('rgb', 0.8, 2); sfxHeartbeat(); } },
    { t: t(155), fn: () => addCreepyText('2', W*0.5, H*0.5, 40, '#f00') },
    { t: t(158), fn: () => addCreepyText('1', W*0.5, H*0.5, 40, '#f00') },
    { t: t(160), fn: () => showNotif('Health', '', 'Your heart rate is 180 BPM. Are you okay?', '\u2764\ufe0f\u200d\U0001FA79', 5000) },
    { t: t(165), fn: () => { sfxJumpscare(); triggerGlitch('static', 1, 2); addCreepyText('TIMES UP', W*0.5, H*0.5, 28, '#f00'); } },
    { t: t(168), fn: () => { addCreepyText('THE PATTERN IS YOUR ONLY HOPE', W*0.5, H*0.8, 12, '#0a0'); sfxWhisper(); } },
    { t: t(175), fn: () => { triggerGlitch('static', 1, 3); sfxJumpscare(); addCreepyText('TOO LATE', W*0.5, H*0.5, 30, '#f00'); } },
    { t: t(180), fn: () => showNotif('Find My', 'Alert', 'Someone is following your location in real-time.', 'ðŸ“', 6000) },
    { t: t(185), fn: () => showNotif('Unknown', 'FINAL WARNING', 'You have 30 seconds. \u2196 \u2198 \u2726 \u2197', '\u2620\ufe0f', 10000) },
    { t: t(195), fn: () => { triggerGlitch('static', 1, 5); triggerGlitch('invert', 1, 5); sfxJumpscare(); addCreepyText('GOODBYE', W*0.5, H*0.5, 40, '#f00'); } },
  ];
}

// ============================================================
// INPUT
// ============================================================
function getTapRegion(x, y) {
  const nx = x / W, ny = y / H;
  for (const [name, r] of Object.entries(regions)) {
    if (nx >= r.x && nx < r.x + r.w && ny >= r.y && ny < r.y + r.h) return name;
  }
  return null;
}

canvas.addEventListener('touchstart', handleTap, { passive: false });
canvas.addEventListener('mousedown', handleTap);

function handleTap(e) {
  if (e.touches) e.preventDefault();
  ensureAudio();
  const p = e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
  inputEvents.push({ type: 'tap', ...p });
}

// ============================================================
// DRAWING HELPERS
// ============================================================
function drawText(text, x, y, size, color = '#fff', align = 'center', font = null) {
  ctx.save();
  ctx.fillStyle = color;
  ctx.font = `${size * scale}px ${font || "-apple-system, 'Segoe UI', sans-serif"}`;
  ctx.textAlign = align;
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x, y);
  ctx.restore();
}

function drawTextBold(text, x, y, size, color = '#fff', align = 'center') {
  ctx.save();
  ctx.fillStyle = color;
  ctx.font = `bold ${size * scale}px -apple-system, 'Segoe UI', sans-serif`;
  ctx.textAlign = align;
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x, y);
  ctx.restore();
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.arcTo(x + w, y, x + w, y + r, r);
  ctx.lineTo(x + w, y + h - r);
  ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
  ctx.lineTo(x + r, y + h);
  ctx.arcTo(x, y + h, x, y + h - r, r);
  ctx.lineTo(x, y + r);
  ctx.arcTo(x, y, x + r, y, r);
  ctx.closePath();
}

// ============================================================
// FAKE PHONE HOME SCREEN
// ============================================================
function drawFakePhone() {
  // Status bar
  const now = new Date();
  const timeStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
  
  // Background â€” dark gradient
  const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
  const r = Math.min(20, hauntLevel * 8);
  bgGrad.addColorStop(0, `rgb(${10+r},${10},${15})`);
  bgGrad.addColorStop(1, `rgb(${5+r},${5},${10})`);
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, W, H);
  
  // Breathing pulse
  breathPhase += deltaTime * (0.8 + hauntLevel * 0.3);
  const breathAlpha = 0.02 + Math.sin(breathPhase) * 0.015 * (1 + hauntLevel);
  ctx.save();
  ctx.globalAlpha = breathAlpha;
  const breathGrad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)*0.6);
  breathGrad.addColorStop(0, hauntLevel >= 2 ? '#400' : '#222');
  breathGrad.addColorStop(1, '#000');
  ctx.fillStyle = breathGrad;
  ctx.fillRect(0, 0, W, H);
  ctx.restore();
  
  // Status bar
  ctx.save();
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.font = `600 ${13*scale}px -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(timeStr, W/2, 18*scale);
  
  // Fake signal, wifi, battery
  ctx.textAlign = 'right';
  ctx.font = `${11*scale}px -apple-system, sans-serif`;
  const battery = hauntLevel >= 1 ? (hauntLevel >= 2 ? '3%' : '13%') : '87%';
  const battColor = hauntLevel >= 2 ? '#f44' : hauntLevel >= 1 ? '#fa0' : 'rgba(255,255,255,0.5)';
  ctx.fillStyle = battColor;
  ctx.fillText(`ðŸ”‹ ${battery}`, W - 12*scale, 18*scale);
  
  ctx.textAlign = 'left';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('ðŸ“¶', 12*scale, 18*scale);
  ctx.restore();
  
  // App grid â€” with corruption at higher levels
  const gridCols = 4;
  const gridRows = 3;
  const appSize = 52 * scale;
  const gapX = (W - gridCols * appSize) / (gridCols + 1);
  const gapY = 20 * scale;
  const gridStartY = H * 0.25;
  
  for (let row = 0; row < gridRows; row++) {
    for (let col = 0; col < gridCols; col++) {
      const idx = row * gridCols + col;
      if (idx >= fakeApps.length) break;
      const app = fakeApps[idx];
      
      const ax = gapX + col * (appSize + gapX) + appSize/2;
      const ay = gridStartY + row * (appSize + gapY + 15*scale);
      
      // Corruption effect
      let corrupt = false;
      if (hauntLevel >= 2 && Math.random() < 0.03) corrupt = true;
      if (hauntLevel >= 3 && Math.random() < 0.08) corrupt = true;
      
      ctx.save();
      if (corrupt) {
        ctx.translate((Math.random()-0.5)*4*scale, (Math.random()-0.5)*4*scale);
        ctx.globalAlpha = 0.5 + Math.random() * 0.5;
      }
      
      // App icon bg
      ctx.fillStyle = corrupt ? '#400' : 'rgba(255,255,255,0.08)';
      roundRect(ax - appSize/2, ay - appSize/2, appSize, appSize, 12*scale);
      ctx.fill();
      
      // Icon
      ctx.font = `${24*scale}px sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillStyle = '#fff';
      ctx.fillText(corrupt ? 'ðŸ‘ï¸' : app.icon, ax, ay);
      
      // Label
      ctx.font = `${9*scale}px -apple-system, sans-serif`;
      ctx.fillStyle = corrupt ? '#f44' : 'rgba(255,255,255,0.6)';
      ctx.fillText(corrupt ? 'HÌ¸EÌ·LÌµPÌ´' : app.name, ax, ay + appSize/2 + 10*scale);
      
      ctx.restore();
    }
  }
  
  // Survival time (subtle, bottom area)
  const mins = Math.floor(survivalTime / 60);
  const secs = Math.floor(survivalTime % 60);
  const tStr = `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
  
  // At higher levels, glitch the time display
  if (hauntLevel >= 2) {
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#f00';
    ctx.font = `bold ${14*scale}px 'Courier New', monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(tStr, W/2 + (Math.random()-0.5)*3*scale, H - 80*scale + (Math.random()-0.5)*2*scale);
    ctx.restore();
  }
  
  drawText(tStr, W/2, H - 80*scale, 14, hauntLevel >= 2 ? '#f44' : '#666', 'center', "'Courier New', monospace");
  
  // Level label
  const levelNames = ['', 'UNSETTLING', 'NIGHTMARE', 'â—‰ TERROR â—‰'];
  if (hauntLevel >= 1) {
    const lbl = levelNames[hauntLevel];
    const lAlpha = 0.3 + Math.sin(gameTime * 3) * 0.15;
    ctx.save(); ctx.globalAlpha = lAlpha;
    drawText(lbl, W/2, H - 55*scale, 10, hauntLevel >= 3 ? '#f44' : '#888', 'center', "'Courier New', monospace");
    ctx.restore();
  }
  
  // --- VISUAL DISTURBANCES ---
  
  // Eyes (level 1+)
  if (hauntLevel >= 1) {
    const eyeCount = hauntLevel;
    for (let i = 0; i < eyeCount; i++) {
      const ex = W * (0.15 + i * 0.35 + Math.sin(gameTime * 0.5 + i) * 0.05);
      const ey = H * (0.65 + Math.sin(gameTime * 0.7 + i * 2) * 0.05);
      const blink = Math.sin(gameTime * 2.5 + i * 3) > 0.92;
      
      if (!blink) {
        ctx.save();
        ctx.globalAlpha = 0.15 + hauntLevel * 0.08;
        // Eye white
        ctx.fillStyle = '#ddd';
        ctx.beginPath();
        ctx.ellipse(ex, ey, 10*scale, 14*scale, 0, 0, Math.PI * 2);
        ctx.fill();
        // Pupil
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(ex + Math.sin(gameTime + i) * 3*scale, ey + Math.cos(gameTime * 0.8 + i) * 2*scale, 4*scale, 0, Math.PI * 2);
        ctx.fill();
        // Red iris
        ctx.fillStyle = hauntLevel >= 3 ? '#f00' : '#400';
        ctx.beginPath();
        ctx.arc(ex + Math.sin(gameTime + i) * 3*scale, ey + Math.cos(gameTime * 0.8 + i) * 2*scale, 2*scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
  }
  
  // Shadow figure (level 2+)
  if (hauntLevel >= 2) {
    const figAlpha = 0.1 + Math.sin(gameTime * 0.8) * 0.06;
    const fx = W * 0.85 + Math.sin(gameTime * 0.3) * 10*scale;
    const fy = H * 0.55;
    
    ctx.save();
    ctx.globalAlpha = figAlpha;
    ctx.fillStyle = '#000';
    // Head
    ctx.beginPath(); ctx.arc(fx, fy - 40*scale, 14*scale, 0, Math.PI*2); ctx.fill();
    // Body
    ctx.fillRect(fx - 10*scale, fy - 26*scale, 20*scale, 50*scale);
    // Arms
    ctx.fillRect(fx - 22*scale, fy - 20*scale, 44*scale, 6*scale);
    ctx.restore();
  }
  
  // Progressive hint system
  if (survivalTime > 15 && tapHistory.length < 1) {
    ctx.save();
    ctx.globalAlpha = 0.06 + Math.sin(gameTime * 1.5) * 0.03;
    drawText('Something is watching...', W/2, H - 28*scale, 9, '#484', 'center');
    ctx.restore();
  }
  if (survivalTime > 40 && tapHistory.length < 2) {
    ctx.save();
    ctx.globalAlpha = 0.1 + Math.sin(gameTime * 1.5) * 0.04;
    drawText('Tap the corners to fight back...', W/2, H - 28*scale, 9, '#484', 'center');
    ctx.restore();
  }
  
  // Show progress indicator
  if (tapHistory.length > 0) {
    const recent = tapHistory.slice(-4);
    let matches = 0;
    for (let i = 0; i < recent.length; i++) {
      if (recent[i] === correctCode[i]) matches++;
      else break;
    }
    if (matches > 0 && matches < correctCode.length) {
      ctx.save();
      ctx.globalAlpha = 0.2;
      const dots = [];
      for (let i = 0; i < correctCode.length; i++) {
        dots.push(i < matches ? 'â—‰' : 'â—‹');
      }
      drawText(dots.join(' '), W/2, H - 28*scale, 12, '#0f0', 'center');
      ctx.restore();
    }
  }
  
  // Bigger hint at level 3
  if (hauntLevel >= 3 && survivalTime > 100 && !solved) {
    ctx.save();
    ctx.globalAlpha = 0.12 + Math.sin(gameTime * 2) * 0.06;
    drawText('â†– â†˜ âœ¦ â†—', W/2, H - 28*scale, 14, '#0a0', 'center');
    ctx.restore();
  }
}

// ============================================================
// GAME STATES
// ============================================================
function startGame() {
  gameState = 'playing';
  survivalTime = 0;
  hauntLevel = 0;
  tapHistory = [];
  solved = false;
  creepyTexts = [];
  particles = [];
  scheduleHaunts();
  startDrone();
}

function resetGame() {
  gameState = 'menu';
  survivalTime = 0;
  hauntLevel = 0;
  staticNoise = 0; rgbShift = 0; colorInvert = false; shakeAmount = 0;
  tapHistory = [];
  solved = false;
  creepyTexts = [];
  particles = [];
  hauntSchedule = [];
  notifEl.classList.remove('show');
  document.getElementById('camera-indicator').classList.remove('active');
}

// ============================================================
// UPDATE
// ============================================================
function update() {
  for (const ev of inputEvents) {
    if (ev.type !== 'tap') continue;
    
    if (gameState === 'menu') {
      const bx = W/2, by = H/2 + 50*scale;
      if (Math.abs(ev.x - bx) < 110*scale && Math.abs(ev.y - by) < 30*scale) {
        startGame();
        continue;
      }
      // Difficulty selector
      const diffs = ['mild', 'normal', 'extreme'];
      diffs.forEach((d, i) => {
        const dx = W/2 + (i - 1) * 90*scale;
        const dy = H/2 + 115*scale;
        if (Math.abs(ev.x - dx) < 40*scale && Math.abs(ev.y - dy) < 20*scale) {
          hauntDifficulty = d;
          sfxTap();
        }
      });
      continue;
    }
    
    if (gameState === 'playing' && !solved) {
      sfxTap();
      const region = getTapRegion(ev.x, ev.y);
      if (region) {
        tapHistory.push(region);
        if (tapHistory.length > 10) tapHistory.shift();
        
        // Check code: look at last N taps and check forward match against correctCode
        const recent = tapHistory.slice(-correctCode.length);
        if (recent.length === correctCode.length && recent.every((r, i) => r === correctCode[i])) {
          solved = true;
          gameState = 'solved';
          sfxWin();
          spawnParticles(W/2, H/2, 40, '#0f0');
          notifEl.classList.remove('show');
          document.getElementById('camera-indicator').classList.remove('active');
        } else {
          // Check how many of the last taps match the start of the code (forward)
          let matchCount = 0;
          for (let i = 0; i < recent.length && i < correctCode.length; i++) {
            if (recent[i] === correctCode[i]) matchCount++;
            else break;
          }
          if (matchCount > 0 && matchCount < correctCode.length) {
            spawnParticles(ev.x, ev.y, 4, '#0a0');
            showToast(`Pattern: ${matchCount}/${correctCode.length}`);
          } else if (recent.length > 0 && matchCount === 0) {
            sfxWrongTap();
          }
        }
      }
      continue;
    }
    
    if (gameState === 'solved') {
      const by = H/2 + 100*scale;
      if (Math.abs(ev.x - W/2) < 110*scale && Math.abs(ev.y - by) < 30*scale) {
        resetGame();
      }
    }
  }
  inputEvents = [];
  
  if (gameState === 'playing') {
    survivalTime += deltaTime;
    
    // Execute haunts
    for (const h of hauntSchedule) {
      if (survivalTime >= h.t && !h.done) {
        h.fn();
        h.done = true;
      }
    }
    
    // Random ambient sounds
    if (hauntLevel >= 1 && Math.random() < 0.001) sfxWhisper();
    if (hauntLevel >= 2 && Math.random() < 0.002) sfxHeartbeat();
    if (hauntLevel >= 3 && Math.random() < 0.003) {
      triggerGlitch(['static', 'rgb', 'shake'][Math.floor(Math.random()*3)], 0.2 + Math.random()*0.3, 0.3);
    }
  }
  
  updateParticles();
}

// ============================================================
// DRAW
// ============================================================
function draw() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);
  
  ctx.save();
  applyGlitch();
  
  if (gameState === 'menu') drawMenu();
  else if (gameState === 'playing') drawPlaying();
  else if (gameState === 'solved') drawSolved();
  
  drawParticles();
  drawScanlines();
  ctx.restore();
}

function drawMenu() {
  // Dark atmospheric background
  const bgGrad = ctx.createRadialGradient(W/2, H*0.4, 0, W/2, H*0.4, Math.max(W,H)*0.6);
  bgGrad.addColorStop(0, '#0a0a12');
  bgGrad.addColorStop(1, '#000');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, W, H);
  
  drawFog();
  
  const ty = H/2 - 80*scale;
  
  // Glitch shadow
  ctx.save();
  ctx.globalAlpha = 0.2;
  drawTextBold('HAUNTED', W/2 + 2*scale, ty + 2*scale, 46, '#f00');
  drawTextBold('HAUNTED', W/2 - 2*scale, ty - 1*scale, 46, '#0f0');
  ctx.restore();
  
  drawTextBold('HAUNTED', W/2, ty, 46, '#fff');
  
  drawText('Your phone is about to turn against you.', W/2, ty + 55*scale, 12, '#777');
  
  // START button
  const by = H/2 + 50*scale;
  const pulse = Math.sin(gameTime * 2.5) * 4 * scale;
  
  ctx.save();
  ctx.shadowColor = '#f00';
  ctx.shadowBlur = 15*scale + pulse;
  ctx.fillStyle = '#c00';
  roundRect(W/2 - 100*scale, by - 28*scale, 200*scale, 56*scale, 10*scale);
  ctx.fill();
  ctx.restore();
  
  drawTextBold('START HAUNTING', W/2, by, 16, '#fff');
  
  // Difficulty selector
  const diffs = ['mild', 'normal', 'extreme'];
  const diffLabels = { mild: 'Mild', normal: 'Normal', extreme: 'Extreme' };
  const diffColors = { mild: '#4a4', normal: '#a80', extreme: '#c00' };
  const diffDescs = { mild: 'Slower scares', normal: 'Standard terror', extreme: 'Relentless' };
  diffs.forEach((d, i) => {
    const dx = W/2 + (i - 1) * 90*scale;
    const dy = H/2 + 115*scale;
    ctx.fillStyle = hauntDifficulty === d ? diffColors[d] : '#181818';
    roundRect(dx - 38*scale, dy - 18*scale, 76*scale, 36*scale, 8*scale);
    ctx.fill();
    ctx.strokeStyle = hauntDifficulty === d ? diffColors[d] : '#333';
    ctx.lineWidth = 1;
    roundRect(dx - 38*scale, dy - 18*scale, 76*scale, 36*scale, 8*scale);
    ctx.stroke();
    drawText(diffLabels[d], dx, dy - 4*scale, 11, hauntDifficulty === d ? '#fff' : '#666');
    drawText(diffDescs[d], dx, dy + 10*scale, 7, hauntDifficulty === d ? '#ddd' : '#444');
  });

  // Instructions
  drawText('Survive as long as you can.', W/2, H - 90*scale, 11, '#555');
  drawText('There IS a way to stop it.', W/2, H - 65*scale, 11, '#555');
  drawText('Tap corners in the right pattern...', W/2, H - 42*scale, 10, '#444');
  
  // Vignette
  const vig = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.25, W/2, H/2, Math.max(W,H)*0.65);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.5)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, W, H);
}

function drawPlaying() {
  drawFakePhone();
  drawFog(hauntLevel >= 2 ? 1 : 0);
  drawCreepyTexts();
  
  // Vignette â€” gets darker with haunt level
  const vig = ctx.createRadialGradient(W/2, H/2, Math.min(W,H)*0.2, W/2, H/2, Math.max(W,H)*0.6);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, `rgba(0,0,0,${0.3 + hauntLevel * 0.1})`);
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, W, H);
}

function drawSolved() {
  // Peaceful black with green tint
  const bgGrad = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W,H)*0.5);
  bgGrad.addColorStop(0, '#001a00');
  bgGrad.addColorStop(1, '#000');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, W, H);
  
  ctx.save();
  const t = Math.min(1, survivalTime * 0.1); // fade in
  ctx.globalAlpha = 0.6 + Math.sin(gameTime * 1.5) * 0.2;
  
  drawTextBold('CLEANSED', W/2, H/2 - 90*scale, 36, '#0f0');
  ctx.restore();
  
  drawText('You stopped the haunting.', W/2, H/2 - 40*scale, 16, '#aaa');
  drawText(`Survived: ${Math.floor(survivalTime)}s`, W/2, H/2 - 10*scale, 14, '#888');
  drawText(`Peak level: ${['SUBTLE','UNSETTLING','NIGHTMARE','TERROR'][hauntLevel]}`, W/2, H/2 + 15*scale, 12, '#666');
  
  // Rating
  let rating = 'ðŸŒ‘ AMATEUR', rColor = '#555';
  if (survivalTime > 110) { rating = 'ðŸŒŸ LEGEND'; rColor = '#fa0'; }
  else if (survivalTime > 85) { rating = 'â­ FEARLESS'; rColor = '#da0'; }
  else if (survivalTime > 60) { rating = 'ðŸ’ª BRAVE'; rColor = '#8a8'; }
  else if (survivalTime > 35) { rating = 'ðŸ«£ SURVIVOR'; rColor = '#686'; }
  
  drawTextBold(rating, W/2, H/2 + 50*scale, 18, rColor);
  
  // Play again
  const by = H/2 + 100*scale;
  ctx.fillStyle = '#222';
  roundRect(W/2 - 100*scale, by - 25*scale, 200*scale, 50*scale, 8*scale);
  ctx.fill();
  ctx.strokeStyle = '#444'; ctx.lineWidth = 1.5;
  roundRect(W/2 - 100*scale, by - 25*scale, 200*scale, 50*scale, 8*scale);
  ctx.stroke();
  drawText('PLAY AGAIN', W/2, by, 14, '#ccc');
  
  // Best time
  var bestTime = 0;
  try { bestTime = parseInt(localStorage.getItem('haunted_best')) || 0; } catch(e){}
  if (Math.floor(survivalTime) > bestTime) {
    try { localStorage.setItem('haunted_best', Math.floor(survivalTime)); } catch(e){}
    drawText('ðŸ† NEW RECORD!', W/2, H - 60*scale, 12, '#fa0');
  } else if (bestTime > 0) {
    drawText(`Best: ${bestTime}s`, W/2, H - 60*scale, 10, '#555');
  }
  drawText('Secret: Tap â†– â†˜ âœ¦ â†—', W/2, H - 40*scale, 9, '#444');
}

// ============================================================
// LOOP
// ============================================================
function gameLoop(ts) {
  deltaTime = Math.min((ts - lastTime) / 1000, 0.1);
  lastTime = ts;
  gameTime += deltaTime;
  
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

resetGame();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
