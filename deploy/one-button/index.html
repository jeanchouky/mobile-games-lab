<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>One Button Odyssey</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #000;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  font-family: monospace;
}
canvas {
  display: block;
  margin: 0 auto;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}
body {
  display: flex;
  align-items: center;
  justify-content: center;
}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
'use strict';

// ============================================================
// ONE BUTTON ODYSSEY - Mobile RPG
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// --- GLOBALS ---
let W, H, pixelScale;
let gameTime = 0, deltaTime = 0, lastTime = 0;
let gameState = 'title'; // title, combat, shop, dialogue, victory
let currentZone = 0; // 0=forest, 1=cave, 2=castle
let currentEncounter = 0;
let beatTime = 0;
let beatPeriod = 0.6; // beat every 0.6s
let lastBeatTime = 0;
let inputQueue = [];
let particles = [];
let shakeAmount = 0;

// Player stats
let player = {
  hp: 100,
  maxHp: 100,
  xp: 0,
  level: 1,
  gold: 0,
  attack: 10,
  defense: 5
};

// Enemy state
let enemy = null;
let enemyAttackTimer = 0;
let enemyAttackWarning = false;

// Combat state
let combatState = 'waiting'; // waiting, attacking, blocking, dodging, hit
let actionTimer = 0;
let comboCount = 0;
let lastActionTime = 0;

// Music state
let musicPlaying = false;
let bgmOscillators = [];

// Zone definitions
const zones = [
  { 
    name: 'Darkwood Forest', 
    bg: '#2a1a3a', 
    fg: '#4a6741', 
    accent: '#7a9a5f',
    enemies: ['slime', 'goblin', 'wolf', 'bat', 'spider'],
    boss: 'treant'
  },
  { 
    name: 'Crimson Caves', 
    bg: '#3a1a1a', 
    fg: '#5a3a3a', 
    accent: '#8a5a5a',
    enemies: ['bat', 'skeleton', 'ghost', 'spider', 'zombie'],
    boss: 'demon'
  },
  { 
    name: 'Obsidian Castle', 
    bg: '#1a1a3a', 
    fg: '#3a3a5a', 
    accent: '#5a5a8a',
    enemies: ['knight', 'mage', 'dragon', 'golem', 'wraith'],
    boss: 'darklord'
  }
];

// Enemy definitions
const enemyTypes = {
  slime: { name: 'Slime', hp: 30, atk: 5, speed: 2.5, color: '#5a9a4a', xp: 10, gold: 5 },
  goblin: { name: 'Goblin', hp: 40, atk: 8, speed: 2.0, color: '#6a7a3a', xp: 15, gold: 8 },
  wolf: { name: 'Wolf', hp: 45, atk: 10, speed: 1.8, color: '#7a6a5a', xp: 20, gold: 10 },
  bat: { name: 'Bat', hp: 25, atk: 6, speed: 1.5, color: '#5a4a6a', xp: 12, gold: 6 },
  spider: { name: 'Spider', hp: 35, atk: 9, speed: 2.2, color: '#4a3a3a', xp: 18, gold: 9 },
  skeleton: { name: 'Skeleton', hp: 50, atk: 12, speed: 2.3, color: '#8a8a7a', xp: 25, gold: 15 },
  ghost: { name: 'Ghost', hp: 40, atk: 11, speed: 1.7, color: '#6a7a8a', xp: 22, gold: 12 },
  zombie: { name: 'Zombie', hp: 60, atk: 10, speed: 3.0, color: '#5a6a4a', xp: 28, gold: 18 },
  knight: { name: 'Knight', hp: 70, atk: 15, speed: 2.5, color: '#7a7a8a', xp: 35, gold: 25 },
  mage: { name: 'Mage', hp: 50, atk: 18, speed: 2.0, color: '#6a5a8a', xp: 40, gold: 30 },
  dragon: { name: 'Dragon', hp: 80, atk: 20, speed: 2.2, color: '#8a4a4a', xp: 50, gold: 40 },
  golem: { name: 'Golem', hp: 90, atk: 16, speed: 3.5, color: '#6a6a5a', xp: 45, gold: 35 },
  wraith: { name: 'Wraith', hp: 65, atk: 22, speed: 1.6, color: '#4a4a5a', xp: 55, gold: 45 },
  treant: { name: 'Ancient Treant', hp: 150, atk: 18, speed: 2.8, color: '#5a7a3a', xp: 100, gold: 100 },
  demon: { name: 'Fire Demon', hp: 200, atk: 25, speed: 2.0, color: '#aa3a3a', xp: 150, gold: 150 },
  darklord: { name: 'Dark Lord', hp: 300, atk: 30, speed: 1.8, color: '#3a3a6a', xp: 200, gold: 200 }
};

// Shop items
const shopItems = [
  { name: 'Health Potion', cost: 20, effect: () => { player.hp = Math.min(player.maxHp, player.hp + 30); sfxHeal(); } },
  { name: 'Attack Boost', cost: 50, effect: () => { player.attack += 5; player.maxHp += 10; player.hp += 10; } },
  { name: 'Defense Ring', cost: 40, effect: () => { player.defense += 3; player.maxHp += 15; player.hp += 15; } },
  { name: 'Max HP Up', cost: 30, effect: () => { player.maxHp += 20; player.hp += 20; } }
];

// ============================================================
// AUDIO ENGINE
// ============================================================
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playTone(freq, duration, type = 'square', vol = 0.12) {
  ensureAudio();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function sfxHit() { playTone(440, 0.08, 'square', 0.15); }
function sfxBlock() { playTone(220, 0.12, 'square', 0.12); }
function sfxDodge() { playTone(880, 0.06, 'sine', 0.1); }
function sfxParry() { playTone(660, 0.1, 'triangle', 0.15); setTimeout(() => playTone(880, 0.1, 'triangle', 0.15), 60); }
function sfxPlayerHit() { playTone(150, 0.2, 'sawtooth', 0.18); }
function sfxEnemyDeath() { playTone(200, 0.15, 'sawtooth', 0.15); setTimeout(() => playTone(100, 0.25, 'sawtooth', 0.12), 150); }
function sfxLevelUp() { 
  playTone(523, 0.1, 'sine', 0.12); 
  setTimeout(() => playTone(659, 0.1, 'sine', 0.12), 100); 
  setTimeout(() => playTone(784, 0.15, 'sine', 0.12), 200);
  setTimeout(() => playTone(1047, 0.2, 'sine', 0.12), 350);
}
function sfxCoin() { playTone(800, 0.05, 'sine', 0.1); setTimeout(() => playTone(1200, 0.05, 'sine', 0.1), 50); }
function sfxPurchase() { playTone(880, 0.08, 'triangle', 0.1); setTimeout(() => playTone(1100, 0.08, 'triangle', 0.1), 80); }
function sfxBeat() { playTone(660, 0.04, 'sine', 0.08); }
function sfxHeal() { playTone(440, 0.1, 'sine', 0.1); setTimeout(() => playTone(550, 0.1, 'sine', 0.1), 90); }
function sfxVictory() {
  [262, 330, 392, 523].forEach((f, i) => {
    setTimeout(() => playTone(f, 0.15, 'triangle', 0.12), i * 120);
  });
}

// Background music (simple chiptune melody)
function startBGM() {
  if (musicPlaying) return;
  musicPlaying = true;
  ensureAudio();
  
  const melody = [262, 294, 330, 349, 392, 440, 494, 523]; // C major scale
  let noteIndex = 0;
  
  function playNote() {
    if (!musicPlaying) return;
    const freq = melody[noteIndex % melody.length];
    noteIndex++;
    playTone(freq, 0.2, 'square', 0.04);
    setTimeout(playNote, 300);
  }
  playNote();
}

function stopBGM() {
  musicPlaying = false;
}

// ============================================================
// RESIZE
// ============================================================
function resize() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  
  // Fixed game resolution
  const gameW = 360;
  const gameH = 640;
  pixelScale = Math.min(W / gameW, H / gameH);
  
  canvas.width = gameW;
  canvas.height = gameH;
  canvas.style.width = (gameW * pixelScale) + 'px';
  canvas.style.height = (gameH * pixelScale) + 'px';
}
window.addEventListener('resize', resize);
resize();

// ============================================================
// DRAWING HELPERS
// ============================================================
function drawPixelRect(x, y, w, h, color) {
  ctx.fillStyle = color;
  ctx.fillRect(Math.floor(x), Math.floor(y), Math.floor(w), Math.floor(h));
}

function drawPixelText(text, x, y, size = 8, color = '#fff') {
  ctx.fillStyle = color;
  ctx.font = `${size}px monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, Math.floor(x), Math.floor(y));
}

function drawHPBar(x, y, w, h, current, max, fgColor = '#4a9a4a', bgColor = '#3a3a3a') {
  drawPixelRect(x, y, w, h, bgColor);
  const fillW = Math.floor((current / max) * w);
  if (fillW > 0) drawPixelRect(x, y, fillW, h, fgColor);
  
  // Border
  ctx.strokeStyle = '#8a8a8a';
  ctx.lineWidth = 1;
  ctx.strokeRect(Math.floor(x), Math.floor(y), Math.floor(w), Math.floor(h));
}

function drawPlayer(x, y, size = 16) {
  // Simple pixel character
  const s = size;
  // Head
  drawPixelRect(x - s/4, y - s, s/2, s/2, '#faa');
  // Body
  drawPixelRect(x - s/3, y - s/2, s * 2/3, s/2, '#4a6a9a');
  // Legs
  drawPixelRect(x - s/3, y, s/4, s/2, '#3a4a6a');
  drawPixelRect(x + s/12, y, s/4, s/2, '#3a4a6a');
  // Weapon (sword)
  if (combatState === 'attacking') {
    drawPixelRect(x + s/2, y - s/2, s/2, s/8, '#aa8a5a');
  } else {
    drawPixelRect(x - s/2, y - s/4, s/2, s/8, '#aa8a5a');
  }
}

function drawEnemy(enemy, x, y, size = 20) {
  if (!enemy) return;
  const s = size;
  const type = enemyTypes[enemy.type];
  
  // Flash white when damaged
  const flash = enemy.damaged && (gameTime % 0.1) < 0.05;
  const color = flash ? '#fff' : type.color;
  
  // Different shapes for different enemies
  if (enemy.type === 'slime' || enemy.type === 'ghost') {
    // Blob shape
    drawPixelRect(x - s/2, y - s/3, s, s/3, color);
    drawPixelRect(x - s/3, y - s * 2/3, s * 2/3, s/3, color);
    drawPixelRect(x - s/4, y - s, s/2, s/3, color);
    // Eyes
    drawPixelRect(x - s/4, y - s * 2/3, s/6, s/6, '#fff');
    drawPixelRect(x + s/12, y - s * 2/3, s/6, s/6, '#fff');
  } else if (enemy.type === 'bat' || enemy.type === 'spider') {
    // Winged/legged
    drawPixelRect(x - s/4, y - s/2, s/2, s/2, color);
    drawPixelRect(x - s/2, y - s/4, s/4, s/8, color);
    drawPixelRect(x + s/4, y - s/4, s/4, s/8, color);
    if (enemy.type === 'bat') {
      drawPixelRect(x - s * 3/4, y - s/3, s/4, s/6, color);
      drawPixelRect(x + s/2, y - s/3, s/4, s/6, color);
    }
  } else if (enemy.type.includes('boss') || enemy.type === 'treant' || enemy.type === 'demon' || enemy.type === 'darklord' || enemy.type === 'dragon') {
    // Boss - larger and more detailed
    drawPixelRect(x - s * 3/4, y - s, s * 3/2, s, color);
    drawPixelRect(x - s/2, y - s * 3/2, s, s/2, color);
    // Eyes
    drawPixelRect(x - s/3, y - s * 4/3, s/4, s/4, '#aa3a3a');
    drawPixelRect(x + s/12, y - s * 4/3, s/4, s/4, '#aa3a3a');
    // Horns or spikes
    drawPixelRect(x - s * 5/6, y - s * 7/4, s/3, s/4, color);
    drawPixelRect(x + s/2, y - s * 7/4, s/3, s/4, color);
  } else {
    // Humanoid
    drawPixelRect(x - s/4, y - s, s/2, s/3, color);
    drawPixelRect(x - s/3, y - s * 2/3, s * 2/3, s/3, color);
    drawPixelRect(x - s/3, y - s/3, s/4, s/3, color);
    drawPixelRect(x + s/12, y - s/3, s/4, s/3, color);
    // Weapon
    drawPixelRect(x + s/3, y - s/2, s/3, s/8, '#8a8a8a');
  }
  
  // Attack warning indicator
  if (enemyAttackWarning && (gameTime % 0.15) < 0.075) {
    drawPixelRect(x - s - 4, y - s/2 - 4, 4, 4, '#aa3a3a');
  }
}

function drawBeatIndicator(x, y, radius = 30) {
  // Calculate beat phase
  const phase = (gameTime - lastBeatTime) / beatPeriod;
  const pulse = Math.sin(phase * Math.PI * 2);
  
  // Perfect timing window
  const perfectWindow = 0.15;
  const inPerfect = phase > (1 - perfectWindow) || phase < perfectWindow;
  const inGood = phase > (1 - perfectWindow * 2) || phase < perfectWindow * 2;
  
  // Outer ring
  ctx.strokeStyle = inPerfect ? '#ffd700' : (inGood ? '#aaa' : '#555');
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.stroke();
  
  // Inner pulse
  const innerRadius = radius * 0.3 + (1 - Math.abs(pulse)) * radius * 0.3;
  drawPixelRect(x - innerRadius, y - innerRadius, innerRadius * 2, innerRadius * 2, '#ffdd44');
  
  // TAP text
  drawPixelText('TAP', x, y + radius + 12, 8, '#fff');
  
  // Action feedback
  if (actionTimer > 0) {
    const alpha = Math.min(1, actionTimer / 0.3);
    ctx.globalAlpha = alpha;
    let feedbackColor = '#fff';
    let feedbackText = '';
    
    if (combatState === 'attacking') {
      feedbackColor = '#ff4444';
      feedbackText = comboCount > 1 ? `HIT x${comboCount}!` : 'HIT!';
    } else if (combatState === 'blocking') {
      feedbackColor = '#4444ff';
      feedbackText = 'BLOCK!';
    } else if (combatState === 'dodging') {
      feedbackColor = '#44ff44';
      feedbackText = 'DODGE!';
    }
    
    drawPixelText(feedbackText, x, y - radius - 20, 10, feedbackColor);
    ctx.globalAlpha = 1;
  }
}

function spawnParticles(x, y, count, color) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4 - 2,
      life: 1,
      color
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.2;
    p.life -= 0.02;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    drawPixelRect(p.x - 2, p.y - 2, 4, 4, p.color);
    ctx.globalAlpha = 1;
  });
}

function shake(amount = 8) {
  shakeAmount = amount;
}

function applyShake() {
  if (shakeAmount > 0.5) {
    ctx.translate(
      Math.floor((Math.random() - 0.5) * shakeAmount),
      Math.floor((Math.random() - 0.5) * shakeAmount)
    );
    shakeAmount *= 0.85;
  } else {
    shakeAmount = 0;
  }
}

// ============================================================
// GAME LOGIC
// ============================================================

function startGame() {
  gameState = 'combat';
  currentZone = 0;
  currentEncounter = 0;
  player = {
    hp: 100,
    maxHp: 100,
    xp: 0,
    level: 1,
    gold: 0,
    attack: 10,
    defense: 5
  };
  startCombat();
  startBGM();
}

function startCombat() {
  const zone = zones[currentZone];
  
  // Boss fight every 5 encounters
  if (currentEncounter > 0 && currentEncounter % 5 === 0) {
    enemy = createEnemy(zone.boss, true);
  } else {
    const enemyType = zone.enemies[Math.floor(Math.random() * zone.enemies.length)];
    enemy = createEnemy(enemyType, false);
  }
  
  combatState = 'waiting';
  enemyAttackTimer = enemy.speed;
  enemyAttackWarning = false;
  comboCount = 0;
}

function createEnemy(type, isBoss) {
  const template = enemyTypes[type];
  return {
    type,
    name: template.name,
    hp: template.hp * (isBoss ? 1 : 1),
    maxHp: template.hp * (isBoss ? 1 : 1),
    atk: template.atk,
    speed: template.speed,
    xp: template.xp,
    gold: template.gold,
    isBoss,
    damaged: false
  };
}

function checkBeatTiming() {
  const phase = (gameTime - lastBeatTime) / beatPeriod;
  const perfectWindow = 0.15;
  const goodWindow = 0.25;
  
  // Wrap phase to [0, 1]
  const wrappedPhase = phase - Math.floor(phase);
  const distFromBeat = Math.min(wrappedPhase, 1 - wrappedPhase);
  
  if (distFromBeat < perfectWindow) return 'perfect';
  if (distFromBeat < goodWindow) return 'good';
  return 'miss';
}

function playerAttack() {
  const timing = checkBeatTiming();
  
  if (timing === 'miss') {
    combatState = 'waiting';
    return;
  }
  
  combatState = 'attacking';
  actionTimer = 0.5;
  
  const damage = Math.floor(player.attack * (timing === 'perfect' ? 1.5 : 1.0));
  enemy.hp -= damage;
  enemy.damaged = true;
  setTimeout(() => { if (enemy) enemy.damaged = false; }, 200);
  
  if (timing === 'perfect') {
    comboCount++;
    sfxParry();
  } else {
    comboCount = 1;
    sfxHit();
  }
  
  spawnParticles(200, 150, 8, '#ff4444');
  shake(5);
  
  if (enemy.hp <= 0) {
    enemyDefeated();
  }
}

function playerBlock() {
  const timing = checkBeatTiming();
  if (timing === 'miss') return;
  
  combatState = 'blocking';
  actionTimer = 0.5;
  comboCount = 0;
  sfxBlock();
  
  // Reset enemy attack if blocking during warning
  if (enemyAttackWarning && timing === 'perfect') {
    enemyAttackTimer = enemy.speed;
    enemyAttackWarning = false;
    spawnParticles(180, 250, 6, '#4444ff');
  }
}

function playerDodge() {
  const timing = checkBeatTiming();
  if (timing !== 'perfect') return;
  
  combatState = 'dodging';
  actionTimer = 0.5;
  comboCount = 0;
  sfxDodge();
  
  // Reset enemy attack completely
  enemyAttackTimer = enemy.speed * 1.5;
  enemyAttackWarning = false;
  spawnParticles(180, 320, 10, '#44ff44');
}

function enemyAttack() {
  if (combatState === 'blocking') {
    // Blocked - reduced damage
    const damage = Math.max(1, Math.floor((enemy.atk - player.defense) * 0.3));
    player.hp -= damage;
    sfxBlock();
    spawnParticles(180, 320, 5, '#8888ff');
  } else if (combatState === 'dodging') {
    // Dodged - no damage
    sfxDodge();
  } else {
    // Full damage
    const damage = Math.max(1, enemy.atk - Math.floor(player.defense * 0.5));
    player.hp -= damage;
    sfxPlayerHit();
    shake(8);
    spawnParticles(180, 320, 12, '#aa3a3a');
  }
  
  if (player.hp <= 0) {
    playerDeath();
  }
  
  combatState = 'waiting';
  enemyAttackTimer = enemy.speed;
  enemyAttackWarning = false;
}

function enemyDefeated() {
  sfxEnemyDeath();
  spawnParticles(200, 150, 20, enemyTypes[enemy.type].color);
  shake(10);
  
  // Rewards
  player.xp += enemy.xp;
  player.gold += enemy.gold;
  sfxCoin();
  
  // Check level up
  const xpNeeded = player.level * 50;
  if (player.xp >= xpNeeded) {
    player.level++;
    player.xp -= xpNeeded;
    player.maxHp += 20;
    player.hp = player.maxHp;
    player.attack += 3;
    player.defense += 2;
    sfxLevelUp();
    spawnParticles(180, 320, 30, '#ffd700');
  }
  
  currentEncounter++;
  
  // Check zone completion (boss defeated)
  if (enemy.isBoss) {
    if (currentZone < zones.length - 1) {
      setTimeout(() => {
        gameState = 'shop';
      }, 1500);
    } else {
      setTimeout(() => {
        gameState = 'victory';
        sfxVictory();
      }, 1500);
    }
  } else {
    setTimeout(() => {
      startCombat();
    }, 1000);
  }
  
  enemy = null;
}

function playerDeath() {
  player.hp = player.maxHp;
  currentEncounter = Math.max(0, Math.floor(currentEncounter / 5) * 5);
  shake(15);
  
  setTimeout(() => {
    startCombat();
  }, 1500);
}

function nextZone() {
  currentZone++;
  currentEncounter = 0;
  player.hp = player.maxHp;
  gameState = 'combat';
  startCombat();
}

// ============================================================
// UPDATE & DRAW
// ============================================================

function update() {
  // Beat tracking
  beatTime += deltaTime;
  if (beatTime - lastBeatTime >= beatPeriod) {
    lastBeatTime = beatTime;
    sfxBeat();
  }
  
  // Action timer
  if (actionTimer > 0) {
    actionTimer -= deltaTime;
    if (actionTimer <= 0) {
      combatState = 'waiting';
    }
  }
  
  updateParticles();
  
  if (gameState === 'combat' && enemy) {
    // Enemy AI
    enemyAttackTimer -= deltaTime;
    
    if (enemyAttackTimer < 0.8 && !enemyAttackWarning) {
      enemyAttackWarning = true;
    }
    
    if (enemyAttackTimer <= 0) {
      enemyAttack();
    }
  }
  
  // Process input
  for (const ev of inputQueue) {
    if (gameState === 'title') {
      startGame();
    } else if (gameState === 'combat') {
      handleCombatInput(ev);
    } else if (gameState === 'shop') {
      handleShopInput(ev);
    } else if (gameState === 'victory') {
      gameState = 'title';
      currentZone = 0;
      currentEncounter = 0;
    }
  }
  inputQueue = [];
}

function handleCombatInput(ev) {
  if (!enemy || actionTimer > 0) return;
  
  const tapY = ev.y / pixelScale;
  
  // Determine action based on tap position
  if (tapY > 500) {
    // Bottom area - primary attack
    playerAttack();
  } else if (tapY < 200) {
    // Top area - block
    playerBlock();
  } else if (ev.quick) {
    // Double tap - dodge
    playerDodge();
  } else {
    // Default - attack
    playerAttack();
  }
}

let lastTapTime = 0;
function processInput(x, y) {
  const now = gameTime;
  const quick = (now - lastTapTime) < 0.3;
  lastTapTime = now;
  inputQueue.push({ x, y, quick });
}

function handleShopInput(ev) {
  const tapX = ev.x / pixelScale;
  const tapY = ev.y / pixelScale;
  
  // Shop items positioned vertically
  const itemHeight = 70;
  const startY = 150;
  
  shopItems.forEach((item, i) => {
    const itemY = startY + i * itemHeight;
    if (tapY > itemY && tapY < itemY + 60 && tapX > 40 && tapX < 320) {
      if (player.gold >= item.cost) {
        player.gold -= item.cost;
        item.effect();
        sfxPurchase();
        spawnParticles(180, itemY + 30, 10, '#ffd700');
      }
    }
  });
  
  // Continue button
  if (tapY > 550 && tapY < 600) {
    nextZone();
  }
}

function draw() {
  ctx.save();
  applyShake();
  
  const zone = zones[currentZone];
  
  // Background
  drawPixelRect(0, 0, 360, 640, zone.bg);
  
  // Ground
  drawPixelRect(0, 400, 360, 240, zone.fg);
  
  if (gameState === 'title') {
    drawTitle();
  } else if (gameState === 'combat') {
    drawCombat();
  } else if (gameState === 'shop') {
    drawShop();
  } else if (gameState === 'victory') {
    drawVictory();
  }
  
  drawParticles();
  ctx.restore();
}

function drawTitle() {
  drawPixelText('ONE BUTTON', 180, 200, 24, '#ffd700');
  drawPixelText('ODYSSEY', 180, 240, 24, '#ffd700');
  
  drawPixelText('TAP TO START', 180, 400, 12, '#fff');
  
  // Animated player
  drawPlayer(180, 500, 20);
  
  drawPixelText('An RPG controlled with', 180, 540, 8, '#aaa');
  drawPixelText('a single tap', 180, 555, 8, '#aaa');
}

function drawCombat() {
  // UI Header
  drawPixelRect(0, 0, 360, 40, '#1a1a2a');
  
  // Player HP
  drawPixelText('HP', 30, 12, 8, '#fff');
  drawHPBar(10, 20, 150, 12, player.hp, player.maxHp, '#4a9a4a', '#3a1a1a');
  
  // Enemy HP
  if (enemy) {
    drawPixelText(enemy.name, 290, 12, 8, '#fff');
    const hpColor = enemy.isBoss ? '#aa3a3a' : '#4a9a4a';
    drawHPBar(200, 20, 150, 12, enemy.hp, enemy.maxHp, hpColor, '#3a1a1a');
  }
  
  // Zone name
  drawPixelText(zones[currentZone].name, 180, 50, 10, zones[currentZone].accent);
  
  // Enemy
  if (enemy) {
    const enemySize = enemy.isBoss ? 40 : 24;
    drawEnemy(enemy, 200, 150, enemySize);
  }
  
  // Player
  drawPlayer(180, 320, 20);
  
  // Beat indicator
  drawBeatIndicator(180, 530, 35);
  
  // Stats footer
  drawPixelText(`LV ${player.level}  XP ${player.xp}  GOLD ${player.gold}`, 180, 610, 8, '#aaa');
  
  // Combat hints
  const hintY = 360;
  ctx.globalAlpha = 0.5;
  drawPixelText('Bottom: ATTACK', 180, hintY, 7, '#ff8888');
  drawPixelText('Top: BLOCK', 180, hintY + 12, 7, '#8888ff');
  drawPixelText('Double-tap: DODGE', 180, hintY + 24, 7, '#88ff88');
  ctx.globalAlpha = 1;
}

function drawShop() {
  drawPixelRect(0, 0, 360, 640, '#2a1a3a');
  
  drawPixelText('SHOP', 180, 50, 20, '#ffd700');
  drawPixelText(`Gold: ${player.gold}`, 180, 90, 12, '#ffdd88');
  
  // Draw merchant
  drawPixelRect(160, 100, 40, 30, '#8a6a4a');
  drawPixelRect(165, 110, 10, 10, '#faa');
  drawPixelRect(185, 110, 10, 10, '#faa');
  
  // Items
  const startY = 150;
  const itemHeight = 70;
  
  shopItems.forEach((item, i) => {
    const itemY = startY + i * itemHeight;
    const canAfford = player.gold >= item.cost;
    
    drawPixelRect(40, itemY, 280, 60, canAfford ? '#3a4a5a' : '#2a2a3a');
    ctx.strokeStyle = canAfford ? '#6a7a8a' : '#4a4a4a';
    ctx.lineWidth = 2;
    ctx.strokeRect(40, itemY, 280, 60);
    
    drawPixelText(item.name, 180, itemY + 20, 10, canAfford ? '#fff' : '#666');
    drawPixelText(`${item.cost} Gold`, 180, itemY + 40, 8, canAfford ? '#ffd700' : '#664400');
  });
  
  // Continue button
  drawPixelRect(80, 550, 200, 40, '#4a6a4a');
  drawPixelText('CONTINUE', 180, 570, 12, '#fff');
  
  drawPixelText(`HP: ${player.hp}/${player.maxHp}  ATK: ${player.attack}  DEF: ${player.defense}`, 180, 620, 8, '#aaa');
}

function drawVictory() {
  drawPixelRect(0, 0, 360, 640, '#1a1a3a');
  
  drawPixelText('VICTORY!', 180, 200, 24, '#ffd700');
  drawPixelText('You completed the', 180, 260, 12, '#fff');
  drawPixelText('One Button Odyssey!', 180, 280, 12, '#fff');
  
  drawPixelText(`Final Level: ${player.level}`, 180, 340, 10, '#aaa');
  drawPixelText(`Total Gold: ${player.gold}`, 180, 360, 10, '#aaa');
  
  // Trophy
  drawPixelRect(165, 400, 30, 40, '#ffd700');
  drawPixelRect(160, 390, 40, 15, '#ffd700');
  drawPixelRect(170, 440, 20, 10, '#8a6a4a');
  
  drawPixelText('TAP TO RESTART', 180, 550, 12, '#888');
}

// ============================================================
// INPUT
// ============================================================
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  ensureAudio();
  const touch = e.touches[0];
  processInput(touch.clientX, touch.clientY);
}, { passive: false });

canvas.addEventListener('mousedown', (e) => {
  ensureAudio();
  processInput(e.clientX, e.clientY);
});

// ============================================================
// GAME LOOP
// ============================================================
function gameLoop(currentTime) {
  deltaTime = Math.min(0.05, (currentTime - lastTime) / 1000);
  lastTime = currentTime;
  gameTime += deltaTime;
  
  update();
  draw();
  
  requestAnimationFrame(gameLoop);
}

// Start
lastTime = performance.now();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
