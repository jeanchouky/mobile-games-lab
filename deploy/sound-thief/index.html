<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Sound Thief</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #0a0e1a;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  font-family: -apple-system, 'Segoe UI', system-ui, sans-serif;
}
canvas {
  display: block;
  width: 100%; height: 100%;
}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
'use strict';

// ============================================================
// SOUND THIEF â€” Mobile Web Game
// Your microphone is your weapon
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// --- GLOBALS ---
let W, H, scale, centerX, centerY;
let gameTime = 0, deltaTime = 0, lastTime = 0;
let gameState = 'TITLE'; // TITLE, RECORDING, PLAYING, PAUSED, GAME_OVER
let currentLevel = 0;
let camera = { x: 0, y: 0, targetX: 0, targetY: 0 };
let particles = [];
let backgroundWaves = [];

// Audio
let audioCtx = null;
let micStream = null;
let micPermission = false;
let analyser = null;
let micDataArray = null;
let soundInventory = []; // max 5 recorded sounds
let recordingState = { active: false, timer: 0, maxDuration: 2.0, audioData: [], sampleRate: 0 };

// Player
let player = {
  x: 100, y: 300, vx: 0, vy: 0,
  w: 24, h: 24, radius: 12,
  onGround: false, hp: 100, maxHp: 100,
  jumpPower: -10, moveSpeed: 4, gravity: 0.5,
  facing: 1 // 1 = right, -1 = left
};

// Game progress
let resonance = 0; // currency
let enemies = [];
let platforms = [];
let projectiles = [];
let pickups = [];

// Input
let keys = {};
let inputEvents = [];
let touchControls = { left: false, right: false, jump: false, action: false };
let gs_levelClearing = false;
let gs_victory = false;

// Tutorial overlay
let tutorialStep = 0; // 0=off, 1-4=tutorial steps
let tutorialTimer = 0;
let showTutorial = true;

// Visual recording feedback
let recordingPulse = 0;

// ---- NEW FEATURE GLOBALS ----

// Sound Combination / Mixing system
let combineMode = false; // true when in the sound mixer overlay
let combineSlotA = -1;   // first slot selected for combining
let combineSlotB = -1;   // second slot selected for combining
let combineAnimation = 0; // animation progress 0..1
let combineResult = null; // result preview while animating
let combinedSoundsCreated = 0; // track how many combos the player has made

// Waveform / Spectrum HUD
let showSpectrumHUD = false; // toggle for the real-time spectrum overlay
let spectrumData = new Float32Array(128); // smoothed spectrum bars
let spectrumHistory = []; // rolling history for waterfall display
const SPECTRUM_HISTORY_LEN = 40;

// Boss battle state
let bossState = {
  active: false,
  phase: 0,           // boss phases 0,1,2
  phaseTimer: 0,
  attackTimer: 0,
  attackPattern: 0,
  shieldHP: 0,
  shieldMax: 0,
  requiredFreqLow: 0,
  requiredFreqHigh: 0,
  vulnerableTimer: 0,
  spawnTimer: 0,
  dialog: '',
  dialogTimer: 0,
  shockwaves: [],     // visual shockwave rings from boss
  beams: []           // boss beam attacks
};

// Enhanced tutorial system
let tutorialPhase = 'none'; // 'none','welcome','movement','recording','combat','weakness','combine','spectrum','boss','complete'
let tutorialSubStep = 0;
let tutorialHighlightArea = null; // {x,y,w,h} rect to highlight
let tutorialArrowTarget = null;  // {x,y} for animated arrow
let tutorialActionRequired = null; // action player must perform to advance
let tutorialActionDone = false;
let tutorialTextQueue = [];
let tutorialCharIndex = 0; // typewriter effect
let tutorialTypeTimer = 0;

// Hazards for advanced levels
let hazards = []; // {x,y,w,h,type:'spikes'|'laser'|'vortex', ...}

// Moving platforms
let movingPlatforms = []; // {x,y,w,h,startX,startY,endX,endY,speed,t}

// Collectible resonance pickups in levels
let resonancePickups = []; // {x,y,collected,value}

// Level transition banner
let levelBanner = { text: '', timer: 0, color: '#64b5f6' };

// Frequency-locked doors/gates
let freqGates = []; // {x,y,w,h,freqLow,freqHigh,open,openTimer}

// Environmental sound emitters (decorative + gameplay)
let soundEmitters = []; // {x,y,frequency,radius,phase,color}

// --- RESIZE ---
function resize() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  scale = Math.min(W / 400, H / 700);
  centerX = W / 2;
  centerY = H / 2;
}
window.addEventListener('resize', resize);
resize();

// ============================================================
// AUDIO ENGINE
// ============================================================

function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

// Request microphone access
async function requestMic() {
  if (micPermission) return true;
  try {
    initAudio();
    const stream = await navigator.mediaDevices.getUserMedia({ 
      audio: { 
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false 
      } 
    });
    micStream = stream;
    
    // Setup analyser for real-time visualization
    const source = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    source.connect(analyser);
    
    micDataArray = new Uint8Array(analyser.frequencyBinCount);
    micPermission = true;
    return true;
  } catch(e) {
    console.error('Mic permission denied:', e);
    micPermission = false;
    return false;
  }
}

// Start recording
function startRecording() {
  if (!micPermission) return;
  recordingState.active = true;
  recordingState.timer = 0;
  recordingState.audioData = [];
  recordingState.sampleRate = audioCtx.sampleRate;
  
  // Create a ScriptProcessorNode to capture audio data (deprecated but widely supported)
  const bufferSize = 4096;
  let recorder;
  try {
    recorder = audioCtx.createScriptProcessor(bufferSize, 1, 1);
  } catch(e) {
    // Fallback if ScriptProcessorNode removed in future
    recordingState.active = false;
    const proceduralSound = createProceduralSound();
    soundInventory.push(proceduralSound);
    playSfx('success');
    gameState = 'PLAYING';
    return;
  }
  const source = audioCtx.createMediaStreamSource(micStream);
  
  recorder.onaudioprocess = (e) => {
    if (!recordingState.active) return;
    const inputData = e.inputBuffer.getChannelData(0);
    recordingState.audioData.push(new Float32Array(inputData));
  };
  
  source.connect(recorder);
  recorder.connect(audioCtx.destination);
  recordingState.recorder = recorder;
  recordingState.source = source;
}

// Stop recording and analyze
function stopRecording() {
  if (!recordingState.active) return;
  recordingState.active = false;

  // Disconnect recorder safely (avoid double-disconnect)
  if (recordingState.recorder) {
    try { recordingState.source.disconnect(); } catch(e) {}
    try { recordingState.recorder.disconnect(); } catch(e) {}
    recordingState.recorder = null;
    recordingState.source = null;
  }
  
  // Merge audio chunks
  const totalLength = recordingState.audioData.reduce((acc, arr) => acc + arr.length, 0);
  const audioBuffer = new Float32Array(totalLength);
  let offset = 0;
  for (const chunk of recordingState.audioData) {
    audioBuffer.set(chunk, offset);
    offset += chunk.length;
  }
  
  // Analyze the sound
  const analysis = analyzeSound(audioBuffer, recordingState.sampleRate);
  
  // Add to inventory if there's space
  if (soundInventory.length < 5) {
    soundInventory.push({
      id: Date.now(),
      buffer: audioBuffer,
      sampleRate: recordingState.sampleRate,
      analysis: analysis,
      waveform: generateWaveform(audioBuffer, 100),
      cooldown: 0
    });
    playSfx('success');
  } else {
    playSfx('error');
  }
  
  gameState = 'PLAYING';
}

// Analyze sound characteristics
function analyzeSound(audioBuffer, sampleRate) {
  // Calculate volume (RMS)
  let sum = 0;
  for (let i = 0; i < audioBuffer.length; i++) {
    sum += audioBuffer[i] * audioBuffer[i];
  }
  const rms = Math.sqrt(sum / audioBuffer.length);
  const volumeDb = 20 * Math.log10(rms + 0.0001);
  const normalizedVolume = Math.max(0, Math.min(100, (volumeDb + 60) * 2));
  
  // FFT for frequency analysis
  const fftSize = 2048;
  const fft = new Float32Array(fftSize);
  for (let i = 0; i < Math.min(fftSize, audioBuffer.length); i++) {
    fft[i] = audioBuffer[i];
  }
  
  // Simple dominant frequency detection (find peak in frequency domain)
  const freqBins = fftSize / 2;
  const spectrum = new Float32Array(freqBins);
  for (let i = 0; i < freqBins; i++) {
    const re = fft[i * 2] || 0;
    const im = fft[i * 2 + 1] || 0;
    spectrum[i] = Math.sqrt(re * re + im * im);
  }
  
  let maxMag = 0;
  let maxBin = 0;
  for (let i = 1; i < freqBins; i++) {
    if (spectrum[i] > maxMag) {
      maxMag = spectrum[i];
      maxBin = i;
    }
  }
  
  const dominantFreq = maxBin * sampleRate / fftSize;
  
  // Classify sound type based on frequency and volume
  let type = 'impact';
  let color = '#ff6b6b';
  
  if (dominantFreq > 2000) {
    type = 'high';
    color = '#4ecdc4';
  } else if (dominantFreq > 800) {
    type = 'mid';
    color = '#ffe66d';
  } else if (normalizedVolume > 60) {
    type = 'loud';
    color = '#ff6b6b';
  } else {
    type = 'low';
    color = '#a8dadc';
  }
  
  // Check for musical/harmonic content
  const isHarmonic = checkHarmonic(spectrum);
  if (isHarmonic) {
    type = 'harmonic';
    color = '#c77dff';
  }
  
  return {
    volume: Math.round(normalizedVolume),
    frequency: Math.round(dominantFreq),
    duration: audioBuffer.length / sampleRate,
    type: type,
    color: color,
    power: Math.round(normalizedVolume * 0.8 + (dominantFreq / 3000) * 20)
  };
}

// Check if sound is harmonic/musical
function checkHarmonic(spectrum) {
  // Very simplified: check if there are clear peaks (not just noise)
  let peaks = 0;
  const threshold = Math.max(...spectrum) * 0.3;
  for (let i = 5; i < spectrum.length - 5; i++) {
    if (spectrum[i] > threshold && 
        spectrum[i] > spectrum[i-1] && 
        spectrum[i] > spectrum[i+1]) {
      peaks++;
    }
  }
  return peaks >= 3 && peaks <= 8; // Musical sounds have a few clear harmonics
}

// Generate waveform visualization data
function generateWaveform(audioBuffer, width) {
  const waveform = [];
  const step = Math.floor(audioBuffer.length / width);
  for (let i = 0; i < width; i++) {
    let sum = 0;
    let count = 0;
    for (let j = 0; j < step && i * step + j < audioBuffer.length; j++) {
      sum += Math.abs(audioBuffer[i * step + j]);
      count++;
    }
    waveform.push(count > 0 ? sum / count : 0);
  }
  return waveform;
}

// Play a recorded sound as weapon
function playSound(soundObj) {
  if (!audioCtx || soundObj.cooldown > 0) return;
  
  const buffer = audioCtx.createBuffer(1, soundObj.buffer.length, soundObj.sampleRate);
  buffer.getChannelData(0).set(soundObj.buffer);
  
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  
  const gain = audioCtx.createGain();
  gain.gain.value = 0.6;
  
  source.connect(gain);
  gain.connect(audioCtx.destination);
  source.start();
  
  // Create projectile
  createSoundProjectile(soundObj);
  
  // Set cooldown
  soundObj.cooldown = 1.0; // 1 second cooldown
  
  playSfx('shoot');
}

// Create projectile from sound
function createSoundProjectile(soundObj) {
  const analysis = soundObj.analysis;
  projectiles.push({
    x: player.x + player.w / 2,
    y: player.y + player.h / 2,
    vx: player.facing * 8,
    vy: 0,
    w: 16,
    h: 16,
    damage: analysis.power,
    type: analysis.type,
    color: analysis.color,
    lifetime: 3.0,
    waveform: soundObj.waveform
  });
}

// Procedural SFX (fallback mode or UI sounds)
function playSfx(type) {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  
  switch(type) {
    case 'jump':
      osc.frequency.setValueAtTime(400, now);
      osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
      osc.type = 'square';
      break;
    case 'shoot':
      osc.frequency.setValueAtTime(800, now);
      osc.frequency.exponentialRampToValueAtTime(200, now + 0.15);
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      osc.type = 'sawtooth';
      break;
    case 'hit':
      osc.frequency.setValueAtTime(100, now);
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
      osc.type = 'square';
      break;
    case 'success':
      osc.frequency.setValueAtTime(523, now);
      osc.frequency.setValueAtTime(659, now + 0.1);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      osc.type = 'sine';
      break;
    case 'error':
      osc.frequency.setValueAtTime(200, now);
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
      osc.type = 'sawtooth';
      break;
    default:
      osc.frequency.value = 440;
      gain.gain.value = 0.1;
  }
  
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(now);
  osc.stop(now + 0.3);
}

// ============================================================
// SOUND COMBINATION / MIXING SYSTEM
// ============================================================

function openCombineMode() {
  if (soundInventory.length < 2) {
    levelBanner = { text: 'Need at least 2 sounds to combine!', timer: 2, color: '#ff6b6b' };
    return;
  }
  combineMode = true;
  combineSlotA = -1;
  combineSlotB = -1;
  combineAnimation = 0;
  combineResult = null;
  playSfx('success');
}

function closeCombineMode() {
  combineMode = false;
  combineSlotA = -1;
  combineSlotB = -1;
  combineAnimation = 0;
  combineResult = null;
}

function selectCombineSlot(index) {
  if (index < 0 || index >= soundInventory.length) return;
  if (combineSlotA === -1) {
    combineSlotA = index;
    playSfx('jump');
  } else if (combineSlotB === -1 && index !== combineSlotA) {
    combineSlotB = index;
    playSfx('jump');
    combineAnimation = 0;
    combineResult = combineSounds(soundInventory[combineSlotA], soundInventory[combineSlotB]);
  }
}

function combineSounds(soundA, soundB) {
  const aVol = soundA.analysis.volume;
  const bVol = soundB.analysis.volume;
  const aPow = soundA.analysis.power;
  const bPow = soundB.analysis.power;

  const typeCombo = soundA.analysis.type + '+' + soundB.analysis.type;
  let newType, newColor, bonusPower;

  const comboMap = {
    'loud+high': { type: 'shockwave', color: '#ff4081', bonus: 30 },
    'high+loud': { type: 'shockwave', color: '#ff4081', bonus: 30 },
    'mid+harmonic': { type: 'resonance', color: '#e040fb', bonus: 25 },
    'harmonic+mid': { type: 'resonance', color: '#e040fb', bonus: 25 },
    'loud+low': { type: 'earthquake', color: '#ff7043', bonus: 35 },
    'low+loud': { type: 'earthquake', color: '#ff7043', bonus: 35 },
    'high+harmonic': { type: 'crystal', color: '#00e5ff', bonus: 28 },
    'harmonic+high': { type: 'crystal', color: '#00e5ff', bonus: 28 },
    'loud+harmonic': { type: 'thunder', color: '#ffab00', bonus: 32 },
    'harmonic+loud': { type: 'thunder', color: '#ffab00', bonus: 32 },
    'mid+low': { type: 'pulse', color: '#76ff03', bonus: 20 },
    'low+mid': { type: 'pulse', color: '#76ff03', bonus: 20 },
    'loud+mid': { type: 'blast', color: '#ff9100', bonus: 22 },
    'mid+loud': { type: 'blast', color: '#ff9100', bonus: 22 },
    'high+low': { type: 'dissonance', color: '#d500f9', bonus: 26 },
    'low+high': { type: 'dissonance', color: '#d500f9', bonus: 26 },
    'loud+loud': { type: 'megabass', color: '#ff1744', bonus: 40 },
    'high+high': { type: 'ultrasonic', color: '#18ffff', bonus: 35 },
    'harmonic+harmonic': { type: 'symphony', color: '#ea80fc', bonus: 45 },
    'mid+mid': { type: 'drone', color: '#ffd740', bonus: 20 },
    'low+low': { type: 'subsonic', color: '#69f0ae', bonus: 30 },
  };

  const combo = comboMap[typeCombo];
  if (combo) {
    newType = combo.type;
    newColor = combo.color;
    bonusPower = combo.bonus;
  } else {
    newType = 'hybrid';
    newColor = '#b388ff';
    bonusPower = 15;
  }

  const newFreq = Math.round((soundA.analysis.frequency + soundB.analysis.frequency) / 2 + Math.random() * 200 - 100);
  const newVol = Math.min(100, Math.round((aVol + bVol) / 2 + 10));
  const newPower = Math.round((aPow + bPow) / 2 + bonusPower);

  const newWaveform = [];
  const wfA = soundA.waveform;
  const wfB = soundB.waveform;
  for (let i = 0; i < 100; i++) {
    const a = wfA[i % wfA.length] || 0.5;
    const b = wfB[i % wfB.length] || 0.5;
    newWaveform.push(a * 0.5 + b * 0.5 + Math.sin(i * 0.3) * 0.1);
  }

  const lenA = soundA.buffer.length;
  const lenB = soundB.buffer.length;
  const maxLen = Math.max(lenA, lenB);
  const newBuffer = new Float32Array(maxLen);
  for (let i = 0; i < maxLen; i++) {
    const sa = i < lenA ? soundA.buffer[i] : 0;
    const sb = i < lenB ? soundB.buffer[i] : 0;
    newBuffer[i] = (sa + sb) * 0.5;
  }

  return {
    id: Date.now() + Math.random(),
    buffer: newBuffer,
    sampleRate: soundA.sampleRate,
    analysis: {
      volume: newVol,
      frequency: newFreq,
      duration: Math.max(soundA.analysis.duration, soundB.analysis.duration),
      type: newType,
      color: newColor,
      power: newPower
    },
    waveform: newWaveform,
    cooldown: 0,
    isCombined: true,
    comboName: newType.charAt(0).toUpperCase() + newType.slice(1)
  };
}

function finalizeCombine() {
  if (combineResult && combineSlotA >= 0 && combineSlotB >= 0) {
    const hi = Math.max(combineSlotA, combineSlotB);
    const lo = Math.min(combineSlotA, combineSlotB);
    soundInventory.splice(hi, 1);
    soundInventory.splice(lo, 1);
    if (soundInventory.length < 5) {
      soundInventory.push(combineResult);
      combinedSoundsCreated++;
      levelBanner = { text: 'Created: ' + combineResult.comboName + ' Sound!', timer: 2.5, color: combineResult.analysis.color };
      playSfx('success');
    }
    closeCombineMode();
  }
}

function updateCombineAnimation() {
  if (!combineMode || combineSlotA < 0 || combineSlotB < 0) return;
  combineAnimation += deltaTime * 0.8;
  if (combineAnimation >= 1.0) combineAnimation = 1.0;
}

function drawCombineMode() {
  if (!combineMode) return;
  ctx.save();
  ctx.fillStyle = 'rgba(10, 14, 26, 0.95)';
  ctx.fillRect(0, 0, W, H);
  ctx.textAlign = 'center';

  ctx.font = 'bold 26px sans-serif';
  ctx.fillStyle = '#e040fb';
  ctx.fillText('SOUND MIXER', centerX, 60);
  ctx.font = '13px sans-serif';
  ctx.fillStyle = '#aaa';
  ctx.fillText('Select two sounds to combine', centerX, 85);

  const slotSize = Math.min(80, (W - 60) / Math.max(soundInventory.length, 1));
  const startX = centerX - (soundInventory.length * (slotSize + 10)) / 2;
  const slotY = 120;

  for (let i = 0; i < soundInventory.length; i++) {
    const sx = startX + i * (slotSize + 10);
    const s = soundInventory[i];
    const selected = (i === combineSlotA || i === combineSlotB);

    ctx.strokeStyle = selected ? '#fff' : s.analysis.color;
    ctx.lineWidth = selected ? 3 : 2;
    ctx.fillStyle = selected ? s.analysis.color + '40' : '#1a2040';
    ctx.fillRect(sx, slotY, slotSize, slotSize);
    ctx.strokeRect(sx, slotY, slotSize, slotSize);

    ctx.strokeStyle = s.analysis.color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    for (let j = 0; j < s.waveform.length; j++) {
      const wx = sx + 4 + (j / s.waveform.length) * (slotSize - 8);
      const wy = slotY + slotSize / 2 + (s.waveform[j] - 0.5) * (slotSize * 0.5);
      if (j === 0) ctx.moveTo(wx, wy); else ctx.lineTo(wx, wy);
    }
    ctx.stroke();

    ctx.font = '10px sans-serif';
    ctx.fillStyle = '#ccc';
    ctx.fillText(s.analysis.type, sx + slotSize / 2, slotY + slotSize + 14);
    ctx.fillStyle = s.analysis.color;
    ctx.fillText('P:' + s.analysis.power, sx + slotSize / 2, slotY + slotSize + 26);

    if (selected) {
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 10px sans-serif';
      ctx.fillText(i === combineSlotA ? 'A' : 'B', sx + slotSize / 2, slotY - 6);
    }
  }

  if (combineSlotA >= 0 && combineSlotB >= 0 && combineResult) {
    const mixY = slotY + slotSize + 60;
    const progress = combineAnimation;
    const mergeX = centerX;
    const mergeY = mixY + 60;

    for (let ring = 0; ring < 4; ring++) {
      const r = 30 + ring * 15;
      const alpha = (1 - ring / 4) * progress;
      ctx.strokeStyle = combineResult.analysis.color;
      ctx.lineWidth = 2;
      ctx.globalAlpha = alpha * 0.6;
      ctx.beginPath();
      ctx.arc(mergeX, mergeY, r * (1 - progress * 0.3), 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    ctx.strokeStyle = combineResult.analysis.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let a = 0; a < Math.PI * 2; a += 0.05) {
      const wIdx = Math.floor((a / (Math.PI * 2)) * combineResult.waveform.length);
      const wVal = combineResult.waveform[wIdx] || 0.5;
      const ringR = 20 + wVal * 25;
      const rx = mergeX + Math.cos(a + gameTime * 3) * ringR * progress;
      const ry = mergeY + Math.sin(a + gameTime * 3) * ringR * progress;
      if (a === 0) ctx.moveTo(rx, ry); else ctx.lineTo(rx, ry);
    }
    ctx.closePath();
    ctx.stroke();

    if (progress >= 0.5) {
      const infoAlpha = (progress - 0.5) * 2;
      ctx.globalAlpha = infoAlpha;
      ctx.font = 'bold 18px sans-serif';
      ctx.fillStyle = combineResult.analysis.color;
      ctx.fillText(combineResult.comboName, mergeX, mergeY + 70);
      ctx.font = '12px sans-serif';
      ctx.fillStyle = '#ccc';
      ctx.fillText('Power: ' + combineResult.analysis.power + '  |  Freq: ' + combineResult.analysis.frequency + 'Hz', mergeX, mergeY + 90);
      ctx.fillText('Vol: ' + combineResult.analysis.volume + 'dB', mergeX, mergeY + 106);
      ctx.globalAlpha = 1;
    }

    if (progress >= 1.0) {
      const btnY2 = mergeY + 125;
      ctx.fillStyle = '#4caf50';
      ctx.fillRect(centerX - 80, btnY2, 160, 45);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(centerX - 80, btnY2, 160, 45);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px sans-serif';
      ctx.fillText('COMBINE!', centerX, btnY2 + 28);
    }
  }

  ctx.fillStyle = '#666';
  ctx.fillRect(centerX - 60, H - 80, 120, 40);
  ctx.strokeStyle = '#999';
  ctx.lineWidth = 2;
  ctx.strokeRect(centerX - 60, H - 80, 120, 40);
  ctx.fillStyle = '#fff';
  ctx.font = '14px sans-serif';
  ctx.fillText('CANCEL', centerX, H - 54);

  ctx.textAlign = 'left';
  ctx.restore();
}

// ============================================================
// REAL-TIME WAVEFORM & SPECTRUM DISPLAY
// ============================================================

function updateSpectrumHUD() {
  if (!analyser || !micPermission) return;
  const freqData = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(freqData);

  const binsPerBar = Math.floor(freqData.length / 128);
  for (let i = 0; i < 128; i++) {
    let sum = 0;
    for (let j = 0; j < binsPerBar; j++) {
      sum += freqData[i * binsPerBar + j];
    }
    const val = sum / binsPerBar / 255;
    spectrumData[i] += (val - spectrumData[i]) * 0.3;
  }

  spectrumHistory.push(new Float32Array(spectrumData));
  if (spectrumHistory.length > SPECTRUM_HISTORY_LEN) spectrumHistory.shift();
}

function drawSpectrumHUD() {
  if (!showSpectrumHUD) return;
  const hudX = 10;
  const hudY = 65;
  const hudW = Math.min(W - 20, 300);
  const hudH = 90;

  ctx.save();
  ctx.fillStyle = 'rgba(10, 14, 26, 0.85)';
  ctx.fillRect(hudX, hudY, hudW, hudH);
  ctx.strokeStyle = '#335';
  ctx.lineWidth = 1;
  ctx.strokeRect(hudX, hudY, hudW, hudH);

  ctx.font = '9px sans-serif';
  ctx.fillStyle = '#64b5f6';
  ctx.fillText('FREQ SPECTRUM', hudX + 4, hudY + 10);

  const barCount = Math.min(64, Math.floor(hudW / 4));
  const barW = (hudW - 8) / barCount;
  const barMaxH = hudH - 20;

  for (let i = 0; i < barCount; i++) {
    const val = spectrumData[i * 2] || 0;
    const barH = val * barMaxH;
    let color;
    if (i < barCount * 0.25) color = '#ff6b6b';
    else if (i < barCount * 0.5) color = '#ffe66d';
    else if (i < barCount * 0.75) color = '#4ecdc4';
    else color = '#c77dff';
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.4 + val * 0.6;
    ctx.fillRect(hudX + 4 + i * barW, hudY + hudH - 4 - barH, barW - 1, barH);
  }
  ctx.globalAlpha = 1;

  if (analyser && micDataArray) {
    analyser.getByteTimeDomainData(micDataArray);
    ctx.strokeStyle = '#64b5f6';
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    const step = Math.floor(micDataArray.length / hudW);
    for (let i = 0; i < hudW; i++) {
      const v = micDataArray[i * step] / 128.0;
      const y = hudY + 15 + (v - 1) * (barMaxH * 0.3) + barMaxH * 0.5;
      if (i === 0) ctx.moveTo(hudX + i, y); else ctx.lineTo(hudX + i, y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // Waterfall display
  const wfY = hudY + hudH + 2;
  const wfH = 30;
  ctx.fillStyle = 'rgba(10, 14, 26, 0.85)';
  ctx.fillRect(hudX, wfY, hudW, wfH);
  ctx.strokeStyle = '#335';
  ctx.strokeRect(hudX, wfY, hudW, wfH);

  const rowH = wfH / SPECTRUM_HISTORY_LEN;
  for (let r = 0; r < spectrumHistory.length; r++) {
    const row = spectrumHistory[r];
    for (let i = 0; i < barCount; i++) {
      const val = row[i * 2] || 0;
      if (val < 0.05) continue;
      const hue = 200 + i * 2;
      ctx.fillStyle = `hsla(${hue}, 80%, 60%, ${val})`;
      ctx.fillRect(hudX + 4 + i * barW, wfY + r * rowH, barW - 1, rowH);
    }
  }
  ctx.restore();
}

function drawSoundDetailPanel(soundObj, panelX, panelY) {
  if (!soundObj) return;
  const pw = 180;
  const ph = 130;
  ctx.save();
  ctx.fillStyle = 'rgba(10, 14, 26, 0.95)';
  ctx.fillRect(panelX, panelY, pw, ph);
  ctx.strokeStyle = soundObj.analysis.color;
  ctx.lineWidth = 2;
  ctx.strokeRect(panelX, panelY, pw, ph);

  ctx.font = 'bold 11px sans-serif';
  ctx.fillStyle = soundObj.analysis.color;
  const label = soundObj.isCombined ? soundObj.comboName : soundObj.analysis.type.toUpperCase();
  ctx.fillText(label, panelX + 6, panelY + 14);

  ctx.strokeStyle = soundObj.analysis.color;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  const ww = pw - 12;
  const wh = 40;
  for (let j = 0; j < soundObj.waveform.length; j++) {
    const x = panelX + 6 + (j / soundObj.waveform.length) * ww;
    const y = panelY + 25 + wh / 2 + (soundObj.waveform[j] - 0.5) * wh;
    if (j === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  ctx.stroke();

  const numBars = 16;
  const nbw = ww / numBars;
  const barMH = 30;
  for (let i = 0; i < numBars; i++) {
    const seg = Math.floor(soundObj.waveform.length / numBars);
    let sum = 0;
    for (let j = 0; j < seg; j++) sum += Math.abs(soundObj.waveform[i * seg + j] - 0.5);
    const val = Math.min(1, sum / seg * 4);
    const barH = val * barMH;
    const hue = 200 + i * 10;
    ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.7)`;
    ctx.fillRect(panelX + 6 + i * nbw, panelY + 75 + barMH - barH, nbw - 1, barH);
  }

  ctx.font = '10px sans-serif';
  ctx.fillStyle = '#bbb';
  ctx.fillText('Vol:' + soundObj.analysis.volume + 'dB Freq:' + soundObj.analysis.frequency + 'Hz', panelX + 6, panelY + 118);
  ctx.fillText('Power:' + soundObj.analysis.power + ' Type:' + soundObj.analysis.type, panelX + 6, panelY + 128);
  ctx.restore();
}

// ============================================================
// BOSS BATTLE SYSTEM
// ============================================================

function initBoss(bossEnemy) {
  bossState.active = true;
  bossState.phase = 0;
  bossState.phaseTimer = 0;
  bossState.attackTimer = 0;
  bossState.attackPattern = 0;
  bossState.shieldHP = 0;
  bossState.shieldMax = 0;
  bossState.vulnerableTimer = 0;
  bossState.spawnTimer = 0;
  bossState.dialog = '';
  bossState.dialogTimer = 0;
  bossState.shockwaves = [];
  bossState.beams = [];

  if (bossEnemy.bossType === 'frequency_lord') {
    bossState.shieldHP = 80;
    bossState.shieldMax = 80;
    bossState.dialog = 'Only mid-range sounds can break my shield!';
    bossState.dialogTimer = 3;
  } else if (bossEnemy.bossType === 'bass_titan') {
    bossState.shieldHP = 100;
    bossState.shieldMax = 100;
    bossState.dialog = 'Bass is my weakness... if you can make it loud enough!';
    bossState.dialogTimer = 3;
  } else if (bossEnemy.bossType === 'harmony_queen') {
    bossState.shieldHP = 60;
    bossState.shieldMax = 60;
    bossState.dialog = 'Only combined sounds can harm me!';
    bossState.dialogTimer = 3;
  } else if (bossEnemy.bossType === 'noise_emperor') {
    bossState.shieldHP = 120;
    bossState.shieldMax = 120;
    bossState.dialog = 'High frequency will shatter my armor!';
    bossState.dialogTimer = 3;
  } else if (bossEnemy.bossType === 'silence_king') {
    bossState.shieldHP = 150;
    bossState.shieldMax = 150;
    bossState.dialog = 'I am silence itself! No single sound can defeat me!';
    bossState.dialogTimer = 3;
  } else {
    bossState.shieldHP = 60;
    bossState.shieldMax = 60;
    bossState.dialog = 'Harmonic sounds are my bane!';
    bossState.dialogTimer = 3;
  }
}

function updateBoss() {
  if (!bossState.active) return;
  const boss = enemies.find(e => e.isBoss);
  if (!boss) { bossState.active = false; return; }

  bossState.phaseTimer += deltaTime;
  bossState.attackTimer += deltaTime;
  bossState.spawnTimer += deltaTime;
  if (bossState.dialogTimer > 0) bossState.dialogTimer -= deltaTime;

  const dx = player.x - boss.x;
  const dist = Math.abs(dx);

  if (boss.bossType === 'silence_king') {
    if (bossState.attackTimer > 3) {
      boss.x = player.x + (Math.random() > 0.5 ? 150 : -150);
      bossState.attackTimer = 0;
      spawnParticles(boss.x + boss.w/2, boss.y + boss.h/2, 15, '#ffffff');
    }
  } else {
    if (dist > 60) boss.vx = dx > 0 ? 2 : -2;
    else boss.vx = 0;
    boss.x += boss.vx * deltaTime * 60;
  }

  // Boss attacks
  if (bossState.attackTimer > 2.5) {
    bossState.attackTimer = 0;
    bossState.attackPattern = (bossState.attackPattern + 1) % 3;

    if (bossState.attackPattern === 0) {
      bossState.shockwaves.push({
        x: boss.x + boss.w/2, y: boss.y + boss.h/2,
        radius: 0, maxRadius: 200, speed: 150, damage: 8
      });
      playSfx('hit');
    } else if (bossState.attackPattern === 1) {
      bossState.beams.push({
        x: boss.x + boss.w/2, y: boss.y + boss.h/2,
        angle: Math.atan2(player.y - boss.y, player.x - boss.x),
        length: 0, maxLength: 400, width: 8, timer: 1.0,
        damage: 12, color: boss.color
      });
      playSfx('shoot');
    } else if (bossState.attackPattern === 2) {
      if (bossState.spawnTimer > 8 && enemies.length < 6) {
        bossState.spawnTimer = 0;
        const minionTypes = ['silence', 'echo', 'noise'];
        createEnemy(boss.x + (Math.random() > 0.5 ? 80 : -80), boss.y,
          minionTypes[Math.floor(Math.random() * minionTypes.length)]);
        levelBanner = { text: 'Boss spawns minion!', timer: 1.5, color: '#ff6b6b' };
      }
    }
  }

  // Update shockwaves
  for (let i = bossState.shockwaves.length - 1; i >= 0; i--) {
    const sw = bossState.shockwaves[i];
    sw.radius += sw.speed * deltaTime;
    if (sw.radius >= sw.maxRadius) { bossState.shockwaves.splice(i, 1); continue; }
    const playerDist = Math.hypot(player.x + player.w/2 - sw.x, player.y + player.h/2 - sw.y);
    if (Math.abs(playerDist - sw.radius) < 15 && (!player.invincible || player.invincible <= 0)) {
      player.hp -= sw.damage;
      player.invincible = 0.8;
      player.vy = -5;
      player.vx = (player.x - sw.x) > 0 ? 4 : -4;
      spawnParticles(player.x, player.y, 6, '#ff6b6b');
      playSfx('hit');
    }
  }

  // Update beams
  for (let i = bossState.beams.length - 1; i >= 0; i--) {
    const beam = bossState.beams[i];
    beam.length = Math.min(beam.maxLength, beam.length + 600 * deltaTime);
    beam.timer -= deltaTime;
    if (beam.timer <= 0) { bossState.beams.splice(i, 1); continue; }
    const beamEndX = beam.x + Math.cos(beam.angle) * beam.length;
    const beamEndY = beam.y + Math.sin(beam.angle) * beam.length;
    const px2 = player.x + player.w/2, py2 = player.y + player.h/2;
    const lineDistSq = pointToSegDistSq(px2, py2, beam.x, beam.y, beamEndX, beamEndY);
    if (lineDistSq < (beam.width + player.radius) * (beam.width + player.radius) &&
        (!player.invincible || player.invincible <= 0)) {
      player.hp -= beam.damage;
      player.invincible = 1.0;
      spawnParticles(player.x, player.y, 8, beam.color);
      playSfx('hit');
    }
  }

  // Phase transitions
  if (boss.hp < boss.maxHp * 0.66 && bossState.phase === 0) {
    bossState.phase = 1;
    bossState.dialog = 'Phase 2! My power grows!';
    bossState.dialogTimer = 2;
    spawnParticles(boss.x, boss.y, 30, boss.color);
    bossState.shieldHP = Math.floor(bossState.shieldMax * 0.5);
  }
  if (boss.hp < boss.maxHp * 0.33 && bossState.phase === 1) {
    bossState.phase = 2;
    bossState.dialog = 'FINAL PHASE! Feel my wrath!';
    bossState.dialogTimer = 2;
    spawnParticles(boss.x, boss.y, 40, '#ff0000');
    bossState.shieldHP = Math.floor(bossState.shieldMax * 0.3);
  }

  // Shield + projectile interaction
  for (let j = projectiles.length - 1; j >= 0; j--) {
    const proj = projectiles[j];
    if (!checkCollision(proj, boss)) continue;

    let dmg = proj.damage;
    if (bossState.shieldHP > 0) {
      const isCorrectType = proj.type === boss.weakness;
      const isCombined = proj.isCombined;
      if (boss.bossType === 'harmony_queen' && isCombined) {
        bossState.shieldHP -= 30;
        dmg *= 2;
        spawnParticles(boss.x, boss.y, 12, '#e040fb');
        levelBanner = { text: 'Combined sound shatters the shield!', timer: 1.5, color: '#e040fb' };
      } else if (boss.bossType === 'silence_king') {
        bossState.shieldHP -= isCombined ? 25 : 8;
        dmg = isCombined ? dmg * 2 : Math.floor(dmg * 0.5);
      } else if (isCorrectType) {
        bossState.shieldHP -= 20;
        dmg *= 1.5;
        spawnParticles(boss.x, boss.y, 8, '#ffd700');
      } else {
        bossState.shieldHP -= 5;
        dmg = Math.floor(dmg * 0.2);
      }
      if (bossState.shieldHP <= 0) {
        bossState.shieldHP = 0;
        bossState.vulnerableTimer = 5;
        levelBanner = { text: 'SHIELD BROKEN! Attack now!', timer: 2, color: '#ffd700' };
        spawnParticles(boss.x, boss.y, 30, '#ffd700');
        playSfx('success');
      }
    } else {
      if (proj.type === boss.weakness) {
        dmg *= 2;
        spawnParticles(boss.x, boss.y, 10, '#ffd700');
      }
    }

    boss.hp -= Math.round(dmg);
    spawnParticles(boss.x, boss.y, 5, proj.color);
    playSfx('hit');
    projectiles.splice(j, 1);

    if (boss.hp <= 0) {
      spawnParticles(boss.x, boss.y, 50, boss.color);
      resonance += 50;
      bossState.active = false;
      const idx = enemies.indexOf(boss);
      if (idx >= 0) enemies.splice(idx, 1);
      levelBanner = { text: 'BOSS DEFEATED!', timer: 3, color: '#4caf50' };
      playSfx('success');
    }
    break;
  }

  // Regenerate shield after vulnerability
  if (bossState.shieldHP <= 0 && bossState.vulnerableTimer > 0) {
    bossState.vulnerableTimer -= deltaTime;
    if (bossState.vulnerableTimer <= 0) {
      bossState.shieldHP = Math.floor(bossState.shieldMax * (0.3 + bossState.phase * 0.1));
      bossState.dialog = 'Shield restored!';
      bossState.dialogTimer = 1.5;
    }
  }
}

function drawBossOverlay() {
  if (!bossState.active) return;
  const boss = enemies.find(e => e.isBoss);
  if (!boss) return;
  const bx = boss.x - camera.x + boss.w/2;
  const by = boss.y - camera.y + boss.h/2;

  ctx.save();

  // Shield visual
  if (bossState.shieldHP > 0) {
    const shieldPct = bossState.shieldHP / bossState.shieldMax;
    ctx.strokeStyle = `rgba(255, 215, 0, ${0.3 + shieldPct * 0.5})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(bx, by, boss.w/2 + 15, 0, Math.PI * 2 * shieldPct);
    ctx.stroke();
    for (let a = 0; a < Math.PI * 2 * shieldPct; a += Math.PI / 3) {
      ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
      ctx.beginPath();
      ctx.arc(bx + Math.cos(a + gameTime) * (boss.w/2 + 15), by + Math.sin(a + gameTime) * (boss.w/2 + 15), 5, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Boss HP bar
  const barW2 = Math.min(W - 40, 300);
  const barH2 = 12;
  const barX2 = centerX - barW2/2;
  const barY2 = 38;
  const hpPct2 = boss.hp / boss.maxHp;
  ctx.fillStyle = '#222';
  ctx.fillRect(barX2, barY2, barW2, barH2);
  const hpGrad = ctx.createLinearGradient(barX2, barY2, barX2 + barW2 * hpPct2, barY2);
  hpGrad.addColorStop(0, boss.color);
  hpGrad.addColorStop(1, '#ff6b6b');
  ctx.fillStyle = hpGrad;
  ctx.fillRect(barX2, barY2, barW2 * hpPct2, barH2);
  ctx.strokeStyle = boss.color;
  ctx.lineWidth = 2;
  ctx.strokeRect(barX2, barY2, barW2, barH2);

  ctx.font = 'bold 10px sans-serif';
  ctx.fillStyle = boss.color;
  ctx.textAlign = 'center';
  const bossNames = { 'boss': 'Harmonic Guardian', 'frequency_lord': 'Frequency Lord', 'bass_titan': 'Bass Titan', 'harmony_queen': 'Harmony Queen', 'noise_emperor': 'Noise Emperor', 'silence_king': 'Silence King' };
  ctx.fillText(bossNames[boss.bossType] || 'BOSS', centerX, barY2 - 3);

  if (bossState.shieldMax > 0) {
    const sBarY = barY2 + barH2 + 3;
    const sPct = bossState.shieldHP / bossState.shieldMax;
    ctx.fillStyle = '#222';
    ctx.fillRect(barX2, sBarY, barW2, 5);
    ctx.fillStyle = '#ffd700';
    ctx.fillRect(barX2, sBarY, barW2 * sPct, 5);
    ctx.font = '8px sans-serif';
    ctx.fillStyle = '#ffd700';
    ctx.fillText('SHIELD', centerX, sBarY + 13);
  }
  ctx.textAlign = 'left';

  // Shockwaves
  for (const sw of bossState.shockwaves) {
    const swx = sw.x - camera.x, swy = sw.y - camera.y;
    const alpha = 1 - sw.radius / sw.maxRadius;
    ctx.strokeStyle = `rgba(255, 100, 100, ${alpha * 0.6})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(swx, swy, sw.radius, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Beams
  for (const beam of bossState.beams) {
    const beamX = beam.x - camera.x, beamY = beam.y - camera.y;
    const endX = beamX + Math.cos(beam.angle) * beam.length;
    const endY = beamY + Math.sin(beam.angle) * beam.length;
    ctx.strokeStyle = beam.color;
    ctx.lineWidth = beam.width;
    ctx.globalAlpha = beam.timer;
    ctx.beginPath();
    ctx.moveTo(beamX, beamY);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    ctx.lineWidth = beam.width * 2;
    ctx.globalAlpha = beam.timer * 0.2;
    ctx.beginPath();
    ctx.moveTo(beamX, beamY);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // Dialog
  if (bossState.dialogTimer > 0) {
    ctx.font = 'bold 12px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.globalAlpha = Math.min(1, bossState.dialogTimer);
    ctx.fillText(bossState.dialog, bx, by - boss.h/2 - 30);
    ctx.globalAlpha = 1;
    ctx.textAlign = 'left';
  }

  // Phase dots
  for (let p = 0; p < 3; p++) {
    ctx.fillStyle = p <= bossState.phase ? '#ff6b6b' : '#444';
    ctx.beginPath();
    ctx.arc(centerX - 15 + p * 15, barY2 + barH2 + 22, 4, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

function pointToSegDistSq(px, py, ax, ay, bx, by) {
  const ddx = bx - ax, ddy = by - ay;
  const lenSq = ddx * ddx + ddy * ddy;
  if (lenSq === 0) return (px - ax) * (px - ax) + (py - ay) * (py - ay);
  let t = ((px - ax) * ddx + (py - ay) * ddy) / lenSq;
  t = Math.max(0, Math.min(1, t));
  const projX = ax + t * ddx, projY = ay + t * ddy;
  return (px - projX) * (px - projX) + (py - projY) * (py - projY);
}

// ============================================================
// HAZARDS, MOVING PLATFORMS, PICKUPS, FREQ GATES
// ============================================================

function updateHazards() {
  for (const h of hazards) {
    if (h.type === 'laser') {
      h.phase = (h.phase || 0) + deltaTime;
      h.active = Math.sin(h.phase * h.speed) > 0;
    }
    if (h.type === 'vortex') {
      h.phase = (h.phase || 0) + deltaTime;
      const dvx = h.x + h.w/2 - player.x, dvy = h.y + h.h/2 - player.y;
      const vdist = Math.hypot(dvx, dvy);
      if (vdist < h.radius && vdist > 5) {
        player.vx += (dvx / vdist) * 0.5;
        player.vy += (dvy / vdist) * 0.3;
      }
    }
    if (h.type === 'spikes' && checkCollision(player, h) && (!player.invincible || player.invincible <= 0)) {
      player.hp -= 15;
      player.invincible = 1.0;
      player.vy = -8;
      spawnParticles(player.x, player.y, 10, '#ff6b6b');
      playSfx('hit');
    }
    if (h.type === 'laser' && h.active && checkCollision(player, h) && (!player.invincible || player.invincible <= 0)) {
      player.hp -= 8;
      player.invincible = 0.5;
      spawnParticles(player.x, player.y, 5, '#ff0000');
      playSfx('hit');
    }
  }
}

function drawHazards() {
  for (const h of hazards) {
    const hx = h.x - camera.x, hy = h.y - camera.y;
    ctx.save();
    if (h.type === 'spikes') {
      ctx.fillStyle = '#ff4444';
      const spikeCount = Math.floor(h.w / 12);
      for (let s = 0; s < spikeCount; s++) {
        const sx = hx + s * 12;
        ctx.beginPath();
        ctx.moveTo(sx, hy + h.h);
        ctx.lineTo(sx + 6, hy);
        ctx.lineTo(sx + 12, hy + h.h);
        ctx.closePath();
        ctx.fill();
      }
    } else if (h.type === 'laser') {
      if (h.active) {
        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
        ctx.fillRect(hx, hy, h.w, h.h);
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 1;
        ctx.strokeRect(hx, hy, h.w, h.h);
        ctx.globalAlpha = 0.2;
        ctx.fillRect(hx - 2, hy - 2, h.w + 4, h.h + 4);
      } else {
        ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';
        ctx.fillRect(hx, hy, h.w, h.h);
      }
    } else if (h.type === 'vortex') {
      const vcx = hx + h.w/2, vcy = hy + h.h/2;
      for (let ring = 0; ring < 4; ring++) {
        const r = 10 + ring * 8 + Math.sin(gameTime * 3 + ring) * 3;
        ctx.strokeStyle = `rgba(148, 0, 255, ${0.5 - ring * 0.1})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(vcx, vcy, r, gameTime * 2 + ring, gameTime * 2 + ring + Math.PI * 1.5);
        ctx.stroke();
      }
    }
    ctx.restore();
  }
}

function updateMovingPlatforms() {
  for (const mp of movingPlatforms) {
    mp.t += mp.speed * deltaTime;
    if (mp.t > 1) mp.t -= 2;
    const t = Math.abs(mp.t);
    mp.x = mp.startX + (mp.endX - mp.startX) * t;
    mp.y = mp.startY + (mp.endY - mp.startY) * t;
  }
}

function updateResonancePickups() {
  for (const p of resonancePickups) {
    if (p.collected) continue;
    if (checkCollision(player, { x: p.x - 10, y: p.y - 10, w: 20, h: 20 })) {
      p.collected = true;
      resonance += p.value;
      spawnParticles(p.x, p.y, 8, '#ffd700');
      playSfx('success');
    }
  }
}

function drawResonancePickups() {
  for (const p of resonancePickups) {
    if (p.collected) continue;
    const rpx = p.x - camera.x, rpy = p.y - camera.y;
    const bob = Math.sin(gameTime * 3 + p.x) * 4;
    ctx.save();
    ctx.fillStyle = '#ffd700';
    ctx.globalAlpha = 0.6 + Math.sin(gameTime * 4) * 0.3;
    ctx.beginPath();
    ctx.arc(rpx, rpy + bob, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#ffab00';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.font = 'bold 8px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.fillText('+' + p.value, rpx, rpy + bob - 12);
    ctx.textAlign = 'left';
    ctx.restore();
  }
}

function updateFreqGates() {
  for (const g of freqGates) {
    if (g.open) { g.openTimer = Math.min(1, (g.openTimer || 0) + deltaTime * 2); continue; }
    for (let j = projectiles.length - 1; j >= 0; j--) {
      const proj = projectiles[j];
      if (checkCollision(proj, g)) {
        if (proj.type === g.requiredType || (proj.isCombined && g.requiredType === 'combined')) {
          g.open = true;
          g.openTimer = 0;
          spawnParticles(g.x + g.w/2, g.y + g.h/2, 20, '#4caf50');
          levelBanner = { text: 'Gate Opened!', timer: 1.5, color: '#4caf50' };
          playSfx('success');
        }
        projectiles.splice(j, 1);
        break;
      }
    }
  }
}

function drawFreqGates() {
  for (const g of freqGates) {
    const gx = g.x - camera.x, gy = g.y - camera.y;
    ctx.save();
    if (g.open) {
      const alpha = 1 - (g.openTimer || 0);
      if (alpha <= 0) { ctx.restore(); continue; }
      ctx.globalAlpha = alpha;
    }
    ctx.fillStyle = g.color || '#ff6b6b';
    ctx.globalAlpha = (ctx.globalAlpha || 1) * (0.5 + Math.sin(gameTime * 3) * 0.2);
    ctx.fillRect(gx, gy, g.w, g.h);
    ctx.strokeStyle = g.color || '#ff6b6b';
    ctx.lineWidth = 2;
    ctx.globalAlpha = 1;
    if (!g.open) {
      ctx.strokeRect(gx, gy, g.w, g.h);
      ctx.font = '9px sans-serif';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.fillText(g.requiredType.toUpperCase(), gx + g.w/2, gy + g.h/2 + 3);
      ctx.textAlign = 'left';
    }
    ctx.restore();
  }
}

function updateSoundEmitters() {
  for (const em of soundEmitters) em.phase += deltaTime * 2;
}

function drawSoundEmitters() {
  for (const em of soundEmitters) {
    const ex = em.x - camera.x, ey = em.y - camera.y;
    ctx.save();
    for (let ring = 0; ring < 3; ring++) {
      const r = 5 + (ring * 12 + em.phase * 20) % (em.radius || 40);
      const alpha = 1 - r / (em.radius || 40);
      ctx.strokeStyle = em.color || '#64b5f6';
      ctx.lineWidth = 1;
      ctx.globalAlpha = alpha * 0.4;
      ctx.beginPath();
      ctx.arc(ex, ey, r, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.globalAlpha = 0.8;
    ctx.fillStyle = em.color || '#64b5f6';
    ctx.beginPath();
    ctx.arc(ex, ey, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ============================================================
// ENHANCED INTERACTIVE TUTORIAL
// ============================================================

const TUTORIAL_PHASES = {
  welcome: {
    steps: [
      { text: 'Welcome to Sound Thief!', subtext: 'Your microphone is your ultimate weapon.', duration: 3 },
      { text: 'You are a Sound Thief', subtext: 'Steal sounds from the world and use them to fight!', duration: 3 }
    ]
  },
  movement: {
    steps: [
      { text: 'MOVEMENT', subtext: 'Use arrow keys or tap the buttons below', highlight: 'dpad', duration: 0, action: 'move' },
      { text: 'Great!', subtext: 'Now try jumping!', highlight: 'jump', duration: 0, action: 'jump' }
    ]
  },
  recording: {
    steps: [
      { text: 'SOUND CAPTURE', subtext: 'Tap the REC button to record a sound from your mic', highlight: 'rec', duration: 0, action: 'record' },
      { text: 'Excellent!', subtext: 'Your sound is now a weapon! Each sound has unique properties.', duration: 2.5 }
    ]
  },
  combat: {
    steps: [
      { text: 'COMBAT', subtext: 'Tap a sound slot or the game area to fire!', highlight: 'inventory', duration: 0, action: 'shoot' },
      { text: 'Direct hit!', subtext: 'Different sounds do different damage.', duration: 2 }
    ]
  },
  weakness: {
    steps: [
      { text: 'WEAKNESSES', subtext: 'Enemies are weak to specific sound types!', duration: 3 },
      { text: 'Sound Types:', subtext: 'Loud (bass), Mid, High (treble), Harmonic, Low', duration: 3.5 },
      { text: 'Pro tip:', subtext: 'Hit an enemy weakness for 2x damage!', duration: 3 }
    ]
  },
  combine: {
    steps: [
      { text: 'SOUND MIXING', subtext: 'Combine two sounds to create powerful hybrids!', duration: 3 },
      { text: 'Tap MIX button', subtext: 'Select two sounds to merge them', highlight: 'mix', duration: 3 },
      { text: 'Combined sounds', subtext: 'Have unique types and bonus power!', duration: 2.5 }
    ]
  },
  spectrum: {
    steps: [
      { text: 'SPECTRUM DISPLAY', subtext: 'The frequency spectrum shows real-time audio analysis', duration: 3 },
      { text: 'Watch the bars', subtext: 'Red=bass, Yellow=mid, Teal=high, Purple=treble', duration: 3 }
    ]
  },
  boss: {
    steps: [
      { text: 'BOSS BATTLES', subtext: 'Bosses have shields! Use the right sound type to break them.', duration: 3.5 },
      { text: 'Phase Shifts', subtext: 'Bosses become more dangerous as they lose HP!', duration: 3 },
      { text: 'Some bosses', subtext: 'Can only be hurt by COMBINED sounds!', duration: 3 }
    ]
  }
};

function advanceTutorialPhase() {
  const phaseOrder = ['welcome', 'movement', 'recording', 'combat', 'weakness', 'combine', 'spectrum', 'boss', 'complete'];
  const currentIdx = phaseOrder.indexOf(tutorialPhase);
  if (currentIdx < phaseOrder.length - 1) {
    tutorialPhase = phaseOrder[currentIdx + 1];
    tutorialSubStep = 0;
    tutorialActionDone = false;
    tutorialCharIndex = 0;
  }
  if (tutorialPhase === 'complete') {
    showTutorial = false;
    tutorialStep = 0;
    levelBanner = { text: 'Tutorial Complete! Good luck, Sound Thief!', timer: 3, color: '#4caf50' };
  }
}

function updateEnhancedTutorial() {
  if (!showTutorial || tutorialPhase === 'none' || tutorialPhase === 'complete') return;
  const phaseData = TUTORIAL_PHASES[tutorialPhase];
  if (!phaseData) { advanceTutorialPhase(); return; }
  const stepData = phaseData.steps[tutorialSubStep];
  if (!stepData) { advanceTutorialPhase(); return; }

  const fullText = stepData.text + (stepData.subtext ? '|' + stepData.subtext : '');
  if (tutorialCharIndex < fullText.length) {
    tutorialTypeTimer += deltaTime;
    if (tutorialTypeTimer > 0.03) { tutorialCharIndex++; tutorialTypeTimer = 0; }
  }

  if (stepData.action) {
    if (stepData.action === 'move' && (Math.abs(player.vx) > 0.5)) tutorialActionDone = true;
    if (stepData.action === 'jump' && !player.onGround) tutorialActionDone = true;
    if (stepData.action === 'record' && soundInventory.length > 2) tutorialActionDone = true;
    if (stepData.action === 'shoot' && projectiles.length > 0) tutorialActionDone = true;
    if (tutorialActionDone) {
      tutorialSubStep++;
      tutorialActionDone = false;
      tutorialCharIndex = 0;
      if (tutorialSubStep >= phaseData.steps.length) advanceTutorialPhase();
    }
  } else if (stepData.duration > 0) {
    tutorialTimer += deltaTime;
    if (tutorialTimer >= stepData.duration) {
      tutorialTimer = 0;
      tutorialSubStep++;
      tutorialCharIndex = 0;
      if (tutorialSubStep >= phaseData.steps.length) advanceTutorialPhase();
    }
  }
}

function drawEnhancedTutorial() {
  if (!showTutorial || tutorialPhase === 'none' || tutorialPhase === 'complete') return;
  const phaseData = TUTORIAL_PHASES[tutorialPhase];
  if (!phaseData) return;
  const stepData = phaseData.steps[tutorialSubStep];
  if (!stepData) return;

  ctx.save();
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(0, 0, W, H);

  if (stepData.highlight) {
    ctx.save();
    let hlRect = null;
    if (stepData.highlight === 'dpad') hlRect = { x: 5, y: H - 210, w: 130, h: 70 };
    else if (stepData.highlight === 'jump') hlRect = { x: W - 80, y: H - 210, w: 70, h: 70 };
    else if (stepData.highlight === 'rec') hlRect = { x: W - 80, y: H - 120, w: 70, h: 50 };
    else if (stepData.highlight === 'inventory') hlRect = { x: 5, y: H - 85, w: W - 10, h: 75 };
    else if (stepData.highlight === 'mix') hlRect = { x: W - 145, y: H - 120, w: 65, h: 50 };
    if (hlRect) {
      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 4]);
      ctx.strokeRect(hlRect.x, hlRect.y, hlRect.w, hlRect.h);
      ctx.setLineDash([]);
      ctx.globalAlpha = 0.15 + Math.sin(gameTime * 4) * 0.1;
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(hlRect.x, hlRect.y, hlRect.w, hlRect.h);
      ctx.globalAlpha = 1;
      const arrowX = hlRect.x + hlRect.w / 2, arrowY = hlRect.y - 20;
      ctx.fillStyle = '#ffd700';
      ctx.beginPath();
      ctx.moveTo(arrowX, arrowY + 15);
      ctx.lineTo(arrowX - 8, arrowY);
      ctx.lineTo(arrowX + 8, arrowY);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  const cardW = Math.min(W - 30, 340);
  const cardH = 90;
  const cardX = centerX - cardW / 2;
  const cardY = 70;
  ctx.fillStyle = 'rgba(26, 32, 64, 0.95)';
  ctx.fillRect(cardX, cardY, cardW, cardH);
  ctx.strokeStyle = '#64b5f6';
  ctx.lineWidth = 2;
  ctx.strokeRect(cardX, cardY, cardW, cardH);

  const phaseNames = Object.keys(TUTORIAL_PHASES);
  const currentPhaseIdx = phaseNames.indexOf(tutorialPhase);
  const dotStartX = centerX - (phaseNames.length * 12) / 2;
  for (let i = 0; i < phaseNames.length; i++) {
    ctx.fillStyle = i <= currentPhaseIdx ? '#64b5f6' : '#444';
    ctx.beginPath();
    ctx.arc(dotStartX + i * 12, cardY + 10, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  const fullTitle = stepData.text;
  const displayTitle = fullTitle.substring(0, Math.min(tutorialCharIndex, fullTitle.length));
  ctx.font = 'bold 16px sans-serif';
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.fillText(displayTitle, centerX, cardY + 38);

  if (stepData.subtext && tutorialCharIndex > fullTitle.length) {
    const subIndex = tutorialCharIndex - fullTitle.length - 1;
    const displaySub = stepData.subtext.substring(0, Math.min(subIndex, stepData.subtext.length));
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#aaa';
    ctx.fillText(displaySub, centerX, cardY + 58);
  }

  if (stepData.action) {
    ctx.font = '10px sans-serif';
    ctx.fillStyle = '#ffd700';
    const prompts = { move: 'Move left or right to continue', jump: 'Press jump to continue', record: 'Record a sound to continue', shoot: 'Fire a sound to continue' };
    ctx.fillText(prompts[stepData.action] || 'Perform the action', centerX, cardY + 78);
  } else {
    ctx.font = '10px sans-serif';
    ctx.fillStyle = '#888';
    ctx.fillText('Tap to skip', centerX, cardY + 78);
  }
  ctx.textAlign = 'left';
  ctx.restore();
}

// ============================================================
// LEVEL BANNER
// ============================================================

function updateLevelBanner() {
  if (levelBanner.timer > 0) levelBanner.timer -= deltaTime;
}

function drawLevelBanner() {
  if (levelBanner.timer <= 0) return;
  ctx.save();
  ctx.globalAlpha = Math.min(1, levelBanner.timer);
  ctx.fillStyle = 'rgba(10, 14, 26, 0.85)';
  ctx.fillRect(0, 62, W, 40);
  ctx.font = 'bold 14px sans-serif';
  ctx.fillStyle = levelBanner.color || '#fff';
  ctx.textAlign = 'center';
  ctx.fillText(levelBanner.text, centerX, 87);
  ctx.textAlign = 'left';
  ctx.globalAlpha = 1;
  ctx.restore();
}

// ============================================================
// BACKGROUND WAVEFORMS
// ============================================================

function initBackgroundWaves() {
  backgroundWaves = [];
  for (let i = 0; i < 12; i++) {
    backgroundWaves.push({
      y: i * (H / 12),
      amplitude: 10 + Math.random() * 30,
      frequency: 0.01 + Math.random() * 0.03,
      phase: Math.random() * Math.PI * 2,
      speed: 0.3 + Math.random() * 0.7,
      opacity: 0.1 + Math.random() * 0.2
    });
  }
}

function drawBackgroundWaves() {
  for (const wave of backgroundWaves) {
    wave.phase += deltaTime * wave.speed;
    
    ctx.save();
    ctx.strokeStyle = `rgba(100, 180, 255, ${wave.opacity})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    
    for (let x = -10; x <= W + 10; x += 4) {
      const wx = x - camera.x * 0.3;
      const y = wave.y + Math.sin(wx * wave.frequency + wave.phase) * wave.amplitude;
      if (x === -10) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    
    ctx.stroke();
    ctx.restore();
  }
}

// ============================================================
// PARTICLES
// ============================================================

function spawnParticles(x, y, count, color) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6 - 2,
      life: 1,
      decay: 0.02 + Math.random() * 0.02,
      size: 2 + Math.random() * 4,
      color
    });
  }
}

function updateParticles() {
  const dt60 = deltaTime * 60;
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt60;
    p.y += p.vy * dt60;
    p.vy += 0.2 * dt60;
    p.life -= p.decay * dt60;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - camera.x, p.y - camera.y, p.size, p.size);
    ctx.restore();
  }
}

// ============================================================
// PLAYER
// ============================================================

function updatePlayer() {
  // Horizontal movement
  let moveX = 0;
  if (keys['ArrowLeft'] || keys['a'] || touchControls.left) moveX = -1;
  if (keys['ArrowRight'] || keys['d'] || touchControls.right) moveX = 1;
  
  const dt60 = deltaTime * 60;
  player.vx = moveX * player.moveSpeed;
  if (moveX !== 0) player.facing = moveX;

  // Jump
  if ((keys[' '] || keys['ArrowUp'] || keys['w'] || touchControls.jump) && player.onGround) {
    player.vy = player.jumpPower;
    player.onGround = false;
    playSfx('jump');
  }

  // Gravity
  if (!player.onGround) {
    player.vy += player.gravity * dt60;
  }

  // Update position
  player.x += player.vx * dt60;
  player.y += player.vy * dt60;
  
  // Collision with platforms
  player.onGround = false;
  for (const plat of platforms) {
    if (player.vx > 0 && player.x + player.w > plat.x && player.x < plat.x && 
        player.y + player.h > plat.y && player.y < plat.y + plat.h) {
      player.x = plat.x - player.w;
      player.vx = 0;
    }
    if (player.vx < 0 && player.x < plat.x + plat.w && player.x + player.w > plat.x + plat.w &&
        player.y + player.h > plat.y && player.y < plat.y + plat.h) {
      player.x = plat.x + plat.w;
      player.vx = 0;
    }
    if (player.vy > 0 && player.y + player.h > plat.y && player.y < plat.y &&
        player.x + player.w > plat.x && player.x < plat.x + plat.w) {
      player.y = plat.y - player.h;
      player.vy = 0;
      player.onGround = true;
    }
    if (player.vy < 0 && player.y < plat.y + plat.h && player.y + player.h > plat.y + plat.h &&
        player.x + player.w > plat.x && player.x < plat.x + plat.w) {
      player.y = plat.y + plat.h;
      player.vy = 0;
    }
  }
  
  // World bounds
  if (player.y > H + 100) {
    player.hp = 0; // Fall death
  }
  
  // Camera follow
  camera.targetX = player.x - W / 2 + player.w / 2;
  camera.targetY = player.y - H / 2 + player.h / 2;
  const camLerp = 1 - Math.pow(0.9, dt60);
  camera.x += (camera.targetX - camera.x) * camLerp;
  camera.y += (camera.targetY - camera.y) * camLerp;
  
  // Invincibility frames
  if (player.invincible > 0) player.invincible -= deltaTime;
  
  // Update cooldowns
  for (const sound of soundInventory) {
    if (sound.cooldown > 0) {
      sound.cooldown -= deltaTime;
    }
  }
}

function drawPlayer() {
  const px = player.x - camera.x;
  const py = player.y - camera.y;
  
  // Player as concentric circles
  ctx.save();
  // Flash during invincibility
  if (player.invincible > 0 && Math.floor(gameTime * 10) % 2 === 0) {
    ctx.globalAlpha = 0.3;
  }
  
  // Outer glow
  const grad = ctx.createRadialGradient(px + player.radius, py + player.radius, 0, 
                                        px + player.radius, py + player.radius, player.radius * 1.5);
  grad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
  grad.addColorStop(0.5, 'rgba(100, 200, 255, 0.4)');
  grad.addColorStop(1, 'rgba(100, 200, 255, 0)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(px + player.radius, py + player.radius, player.radius * 1.5, 0, Math.PI * 2);
  ctx.fill();
  
  // Core circles
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(px + player.radius, py + player.radius, player.radius, 0, Math.PI * 2);
  ctx.stroke();
  
  ctx.strokeStyle = 'rgba(100, 200, 255, 0.8)';
  ctx.beginPath();
  ctx.arc(px + player.radius, py + player.radius, player.radius * 0.6, 0, Math.PI * 2);
  ctx.stroke();

  ctx.restore();

  // Visual recording feedback: show sound energy ring when sounds are ready
  const readySounds = soundInventory.filter(s => s.cooldown <= 0).length;
  if (readySounds > 0) {
    ctx.save();
    const ringPulse = Math.sin(gameTime * 4) * 0.15 + 0.25;
    ctx.globalAlpha = ringPulse;
    ctx.strokeStyle = '#4caf50';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(px + player.radius, py + player.radius, player.radius * 2 + Math.sin(gameTime * 3) * 4, 0, Math.PI * 2);
    ctx.stroke();
    // Mini waveform around the ring
    ctx.strokeStyle = '#64b5f6';
    ctx.beginPath();
    const ringR = player.radius * 2.5;
    for (let a = 0; a < Math.PI * 2; a += 0.1) {
      const waveOff = Math.sin(a * 8 + gameTime * 5) * 3;
      const rx = px + player.radius + Math.cos(a) * (ringR + waveOff);
      const ry = py + player.radius + Math.sin(a) * (ringR + waveOff);
      if (a === 0) ctx.moveTo(rx, ry); else ctx.lineTo(rx, ry);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
}

// ============================================================
// ENEMIES
// ============================================================

function createEnemy(x, y, type = 'silence') {
  const enemy = {
    id: Date.now() + Math.random(),
    x, y, vx: 0, vy: 0,
    w: 30, h: 30,
    hp: 30,
    maxHp: 30,
    type: type,
    color: '#ff0080',
    phase: Math.random() * Math.PI * 2,
    weakness: 'loud', // weak to loud sounds
    shielded: false
  };
  
  if (type === 'echo') {
    enemy.color = '#00ffff';
    enemy.weakness = 'mid';
  } else if (type === 'harmonic') {
    enemy.color = '#c77dff';
    enemy.weakness = 'harmonic';
    enemy.hp = 50;
    enemy.maxHp = 50;
  } else if (type === 'noise') {
    enemy.color = '#ffd700';
    enemy.weakness = 'high';
    enemy.hp = 40;
    enemy.maxHp = 40;
  } else if (type === 'resonator') {
    // Resonator: shields nearby enemies, weak to low sounds
    enemy.color = '#ff9800';
    enemy.weakness = 'low';
    enemy.hp = 35;
    enemy.maxHp = 35;
    enemy.shieldRadius = 80;
  } else if (type === 'absorber') {
    // Absorber: eats projectiles until overloaded (3 hits), then pops
    enemy.color = '#7e57c2';
    enemy.weakness = 'loud';
    enemy.hp = 60;
    enemy.maxHp = 60;
    enemy.absorbed = 0;
    enemy.absorbMax = 3;
  }

  enemies.push(enemy);
}

function updateEnemies() {
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    e.phase += deltaTime * 2;
    
    // Simple AI: move toward player
    const dx = player.x - e.x;
    const dist = Math.abs(dx);
    if (dist > 20) {
      e.vx = dx > 0 ? 1 : -1;
    } else {
      e.vx = 0;
    }
    
    e.x += e.vx * deltaTime * 60;

    // Collision with player (with invincibility frames)
    if (checkCollision(player, e) && (!player.invincible || player.invincible <= 0)) {
      player.hp -= 10;
      player.invincible = 1.0; // 1 second invincibility
      spawnParticles(player.x, player.y, 8, '#ff6b6b');
      playSfx('hit');
      // Knockback
      player.vx = (player.x - e.x) > 0 ? 5 : -5;
      player.vy = -4;
    }
    
    // Resonator: shield nearby allies
    if (e.type === 'resonator' && e.shieldRadius) {
      for (const ally of enemies) {
        if (ally.id === e.id) continue;
        if (Math.hypot(ally.x - e.x, ally.y - e.y) < e.shieldRadius) {
          ally.shielded = true;
        }
      }
    }

    // Check projectile hits
    for (let j = projectiles.length - 1; j >= 0; j--) {
      const proj = projectiles[j];
      if (checkCollision(proj, e)) {
        // Absorber: eats projectiles
        if (e.type === 'absorber' && e.absorbed < e.absorbMax) {
          e.absorbed++;
          spawnParticles(e.x, e.y, 3, '#7e57c2');
          projectiles.splice(j, 1);
          if (e.absorbed >= e.absorbMax) {
            // Overloaded: takes massive damage
            e.hp -= 100;
            spawnParticles(e.x, e.y, 25, '#7e57c2');
            playSfx('hit');
          }
          break;
        }

        let damage = proj.damage;
        // Bonus damage for hitting weakness
        if (proj.type === e.weakness) {
          damage *= 2;
          spawnParticles(e.x, e.y, 10, '#ffd700');
        }
        // Shielded enemies take reduced damage
        if (e.shielded) {
          damage = Math.floor(damage * 0.3);
          e.shielded = false;
        }
        e.hp -= damage;
        spawnParticles(e.x, e.y, 5, proj.color);
        playSfx('hit');
        projectiles.splice(j, 1);

        if (e.hp <= 0) {
          spawnParticles(e.x, e.y, 20, e.color);
          resonance += 10;
          enemies.splice(i, 1);
        }
        break;
      }
    }
  }
}

function drawEnemies() {
  for (const e of enemies) {
    const ex = e.x - camera.x;
    const ey = e.y - camera.y;
    
    // Enemy as pulsing circle
    const pulse = Math.sin(e.phase) * 3;
    
    ctx.save();
    ctx.strokeStyle = e.color;
    ctx.lineWidth = 2;
    ctx.fillStyle = e.color + '40';
    ctx.beginPath();
    ctx.arc(ex + e.w/2, ey + e.h/2, e.w/2 + pulse, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // Resonator shield radius indicator
    if (e.type === 'resonator') {
      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = '#ff9800';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.arc(ex + e.w/2, ey + e.h/2, e.shieldRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
    }

    // Absorber: show absorbed count
    if (e.type === 'absorber') {
      for (let a = 0; a < e.absorbed; a++) {
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(ex + e.w/2 + (a - 1) * 8, ey - 16, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // HP bar
    const barW = e.w;
    const barH = 4;
    const hpPct = e.hp / e.maxHp;
    ctx.fillStyle = '#333';
    ctx.fillRect(ex, ey - 10, barW, barH);
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(ex, ey - 10, barW * hpPct, barH);

    ctx.restore();
  }
}

// ============================================================
// PROJECTILES
// ============================================================

function updateProjectiles() {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const proj = projectiles[i];
    proj.x += proj.vx * deltaTime * 60;
    proj.y += proj.vy * deltaTime * 60;
    proj.lifetime -= deltaTime;
    
    if (proj.lifetime <= 0) {
      projectiles.splice(i, 1);
    }
  }
}

function drawProjectiles() {
  for (const proj of projectiles) {
    const px = proj.x - camera.x;
    const py = proj.y - camera.y;
    
    ctx.save();
    
    // Draw waveform representation
    if (proj.waveform) {
      ctx.strokeStyle = proj.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      const waveWidth = proj.w * 2;
      const waveHeight = proj.h;
      for (let i = 0; i < proj.waveform.length; i++) {
        const x = px - waveWidth/2 + (i / proj.waveform.length) * waveWidth;
        const y = py + (proj.waveform[i] - 0.5) * waveHeight;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }
    
    // Core circle
    ctx.fillStyle = proj.color;
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    ctx.arc(px, py, proj.w/2, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  }
}

// ============================================================
// PLATFORMS
// ============================================================

function drawPlatforms() {
  for (const plat of platforms) {
    const px = plat.x - camera.x;
    const py = plat.y - camera.y;
    
    ctx.save();
    // Platform gradient
    const platGrad = ctx.createLinearGradient(px, py, px, py + plat.h);
    platGrad.addColorStop(0, '#667788');
    platGrad.addColorStop(1, '#445566');
    ctx.fillStyle = platGrad;
    ctx.fillRect(px, py, plat.w, plat.h);
    // Top highlight
    ctx.fillStyle = '#88aabb';
    ctx.fillRect(px, py, plat.w, 3);
    ctx.strokeStyle = '#556677';
    ctx.lineWidth = 1;
    ctx.strokeRect(px, py, plat.w, plat.h);
    ctx.restore();
  }
}

// ============================================================
// LEVELS
// ============================================================

function loadLevel(levelIndex) {
  enemies = [];
  platforms = [];
  projectiles = [];
  pickups = [];
  player.x = 50;
  player.y = 300;
  player.vx = 0;
  player.vy = 0;
  player.hp = player.maxHp;
  camera.x = 0;
  camera.y = 0;
  
  // Level 1: Tutorial
  if (levelIndex === 0) {
    platforms.push({ x: -200, y: 400, w: 1200, h: 40 });
    platforms.push({ x: 300, y: 300, w: 150, h: 20 });
    platforms.push({ x: 550, y: 200, w: 150, h: 20 });
    // Start with a procedural sound so player can fight
    if (soundInventory.length === 0) {
      soundInventory.push(createProceduralSound());
      soundInventory.push(createProceduralSound());
    }
    createEnemy(500, 360, 'silence');
    createEnemy(700, 160, 'echo');
  }
  // Level 2: Echo Chamber
  else if (levelIndex === 1) {
    platforms.push({ x: 0, y: 450, w: 200, h: 40 });
    platforms.push({ x: 300, y: 400, w: 200, h: 40 });
    platforms.push({ x: 600, y: 350, w: 200, h: 40 });
    platforms.push({ x: 900, y: 300, w: 200, h: 40 });
    createEnemy(350, 360, 'echo');
    createEnemy(650, 310, 'echo');
    createEnemy(950, 260, 'silence');
  }
  // Level 3: Harmonic Gate
  else if (levelIndex === 2) {
    platforms.push({ x: 0, y: 500, w: 300, h: 40 });
    platforms.push({ x: 400, y: 400, w: 100, h: 20 });
    platforms.push({ x: 600, y: 300, w: 100, h: 20 });
    platforms.push({ x: 800, y: 500, w: 300, h: 40 });
    createEnemy(450, 360, 'harmonic');
    createEnemy(850, 460, 'noise');
  }
  // Level 4: Noise Pit
  else if (levelIndex === 3) {
    platforms.push({ x: 0, y: 550, w: 150, h: 40 });
    platforms.push({ x: 200, y: 450, w: 150, h: 20 });
    platforms.push({ x: 400, y: 350, w: 150, h: 20 });
    platforms.push({ x: 600, y: 450, w: 150, h: 20 });
    platforms.push({ x: 800, y: 550, w: 150, h: 40 });
    createEnemy(250, 410, 'noise');
    createEnemy(450, 310, 'noise');
    createEnemy(650, 410, 'silence');
  }
  // Level 5: Resonance Chamber
  else if (levelIndex === 4) {
    platforms.push({ x: 0, y: 500, w: 400, h: 40 });
    platforms.push({ x: 500, y: 400, w: 200, h: 20 });
    platforms.push({ x: 800, y: 500, w: 400, h: 40 });
    // Resonator shields others
    createEnemy(600, 360, 'resonator');
    createEnemy(700, 460, 'silence');
    createEnemy(900, 460, 'echo');
  }
  // Level 6: The Absorber Den
  else if (levelIndex === 5) {
    platforms.push({ x: 0, y: 550, w: 200, h: 40 });
    platforms.push({ x: 250, y: 450, w: 150, h: 20 });
    platforms.push({ x: 450, y: 350, w: 150, h: 20 });
    platforms.push({ x: 650, y: 450, w: 150, h: 20 });
    platforms.push({ x: 850, y: 550, w: 200, h: 40 });
    createEnemy(300, 410, 'absorber');
    createEnemy(500, 310, 'absorber');
    createEnemy(700, 410, 'noise');
  }
  // Level 7: Fortress
  else if (levelIndex === 6) {
    platforms.push({ x: 0, y: 500, w: 300, h: 40 });
    platforms.push({ x: 350, y: 400, w: 100, h: 20 });
    platforms.push({ x: 500, y: 300, w: 200, h: 20 });
    platforms.push({ x: 750, y: 400, w: 100, h: 20 });
    platforms.push({ x: 900, y: 500, w: 300, h: 40 });
    // Resonator + absorber combo
    createEnemy(550, 260, 'resonator');
    createEnemy(600, 260, 'absorber');
    createEnemy(950, 460, 'harmonic');
    createEnemy(1050, 460, 'noise');
  }
  // Level 8: Boss - Harmonic Guardian
  else if (levelIndex === 7) {
    platforms.push({ x: 0, y: 500, w: 1000, h: 40 });
    // Boss enemy
    const boss = {
      x: 500, y: 300, vx: 0, vy: 0,
      w: 60, h: 60,
      hp: 200,
      maxHp: 200,
      type: 'boss',
      color: '#c77dff',
      phase: 0,
      weakness: 'harmonic',
      isBoss: true
    };
    enemies.push(boss);
  }

  currentLevel = levelIndex;
}

// ============================================================
// COLLISION
// ============================================================

function checkCollision(a, b) {
  return a.x < b.x + b.w &&
         a.x + (a.w || a.radius * 2) > b.x &&
         a.y < b.y + b.h &&
         a.y + (a.h || a.radius * 2) > b.y;
}

// ============================================================
// UI
// ============================================================

function drawUI() {
  // Top bar: HP and Resonance
  ctx.save();
  ctx.fillStyle = 'rgba(10, 14, 26, 0.8)';
  ctx.fillRect(0, 0, W, 60);
  
  // HP bar
  ctx.font = `bold 14px sans-serif`;
  ctx.fillStyle = '#64b5f6';
  ctx.fillText('HP:', 10, 25);
  
  const hpBarW = 150;
  const hpPct = player.hp / player.maxHp;
  ctx.fillStyle = '#333';
  ctx.fillRect(50, 12, hpBarW, 20);
  
  const grad = ctx.createLinearGradient(50, 12, 50 + hpBarW * hpPct, 12);
  grad.addColorStop(0, '#4caf50');
  grad.addColorStop(1, '#81c784');
  ctx.fillStyle = grad;
  ctx.fillRect(50, 12, hpBarW * hpPct, 20);
  
  ctx.strokeStyle = '#64b5f6';
  ctx.lineWidth = 2;
  ctx.strokeRect(50, 12, hpBarW, 20);
  
  ctx.fillStyle = '#fff';
  ctx.fillText(`${Math.round(player.hp)}%`, 220, 25);
  
  // Resonance
  ctx.fillStyle = '#ffd700';
  ctx.fillText(`Resonance: ${resonance}`, W - 160, 25);
  
  // Level
  const levelNames = ['Tutorial', 'Echo Chamber', 'Harmonic Gate', 'Noise Pit', 'Resonance Chamber', 'Absorber Den', 'Fortress', 'Harmonic Guardian'];
  ctx.fillStyle = '#64b5f6';
  ctx.font = `12px sans-serif`;
  ctx.fillText(`Level ${currentLevel + 1}: ${levelNames[currentLevel] || '???'}`, 10, 50);
  
  ctx.restore();
  
  // Sound inventory at bottom
  drawSoundInventory();
  
  // Touch controls (mobile)
  if ('ontouchstart' in window) {
    drawTouchControls();
  }
}

function drawSoundInventory() {
  const invY = H - 120;
  const invH = 120;
  
  ctx.save();
  ctx.fillStyle = 'rgba(10, 14, 26, 0.9)';
  ctx.fillRect(0, invY, W, invH);
  
  // Title
  ctx.font = `bold 12px sans-serif`;
  ctx.fillStyle = '#64b5f6';
  ctx.fillText('SOUND INVENTORY', 10, invY + 18);
  
  // Record button
  const recBtn = {
    x: W - 70,
    y: invY + 10,
    w: 60,
    h: 40
  };
  
  ctx.fillStyle = recordingState.active ? '#ff6b6b' : '#4caf50';
  ctx.fillRect(recBtn.x, recBtn.y, recBtn.w, recBtn.h);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.strokeRect(recBtn.x, recBtn.y, recBtn.w, recBtn.h);
  
  ctx.fillStyle = '#fff';
  ctx.font = `10px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText(recordingState.active ? 'STOP' : 'ðŸŽ¤ REC', recBtn.x + recBtn.w/2, recBtn.y + recBtn.h/2 + 4);
  ctx.textAlign = 'left';
  
  // Sound slots
  const slotW = (W - 40) / 5;
  const slotH = 70;
  const slotY = invY + 40;
  
  for (let i = 0; i < 5; i++) {
    const slotX = 10 + i * slotW;
    const sound = soundInventory[i];
    
    // Slot background
    ctx.strokeStyle = sound ? sound.analysis.color : '#444';
    ctx.lineWidth = 2;
    ctx.strokeRect(slotX, slotY, slotW - 10, slotH);
    
    if (sound) {
      // Waveform
      ctx.save();
      ctx.strokeStyle = sound.analysis.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      const waveW = slotW - 20;
      const waveH = 30;
      for (let j = 0; j < sound.waveform.length; j++) {
        const x = slotX + 5 + (j / sound.waveform.length) * waveW;
        const y = slotY + 10 + waveH/2 + (sound.waveform[j] - 0.5) * waveH;
        if (j === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.restore();
      
      // Stats
      ctx.font = `11px sans-serif`;
      ctx.fillStyle = '#ccc';
      ctx.fillText(`${sound.analysis.volume}dB`, slotX + 5, slotY + 50);
      ctx.fillText(`${(sound.analysis.frequency/1000).toFixed(1)}kHz`, slotX + 5, slotY + 62);
      
      // Cooldown overlay
      if (sound.cooldown > 0) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        const cdHeight = slotH * (sound.cooldown / 1.0);
        ctx.fillRect(slotX, slotY + slotH - cdHeight, slotW - 10, cdHeight);
      }
      
      // Slot number
      ctx.fillStyle = '#fff';
      ctx.font = `bold 11px sans-serif`;
      ctx.fillText(`${i + 1}`, slotX + 5, slotY + 15);

      // Delete button (small X in top-right corner)
      ctx.fillStyle = '#ff6b6b';
      ctx.font = `bold 10px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText('x', slotX + slotW - 18, slotY + 10);
      ctx.textAlign = 'left';
    } else {
      // Empty slot
      ctx.fillStyle = '#666';
      ctx.font = `10px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText('EMPTY', slotX + (slotW - 10)/2, slotY + slotH/2 + 4);
      ctx.textAlign = 'left';
    }
  }
  
  ctx.restore();
}

function drawTouchControls() {
  const btnSize = 50;
  const margin = 20;
  
  ctx.save();
  ctx.globalAlpha = 0.4;
  
  // Left button
  ctx.fillStyle = touchControls.left ? '#fff' : '#888';
  ctx.beginPath();
  ctx.arc(margin + btnSize/2, H - 180, btnSize/2, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#000';
  ctx.font = `20px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText('â†', margin + btnSize/2, H - 175);
  
  // Right button
  ctx.fillStyle = touchControls.right ? '#fff' : '#888';
  ctx.beginPath();
  ctx.arc(margin + btnSize * 2, H - 180, btnSize/2, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#000';
  ctx.fillText('â†’', margin + btnSize * 2, H - 175);
  
  // Jump button
  ctx.fillStyle = touchControls.jump ? '#fff' : '#888';
  ctx.beginPath();
  ctx.arc(W - margin - btnSize/2, H - 180, btnSize/2, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#000';
  ctx.fillText('â†‘', W - margin - btnSize/2, H - 175);
  
  ctx.restore();
}

// ============================================================
// RECORDING UI
// ============================================================

function drawRecordingScreen() {
  // Dark overlay
  ctx.fillStyle = 'rgba(10, 14, 26, 0.95)';
  ctx.fillRect(0, 0, W, H);
  
  // Title
  ctx.font = `bold 28px sans-serif`;
  ctx.fillStyle = '#64b5f6';
  ctx.textAlign = 'center';
  ctx.fillText('CAPTURE SOUND', centerX, 80);
  
  // Concentric circles animation
  const numCircles = 5;
  const baseRadius = 60;
  const pulse = Math.sin(gameTime * 3) * 10;
  
  for (let i = 0; i < numCircles; i++) {
    const radius = baseRadius + i * 30 + pulse;
    const alpha = 1 - (i / numCircles);
    
    ctx.strokeStyle = `rgba(255, 107, 107, ${alpha * 0.6})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(centerX, centerY - 40, radius, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  // Microphone icon
  ctx.fillStyle = '#ff6b6b';
  ctx.font = `40px sans-serif`;
  ctx.fillText('ðŸŽ¤', centerX, centerY - 30);
  
  // Live waveform if recording
  if (recordingState.active && analyser && micDataArray) {
    analyser.getByteTimeDomainData(micDataArray);
    
    const waveY = centerY + 60;
    const waveW = W - 40;
    const waveH = 80;
    
    ctx.save();
    ctx.strokeStyle = '#4caf50';
    ctx.lineWidth = 2;
    ctx.strokeRect(20, waveY, waveW, waveH);
    
    ctx.strokeStyle = '#4caf50';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    const sliceWidth = waveW / micDataArray.length;
    let x = 20;
    
    for (let i = 0; i < micDataArray.length; i++) {
      const v = micDataArray[i] / 128.0;
      const y = waveY + (v * waveH / 2);
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
      
      x += sliceWidth;
    }
    
    ctx.stroke();
    ctx.restore();
    
    // Timer
    const timeLeft = recordingState.maxDuration - recordingState.timer;
    ctx.font = `18px sans-serif`;
    ctx.fillStyle = timeLeft < 0.5 ? '#ff6b6b' : '#ffd700';
    ctx.fillText(`LISTENING... ${timeLeft.toFixed(1)}s`, centerX, waveY + waveH + 30);
  } else {
    // Instructions
    ctx.font = `14px sans-serif`;
    ctx.fillStyle = '#ccc';
    ctx.fillText('Tap STOP when done recording', centerX, centerY + 80);
    ctx.fillText('(or wait 2 seconds)', centerX, centerY + 100);
  }
  
  // Stop button
  ctx.fillStyle = '#ff6b6b';
  ctx.fillRect(centerX - 60, H - 200, 120, 50);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 3;
  ctx.strokeRect(centerX - 60, H - 200, 120, 50);
  
  ctx.fillStyle = '#fff';
  ctx.font = `bold 16px sans-serif`;
  ctx.fillText('STOP', centerX, H - 170);
  
  // Cancel button
  ctx.fillStyle = '#666';
  ctx.fillRect(centerX - 60, H - 130, 120, 40);
  ctx.strokeStyle = '#999';
  ctx.lineWidth = 2;
  ctx.strokeRect(centerX - 60, H - 130, 120, 40);
  
  ctx.fillStyle = '#fff';
  ctx.font = `14px sans-serif`;
  ctx.fillText('CANCEL', centerX, H - 105);
  
  ctx.textAlign = 'left';
}

// ============================================================
// TUTORIAL OVERLAY
// ============================================================

const TUTORIAL_STEPS = [
  { text: 'Move with arrows or tap left/right', icon: '< >', highlight: 'controls' },
  { text: 'Tap the REC button to capture sounds', icon: 'ðŸŽ¤', highlight: 'rec' },
  { text: 'Tap sound slots to fire at enemies', icon: 'ðŸ”Š', highlight: 'inventory' },
  { text: 'Match sound TYPES to enemy weaknesses!', icon: 'âš¡', highlight: 'enemy' }
];

function drawTutorial() {
  if (!showTutorial || tutorialStep < 1 || tutorialStep > TUTORIAL_STEPS.length) return;
  const step = TUTORIAL_STEPS[tutorialStep - 1];

  // Semi-transparent overlay
  ctx.save();
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(0, 0, W, H);

  // Tutorial card
  const cardW = Math.min(W - 40, 320);
  const cardH = 120;
  const cardX = centerX - cardW / 2;
  const cardY = centerY - cardH / 2;

  ctx.fillStyle = '#1a2040';
  ctx.fillRect(cardX, cardY, cardW, cardH);
  ctx.strokeStyle = '#64b5f6';
  ctx.lineWidth = 2;
  ctx.strokeRect(cardX, cardY, cardW, cardH);

  // Icon
  ctx.font = `32px sans-serif`;
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.fillText(step.icon, centerX, cardY + 35);

  // Text
  ctx.font = `14px sans-serif`;
  ctx.fillStyle = '#ccc';
  ctx.fillText(step.text, centerX, cardY + 70);

  // Step indicator
  ctx.font = `11px sans-serif`;
  ctx.fillStyle = '#888';
  ctx.fillText(`${tutorialStep}/${TUTORIAL_STEPS.length} - Tap to continue`, centerX, cardY + 100);

  ctx.textAlign = 'left';
  ctx.restore();
}

// ============================================================
// TITLE SCREEN
// ============================================================

function drawTitleScreen() {
  // Animated waveform background
  drawBackgroundWaves();
  
  // Dark overlay
  ctx.fillStyle = 'rgba(10, 14, 26, 0.7)';
  ctx.fillRect(0, 0, W, H);
  
  // Title
  ctx.save();
  ctx.font = `bold ${48 * scale}px sans-serif`;
  ctx.fillStyle = '#64b5f6';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('SOUND THIEF', centerX, centerY - 100);
  
  // Subtitle
  ctx.font = `${16 * scale}px sans-serif`;
  ctx.fillStyle = '#ccc';
  ctx.fillText('Your microphone is your weapon', centerX, centerY - 50);
  
  // Start button
  const btnW = 200;
  const btnH = 60;
  const btnY = centerY + 20;
  
  ctx.fillStyle = '#4caf50';
  ctx.fillRect(centerX - btnW/2, btnY - btnH/2, btnW, btnH);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 3;
  ctx.strokeRect(centerX - btnW/2, btnY - btnH/2, btnW, btnH);
  
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${20 * scale}px sans-serif`;
  ctx.fillText('START GAME', centerX, btnY);
  
  // Mic permission status
  if (micPermission) {
    ctx.fillStyle = '#4caf50';
    ctx.font = `${12 * scale}px sans-serif`;
    ctx.fillText('ðŸŽ¤ Microphone Ready', centerX, centerY + 80);
  } else {
    ctx.fillStyle = '#ff6b6b';
    ctx.font = `${12 * scale}px sans-serif`;
    ctx.fillText('âš  Microphone access required', centerX, centerY + 80);
    ctx.fillStyle = '#ccc';
    ctx.font = `${10 * scale}px sans-serif`;
    ctx.fillText('(Fallback mode: tap-to-shoot)', centerX, centerY + 100);
  }

  // How to play
  ctx.font = `${11 * scale}px sans-serif`;
  ctx.fillStyle = '#888';
  ctx.fillText('Record real sounds with your mic', centerX, centerY + 140);
  ctx.fillText('to create unique weapons!', centerX, centerY + 158);
  ctx.fillText(`8 levels | ${Object.keys({silence:1,echo:1,harmonic:1,noise:1,resonator:1,absorber:1}).length} enemy types`, centerX, centerY + 185);

  ctx.restore();
}

// ============================================================
// GAME OVER
// ============================================================

function drawGameOver() {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
  ctx.fillRect(0, 0, W, H);
  
  ctx.save();
  ctx.font = `bold 36px sans-serif`;
  ctx.fillStyle = gs_victory ? '#4caf50' : '#ff6b6b';
  ctx.textAlign = 'center';
  ctx.fillText(gs_victory ? 'YOU WIN!' : 'GAME OVER', centerX, centerY - 50);
  
  ctx.font = `18px sans-serif`;
  ctx.fillStyle = '#ccc';
  ctx.fillText(`Level ${currentLevel + 1} | Resonance: ${resonance}`, centerX, centerY);
  
  // Restart button
  ctx.fillStyle = '#4caf50';
  ctx.fillRect(centerX - 100, centerY + 40, 200, 50);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.strokeRect(centerX - 100, centerY + 40, 200, 50);
  
  ctx.fillStyle = '#fff';
  ctx.font = `bold 16px sans-serif`;
  ctx.fillText('RESTART', centerX, centerY + 70);
  
  ctx.restore();
}

// ============================================================
// INPUT
// ============================================================

window.addEventListener('keydown', (e) => {
  keys[e.key] = true;
  
  // Number keys 1-5 to use sounds
  if (gameState === 'PLAYING') {
    const num = parseInt(e.key);
    if (num >= 1 && num <= 5 && soundInventory[num - 1]) {
      playSound(soundInventory[num - 1]);
    }
  }
});

window.addEventListener('keyup', (e) => {
  keys[e.key] = false;
});

canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
canvas.addEventListener('mousedown', handleMouseDown);

function handleTouchStart(e) {
  e.preventDefault();
  initAudio();
  
  for (let i = 0; i < e.touches.length; i++) {
    const touch = e.touches[i];
    handleInput(touch.clientX, touch.clientY, 'start');
  }
}

function handleTouchMove(e) {
  e.preventDefault();
}

function handleTouchEnd(e) {
  e.preventDefault();
  touchControls.left = false;
  touchControls.right = false;
  touchControls.jump = false;
}

function handleMouseDown(e) {
  initAudio();
  handleInput(e.clientX, e.clientY, 'start');
}

function handleInput(x, y, type) {
  if (gameState === 'TITLE') {
    // Start button
    const btnW = 200;
    const btnH = 60;
    if (x > centerX - btnW/2 && x < centerX + btnW/2 &&
        y > centerY + 20 - btnH/2 && y < centerY + 20 + btnH/2) {
      startGame();
    }
  } else if (gameState === 'RECORDING') {
    // Stop button
    if (x > centerX - 60 && x < centerX + 60 &&
        y > H - 200 && y < H - 150) {
      stopRecording();
    }
    // Cancel button
    if (x > centerX - 60 && x < centerX + 60 &&
        y > H - 130 && y < H - 90) {
      recordingState.active = false;
      if (recordingState.recorder) {
        try { recordingState.source.disconnect(); } catch(e) {}
        try { recordingState.recorder.disconnect(); } catch(e) {}
        recordingState.recorder = null;
        recordingState.source = null;
      }
      gameState = 'PLAYING';
    }
  } else if (gameState === 'PLAYING') {
    // Tutorial overlay intercepts taps
    if (tutorialStep > 0 && tutorialStep <= TUTORIAL_STEPS.length) {
      tutorialStep++;
      if (tutorialStep > TUTORIAL_STEPS.length) {
        tutorialStep = 0;
        showTutorial = false;
      }
      return;
    }

    // Touch controls
    const btnSize = 50;
    const margin = 20;
    
    // Left
    if (Math.hypot(x - (margin + btnSize/2), y - (H - 180)) < btnSize/2) {
      touchControls.left = true;
    }
    // Right
    if (Math.hypot(x - (margin + btnSize * 2), y - (H - 180)) < btnSize/2) {
      touchControls.right = true;
    }
    // Jump
    if (Math.hypot(x - (W - margin - btnSize/2), y - (H - 180)) < btnSize/2) {
      touchControls.jump = true;
    }
    
    // Record button
    if (x > W - 70 && x < W - 10 && y > H - 110 && y < H - 80) {
      if (recordingState.active) {
        stopRecording();
      } else {
        startRecordingMode();
      }
    }
    
    // Sound inventory slots
    const invY = H - 120;
    const slotW = (W - 40) / 5;
    const slotH = 70;
    const slotY = invY + 40;
    
    if (y > slotY && y < slotY + slotH) {
      const slotIndex = Math.floor((x - 10) / slotW);
      if (slotIndex >= 0 && slotIndex < 5 && soundInventory[slotIndex]) {
        // Check if tapping the delete X (top-right corner of slot)
        const slotXPos = 10 + slotIndex * slotW;
        if (x > slotXPos + slotW - 25 && y < slotY + 18) {
          soundInventory.splice(slotIndex, 1);
          playSfx('error');
        } else {
          playSound(soundInventory[slotIndex]);
        }
      }
    }
    
    // Tap anywhere in game area to auto-shoot first available sound
    if (y < invY && y > 60) {
      // Set facing based on tap side
      if (x > W / 2) player.facing = 1; else player.facing = -1;
      for (const s of soundInventory) {
        if (s.cooldown <= 0) { playSound(s); break; }
      }
    }
  } else if (gameState === 'GAME_OVER') {
    // Restart button
    if (x > centerX - 100 && x < centerX + 100 &&
        y > centerY + 40 && y < centerY + 90) {
      gs_victory = false;
      gs_levelClearing = false;
      resonance = 0;
      soundInventory = [];
      loadLevel(0);
      gameState = 'PLAYING';
    }
  }
}

// ============================================================
// GAME LOGIC
// ============================================================

async function startGame() {
  // Request mic permission
  const granted = await requestMic();
  if (!granted) {
    // Fallback mode: generate procedural sounds
    console.log('Running in fallback mode without microphone');
  }
  
  loadLevel(0);
  gameState = 'PLAYING';
  if (showTutorial) {
    tutorialStep = 1;
    tutorialTimer = 0;
  }
}

function startRecordingMode() {
  if (!micPermission) {
    // Fallback: create procedural sound
    const proceduralSound = createProceduralSound();
    soundInventory.push(proceduralSound);
    playSfx('success');
    return;
  }
  
  gameState = 'RECORDING';
  startRecording();
}

function createProceduralSound() {
  // Generate a random procedural sound for fallback mode
  const types = ['loud', 'mid', 'high', 'harmonic'];
  const type = types[Math.floor(Math.random() * types.length)];
  
  const colors = { loud: '#ff6b6b', mid: '#ffe66d', high: '#4ecdc4', harmonic: '#c77dff' };
  
  const freq = type === 'high' ? 2000 + Math.random() * 1000 :
               type === 'mid' ? 800 + Math.random() * 1200 :
               type === 'harmonic' ? 440 + Math.random() * 660 :
               200 + Math.random() * 400;
  
  const vol = 60 + Math.random() * 40;
  
  // Generate simple waveform
  const waveform = [];
  for (let i = 0; i < 100; i++) {
    waveform.push(0.5 + Math.sin(i * 0.1) * 0.3 * Math.random());
  }
  
  return {
    id: Date.now(),
    buffer: new Float32Array(8000), // dummy buffer
    sampleRate: 44100,
    analysis: {
      volume: Math.round(vol),
      frequency: Math.round(freq),
      duration: 1.0,
      type: type,
      color: colors[type],
      power: Math.round(vol * 0.8 + (freq / 3000) * 20)
    },
    waveform: waveform,
    cooldown: 0
  };
}

// ============================================================
// MAIN LOOP
// ============================================================

function update() {
  const now = performance.now() / 1000;
  deltaTime = Math.min(0.1, now - lastTime);
  lastTime = now;
  gameTime += deltaTime;
  
  if (gameState === 'PLAYING') {
    updatePlayer();
    updateEnemies();
    updateProjectiles();
    updateParticles();
    
    // Check level completion
    if (enemies.length === 0 && !gs_levelClearing) {
      gs_levelClearing = true;
      if (currentLevel < 7) {
        setTimeout(() => {
          loadLevel(currentLevel + 1);
          gs_levelClearing = false;
        }, 1500);
      } else {
        // Game won!
        gameState = 'GAME_OVER';
        gs_victory = true;
        player.hp = player.maxHp;
      }
    }
    
    // Check game over
    if (player.hp <= 0) {
      gameState = 'GAME_OVER';
    }
  } else if (gameState === 'RECORDING') {
    recordingState.timer += deltaTime;
    if (recordingState.timer >= recordingState.maxDuration && recordingState.active) {
      stopRecording();
    }
  }
}

function draw() {
  // Clear
  ctx.fillStyle = '#0a0e1a';
  ctx.fillRect(0, 0, W, H);
  
  if (gameState === 'TITLE') {
    drawTitleScreen();
  } else if (gameState === 'RECORDING') {
    drawRecordingScreen();
  } else if (gameState === 'PLAYING') {
    drawBackgroundWaves();
    drawPlatforms();
    drawPlayer();
    drawEnemies();
    drawProjectiles();
    drawParticles();
    drawUI();
    drawTutorial();
  } else if (gameState === 'GAME_OVER') {
    drawGameOver();
  }
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// ============================================================
// START
// ============================================================

initBackgroundWaves();
gameLoop();

</script>
</body>
</html>
