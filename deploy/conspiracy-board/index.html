<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Conspiracy Board</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #3a2a1a;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  font-family: 'Courier New', monospace;
}
canvas {
  display: block;
  width: 100%; height: 100%;
  cursor: crosshair;
}
</style>
</head>
<body>
<canvas id="board"></canvas>
<script>
'use strict';

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

let W, H, scale;
let gameTime = 0, deltaTime = 0, lastTime = 0;
let currentCase = null;
let caseIndex = 0;
let clues = [];
let connections = [];
let draggedClue = null;
let dragOffset = { x: 0, y: 0 };
let drawingString = false;
let stringStart = null;
let stringCurrent = { x: 0, y: 0 };
let camera = { x: 0, y: 0, zoom: 1, targetZoom: 1 };
let inputEvents = [];
let gameState = 'menu';
let solveTime = 0;
let correctConnections = 0;
let totalRequired = 0;
let revealAnim = 0;
let pinchDist = 0;
let selectedClue = null;
let tutorial = { step: 0, shown: false, timer: 0 };
let hints = [];
let hintsUsed = 0;
let shakeAmount = 0;
let bestTimes = {};
try { const s = localStorage.getItem('conspboard'); if (s) bestTimes = JSON.parse(s); } catch(e){}
function saveBest() { try { localStorage.setItem('conspboard', JSON.stringify(bestTimes)); } catch(e){} }

// Pin colors pool
const pinColors = ['#c41e3a', '#ffd700', '#4169e1', '#228b22', '#ff8c00', '#9932cc', '#ff69b4', '#00ced1'];
let pinColorIdx = 0;
function nextPinColor() { return pinColors[pinColorIdx++ % pinColors.length]; }

function resize() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  scale = Math.min(W / 400, H / 700);
}
window.addEventListener('resize', resize);
resize();

// ============================================================
// AUDIO
// ============================================================
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){} }
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
}

function playTone(freq, dur, type = 'sine', vol = 0.1) {
  if (!audioCtx) return;
  const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.setValueAtTime(vol, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur);
  o.connect(g).connect(audioCtx.destination);
  o.start(t); o.stop(t + dur);
}
function playNoise(dur, vol = 0.06, freq = null) {
  if (!audioCtx) return;
  const t = audioCtx.currentTime;
  const sz = audioCtx.sampleRate * dur;
  const buf = audioCtx.createBuffer(1, sz, audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < sz; i++) d[i] = Math.random() * 2 - 1;
  const s = audioCtx.createBufferSource(); s.buffer = buf;
  const g = audioCtx.createGain();
  g.gain.setValueAtTime(vol, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur);
  if (freq) {
    const f = audioCtx.createBiquadFilter();
    f.type = 'lowpass'; f.frequency.value = freq;
    s.connect(f).connect(g).connect(audioCtx.destination);
  } else { s.connect(g).connect(audioCtx.destination); }
  s.start(t);
}

function sfxPin() { playTone(800, 0.04, 'sine', 0.08); playTone(400, 0.03, 'sine', 0.06); }
function sfxPaper() { playNoise(0.12, 0.05, 2000); }
function sfxString() { playTone(300 + Math.random() * 100, 0.08, 'triangle', 0.04); }
function sfxCorrect() { playTone(880, 0.08, 'sine', 0.08); playTone(1100, 0.06, 'sine', 0.06); }
function sfxWrong() { playTone(200, 0.12, 'sawtooth', 0.06); }
function sfxSolve() { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playTone(f, 0.15, 'sine', 0.1), i * 120)); }
function sfxClick() { playTone(600, 0.03, 'sine', 0.04); }
function sfxHint() { playTone(440, 0.1, 'triangle', 0.06); playTone(660, 0.08, 'triangle', 0.04); }
function sfxRemove() { playTone(300, 0.06, 'triangle', 0.04); }

// ============================================================
// CASES â€” improved with clearer connections
// ============================================================
const caseTemplates = [
  {
    type: 'murder', title: 'The Midnight Manor Murder',
    difficulty: 1,
    suspects: ['Butler', 'Gardener', 'Cook', 'Maid', 'Doctor'],
    clueData: [
      { type: 'photo', label: 'ðŸ“· CRIME SCENE', desc: 'Study, 11pm\nBlood on desk', tags: ['crime', 'time'], color: '#8b0000' },
      { type: 'document', label: 'ðŸ“œ THE WILL', desc: 'Â£5M inheritance\nRecent change', tags: ['motive', 'suspect1'], color: '#daa520' },
      { type: 'evidence', label: 'ðŸ”ª CANDLESTICK', desc: 'Bloody, heavy\nFingerprints: Cook', tags: ['weapon', 'suspect2'], color: '#cd853f' },
      { type: 'statement', label: 'ðŸ’¬ BUTLER SAYS', desc: '"Heard arguing\nat 11pm"', tags: ['time', 'suspect1'], color: '#4682b4' },
      { type: 'evidence', label: 'ðŸ‘£ MUD TRACKS', desc: 'Garden boots\nSize 10 â€” Gardener', tags: ['suspect3', 'crime'], color: '#556b2f' },
      { type: 'document', label: 'ðŸ§ª POISON TEST', desc: 'Result: Negative\nNot poisoned', tags: ['weapon', 'crime'], color: '#708090' },
      { type: 'statement', label: 'âŒ ALIBI BROKEN', desc: 'Gardener says home\nNeighbour saw him here', tags: ['suspect3', 'motive'], color: '#b22222' },
      { type: 'evidence', label: 'ðŸ§µ APRON THREAD', desc: 'Cook\'s apron thread\nFound at scene', tags: ['suspect2', 'crime'], color: '#deb887' },
    ],
    connections: [
      [0, 5, 'crime-weapon'], [5, 2, 'weapon-suspect'], [2, 7, 'suspect-scene'],
      [0, 3, 'crime-time'], [3, 1, 'time-motive'], [4, 6, 'suspect-alibi']
    ]
  },
  {
    type: 'heist', title: 'The Gallery Heist',
    difficulty: 2,
    suspects: ['Security Guard', 'Curator', 'Janitor', 'Donor', 'Artist'],
    clueData: [
      { type: 'photo', label: 'ðŸ–¼ï¸ EMPTY FRAME', desc: '$10M painting gone\n3am discovered', tags: ['crime', 'time'], color: '#8b0000' },
      { type: 'document', label: 'ðŸ“Š SECURITY LOG', desc: 'Logs altered at 2am\nGuard\'s terminal', tags: ['suspect1', 'crime'], color: '#4169e1' },
      { type: 'photo', label: 'ðŸ”§ VENT OPENED', desc: 'Ventilation shaft\nScrews removed inside', tags: ['entry', 'crime'], color: '#708090' },
      { type: 'statement', label: 'ðŸ’¬ CURATOR', desc: '"I left at 8pm"\nCard swipe confirms', tags: ['suspect2', 'time'], color: '#4682b4' },
      { type: 'evidence', label: 'ðŸ”‘ JANITOR KEY', desc: 'Keycard used 3am\nJanitor denies it', tags: ['suspect3', 'entry'], color: '#daa520' },
      { type: 'document', label: 'ðŸ’° BANKRUPTCY', desc: 'Donor filed Ch.11\nLast month', tags: ['suspect4', 'motive'], color: '#b22222' },
      { type: 'evidence', label: 'ðŸŽ¨ PAINT MATCH', desc: 'Paint samples match\nArtist\'s studio', tags: ['suspect5', 'crime'], color: '#9370db' },
      { type: 'statement', label: 'ðŸ“¹ FOOTAGE GONE', desc: 'Security footage\n"corrupted" by guard', tags: ['suspect1', 'motive'], color: '#cd853f' },
    ],
    connections: [
      [0, 2, 'crime-entry'], [2, 4, 'entry-suspect'], [4, 1, 'suspect-evidence'],
      [1, 7, 'evidence-motive'], [0, 3, 'crime-time'], [5, 6, 'motive-link']
    ]
  },
  {
    type: 'missing', title: 'The Vanishing Heiress',
    difficulty: 2,
    suspects: ['FiancÃ©', 'Business Partner', 'Brother', 'Therapist', 'Driver'],
    clueData: [
      { type: 'photo', label: 'â˜• LAST SEEN', desc: 'CafÃ© at 2pm\nSeemed nervous', tags: ['time', 'location'], color: '#8b4513' },
      { type: 'document', label: 'ðŸ“± TEXT MSG', desc: '"Meet me at docks"\nFrom unknown number', tags: ['location', 'suspect1'], color: '#4169e1' },
      { type: 'statement', label: 'ðŸ’¬ FIANCÃ‰ LIES', desc: '"She went abroad"\nPassport still home', tags: ['suspect1', 'motive'], color: '#b22222' },
      { type: 'photo', label: 'ðŸš— CAR FOUND', desc: 'Abandoned at docks\nKeys in ignition', tags: ['location', 'crime'], color: '#708090' },
      { type: 'document', label: 'ðŸ“‹ INSURANCE', desc: 'New life policy\n$2M â€” FiancÃ© benefits', tags: ['motive', 'suspect1'], color: '#daa520' },
      { type: 'statement', label: 'ðŸ’¬ BROTHER', desc: '"She feared someone"\nWouldn\'t say who', tags: ['suspect3', 'motive'], color: '#4682b4' },
      { type: 'evidence', label: 'ðŸ“” THERAPY NOTES', desc: 'Paranoia, threats\nFrom "close friend"', tags: ['suspect4', 'motive'], color: '#9370db' },
      { type: 'photo', label: 'ðŸ“ DRIVER GPS', desc: 'Went to warehouse\nDistrict 5, 4pm', tags: ['suspect5', 'location'], color: '#cd853f' },
    ],
    connections: [
      [0, 3, 'location-crime'], [3, 1, 'crime-suspect'], [1, 2, 'suspect-motive'],
      [2, 4, 'motive-evidence'], [0, 7, 'time-trail'], [5, 6, 'fear-source']
    ]
  },
  {
    type: 'sabotage', title: 'The Poisoned Prototype',
    difficulty: 3,
    suspects: ['Rival CEO', 'Lab Assistant', 'Investor', 'Ex-Partner', 'Intern'],
    clueData: [
      { type: 'photo', label: 'ðŸ§¬ SABOTAGED', desc: 'Prototype failed\nContaminated sample', tags: ['crime', 'method'], color: '#8b0000' },
      { type: 'document', label: 'ðŸ’» ACCESS LOG', desc: 'Lab entered 2am\nIntern\'s badge', tags: ['suspect5', 'crime'], color: '#4169e1' },
      { type: 'evidence', label: 'ðŸ§ª CHEMICAL', desc: 'Rare solvent found\nOnly sold to 3 labs', tags: ['method', 'trail'], color: '#daa520' },
      { type: 'statement', label: 'ðŸ’¬ ASSISTANT', desc: '"Saw rival CEO\nnear lab Tuesday"', tags: ['suspect1', 'suspect5'], color: '#4682b4' },
      { type: 'document', label: 'ðŸ“§ LEAKED EMAIL', desc: 'Rival offered intern\n$50K to "help"', tags: ['suspect1', 'motive'], color: '#b22222' },
      { type: 'evidence', label: 'ðŸ“¦ DELIVERY', desc: 'Chemical shipped to\nP.O. Box â€” Rival\'s', tags: ['trail', 'suspect1'], color: '#cd853f' },
      { type: 'statement', label: 'ðŸ’¬ EX-PARTNER', desc: '"They stole my\nresearch. I want justice"', tags: ['suspect4', 'motive'], color: '#9370db' },
      { type: 'document', label: 'ðŸ“ˆ STOCK MOVE', desc: 'Investor shorted stock\nDay before failure', tags: ['suspect3', 'motive'], color: '#556b2f' },
    ],
    connections: [
      [0, 2, 'crime-method'], [2, 5, 'method-trail'], [5, 4, 'trail-motive'],
      [4, 3, 'motive-link'], [1, 3, 'access-witness'], [6, 7, 'side-motives']
    ]
  },
  {
    type: 'fraud', title: 'The Charity Swindle',
    difficulty: 2,
    suspects: ['Director', 'Accountant', 'PR Manager', 'Board Chair', 'Volunteer Lead'],
    clueData: [
      { type: 'document', label: 'ðŸ“Š AUDIT REPORT', desc: '$3M unaccounted\nFlagged by auditor', tags: ['crime', 'money'], color: '#8b0000' },
      { type: 'evidence', label: 'ðŸ¦ BANK RECORDS', desc: 'Wire transfers to\noffshore account', tags: ['money', 'trail'], color: '#4169e1' },
      { type: 'statement', label: 'ðŸ’¬ ACCOUNTANT', desc: '"Director told me\nto move funds"', tags: ['suspect1', 'suspect2'], color: '#4682b4' },
      { type: 'photo', label: 'ðŸ“¸ YACHT PHOTOS', desc: 'Director\'s social media\nNew yacht last month', tags: ['suspect1', 'motive'], color: '#daa520' },
      { type: 'document', label: 'ðŸ“ FORGED RECEIPT', desc: 'Fake vendor invoice\nPR Mgr\'s handwriting', tags: ['suspect3', 'crime'], color: '#b22222' },
      { type: 'evidence', label: 'ðŸ’» DELETED EMAILS', desc: 'Recovered from server\nBoard chair warned early', tags: ['suspect4', 'trail'], color: '#cd853f' },
      { type: 'statement', label: 'ðŸ’¬ VOLUNTEER', desc: '"Supplies never arrived\nbut were paid for"', tags: ['crime', 'motive'], color: '#9370db' },
      { type: 'document', label: 'ðŸ“‹ SHELL COMPANY', desc: 'Registered to Director\nSame offshore address', tags: ['trail', 'suspect1'], color: '#556b2f' },
    ],
    connections: [
      [0, 1, 'crime-money'], [1, 7, 'money-trail'], [7, 3, 'trail-suspect'],
      [2, 3, 'witness-suspect'], [4, 0, 'forgery-crime'], [5, 6, 'cover-up']
    ]
  },
  {
    type: 'arson', title: 'The Factory Fire',
    difficulty: 3,
    suspects: ['Owner', 'Night Guard', 'Rival Owner', 'Insurance Agent', 'Former Employee'],
    clueData: [
      { type: 'photo', label: 'ðŸ”¥ BURN PATTERN', desc: 'Two origin points\nAccelerant detected', tags: ['crime', 'method'], color: '#8b0000' },
      { type: 'document', label: 'ðŸ“„ INSURANCE', desc: 'Policy doubled\n2 weeks before fire', tags: ['motive', 'suspect1'], color: '#daa520' },
      { type: 'evidence', label: 'ðŸ”‘ SPARE KEY', desc: 'Guard\'s spare key\nmissing from lockbox', tags: ['suspect2', 'entry'], color: '#4169e1' },
      { type: 'statement', label: 'ðŸ’¬ GUARD ALIBI', desc: '"Left post at 11pm\nDrove home â€” no proof"', tags: ['suspect2', 'time'], color: '#4682b4' },
      { type: 'document', label: 'ðŸ“ž PHONE RECORDS', desc: 'Owner called rival\n3 times that week', tags: ['suspect1', 'suspect3'], color: '#b22222' },
      { type: 'evidence', label: 'â›½ GAS CANISTER', desc: 'Found in dumpster\nFingerprints: ex-employee', tags: ['method', 'suspect5'], color: '#cd853f' },
      { type: 'statement', label: 'ðŸ’¬ EX-EMPLOYEE', desc: '"Owner offered me $10K\nto start the fire"', tags: ['suspect5', 'suspect1'], color: '#9370db' },
      { type: 'document', label: 'ðŸ“§ AGENT EMAIL', desc: 'Insurance agent flagged\n"suspicious timing"', tags: ['suspect4', 'motive'], color: '#556b2f' },
    ],
    connections: [
      [0, 5, 'crime-method'], [5, 6, 'method-suspect'], [6, 4, 'suspect-link'],
      [4, 1, 'link-motive'], [2, 3, 'entry-alibi'], [7, 1, 'insurance-motive']
    ]
  }
];

// ============================================================
// CASE SETUP
// ============================================================
function generateCase(templateIndex) {
  const t = caseTemplates[templateIndex % caseTemplates.length];
  const padding = 100 * scale;
  const boardW = W * 1.5;
  const boardH = H * 1.5;
  
  // Arrange clues in a nice spread
  const cols = 3;
  const rows = Math.ceil(t.clueData.length / cols);
  const cellW = (boardW - padding * 2) / cols;
  const cellH = (boardH - padding * 2) / rows;
  
  const caseClues = t.clueData.map((cd, i) => {
    const col = i % cols;
    const row = Math.floor(i / cols);
    const x = padding + col * cellW + cellW / 2 + (Math.random() - 0.5) * cellW * 0.3;
    const y = padding + row * cellH + cellH / 2 + (Math.random() - 0.5) * cellH * 0.3;
    const rotation = (Math.random() - 0.5) * 0.08;
    
    return {
      id: i,
      type: cd.type,
      label: cd.label,
      desc: cd.desc,
      tags: cd.tags,
      color: cd.color,
      x, y, rotation,
      width: 130 * scale,
      height: 90 * scale,
      pinColor: null,
      discovered: false,
      dropDelay: i * 0.15
    };
  });
  
  return {
    title: t.title,
    type: t.type,
    difficulty: t.difficulty,
    clues: caseClues,
    requiredConnections: t.connections,
    suspects: t.suspects
  };
}

function startCase(index) {
  caseIndex = index;
  currentCase = generateCase(index);
  clues = currentCase.clues;
  connections = [];
  gameState = 'playing';
  solveTime = 0;
  correctConnections = 0;
  totalRequired = currentCase.requiredConnections.length;
  camera = { x: W * 0.75, y: H * 0.75, zoom: 0.6, targetZoom: 0.6 };
  selectedClue = null;
  hints = [...currentCase.requiredConnections];
  hintsUsed = 0;
  pinColorIdx = 0;
  tutorial = { step: 0, shown: false, timer: 0 };
  shakeAmount = 0;
  
  // Animated reveal
  clues.forEach((c, i) => {
    setTimeout(() => {
      c.discovered = true;
      sfxPaper();
    }, 300 + i * 150);
  });
}

// ============================================================
// DRAWING
// ============================================================
function drawCorkBG() {
  const grad = ctx.createLinearGradient(0, 0, W, H);
  grad.addColorStop(0, '#7a6545');
  grad.addColorStop(0.3, '#8d7455');
  grad.addColorStop(0.7, '#7a6545');
  grad.addColorStop(1, '#6d5a3a');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
  
  // Cork grain (static pattern based on position)
  ctx.save(); ctx.globalAlpha = 0.15;
  for (let i = 0; i < 300; i++) {
    const seed = i * 7919;
    const x = (seed * 13) % W;
    const y = (seed * 17) % H;
    const s = (seed % 3) + 1;
    ctx.fillStyle = (seed % 2) ? '#5d4a35' : '#9a8060';
    ctx.fillRect(x, y, s, s);
  }
  ctx.restore();
}

function drawClue(clue) {
  if (!clue.discovered) return;
  
  // Drop animation
  const age = gameTime - clue.dropDelay;
  if (age < 0) return;
  const dropScale = age < 0.3 ? 0.5 + (age / 0.3) * 0.5 : 1;
  const dropAlpha = age < 0.2 ? age / 0.2 : 1;
  
  ctx.save();
  ctx.globalAlpha = dropAlpha;
  ctx.translate(clue.x, clue.y);
  ctx.rotate(clue.rotation);
  ctx.scale(dropScale, dropScale);
  
  const hw = clue.width / 2;
  const hh = clue.height / 2;
  const isSelected = selectedClue === clue;
  
  // Shadow
  ctx.shadowColor = isSelected ? 'rgba(255,200,0,0.4)' : 'rgba(0,0,0,0.35)';
  ctx.shadowBlur = isSelected ? 15 * scale : 8 * scale;
  ctx.shadowOffsetX = isSelected ? 0 : 3 * scale;
  ctx.shadowOffsetY = isSelected ? 0 : 3 * scale;
  
  // Card background
  const bgCol = clue.type === 'photo' ? '#f0ece0' : 
                clue.type === 'document' ? '#fefef8' :
                clue.type === 'statement' ? '#fffed0' : '#ece5d5';
  ctx.fillStyle = bgCol;
  ctx.fillRect(-hw, -hh, clue.width, clue.height);
  
  // Color accent stripe on left
  ctx.fillStyle = clue.color;
  ctx.fillRect(-hw, -hh, 5 * scale, clue.height);
  
  // Type-specific decoration
  if (clue.type === 'photo') {
    ctx.fillStyle = '#ddd';
    ctx.fillRect(-hw + 7*scale, -hh + 5*scale, clue.width - 14*scale, clue.height * 0.35);
    // Film strip effect
    ctx.fillStyle = '#aaa';
    for (let i = 0; i < 4; i++) {
      ctx.fillRect(-hw + 10*scale + i * 25*scale, -hh + 3*scale, 3*scale, 2*scale);
    }
  } else if (clue.type === 'document') {
    ctx.strokeStyle = 'rgba(150,180,220,0.25)';
    ctx.lineWidth = 0.5;
    for (let ly = -hh + 30*scale; ly < hh - 5*scale; ly += 8*scale) {
      ctx.beginPath(); ctx.moveTo(-hw + 10*scale, ly); ctx.lineTo(hw - 5*scale, ly); ctx.stroke();
    }
  }
  
  // Border
  ctx.shadowColor = 'transparent';
  ctx.strokeStyle = isSelected ? '#ffd700' : clue.color;
  ctx.lineWidth = isSelected ? 2.5 : 1.5;
  ctx.strokeRect(-hw, -hh, clue.width, clue.height);
  
  // Label (emoji + name)
  ctx.fillStyle = '#111';
  ctx.font = `bold ${10 * scale}px 'Courier New', monospace`;
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText(clue.label, -hw + 8*scale, -hh + (clue.type === 'photo' ? clue.height * 0.4 : 6*scale));
  
  // Description text
  ctx.fillStyle = '#333';
  ctx.font = `${10 * scale}px 'Courier New', monospace`;
  const descLines = clue.desc.split('\n');
  const descStartY = clue.type === 'photo' ? clue.height * 0.55 : 20*scale;
  descLines.forEach((line, i) => {
    ctx.fillText(line, -hw + 8*scale, -hh + descStartY + i * 10*scale);
  });
  
  // Pushpin
  if (clue.pinColor) {
    const px = 0, py = -hh - 2*scale;
    ctx.fillStyle = clue.pinColor;
    ctx.beginPath(); ctx.arc(px, py, 5*scale, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.beginPath(); ctx.arc(px - 1.5*scale, py - 1.5*scale, 2*scale, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#777'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px, py + 6*scale); ctx.stroke();
  }
  
  ctx.restore();
}

function drawString(x1, y1, x2, y2, color = '#c41e3a', alpha = 1, thickness = 2) {
  ctx.save();
  ctx.globalAlpha = alpha;
  
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.sqrt(dx*dx + dy*dy);
  const sag = Math.min(25 * scale, dist * 0.08);
  const mx = (x1 + x2) / 2;
  const my = (y1 + y2) / 2 + sag;
  
  // Main string
  ctx.strokeStyle = color;
  ctx.lineWidth = thickness * scale;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.quadraticCurveTo(mx, my, x2, y2);
  ctx.stroke();
  
  // Glow
  ctx.globalAlpha = alpha * 0.15;
  ctx.lineWidth = (thickness + 3) * scale;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.quadraticCurveTo(mx, my, x2, y2);
  ctx.stroke();
  
  ctx.restore();
}

function drawConnections() {
  connections.forEach(conn => {
    const c1 = clues[conn.from];
    const c2 = clues[conn.to];
    if (c1 && c2) {
      const color = conn.correct === true ? '#ffd700' : conn.correct === false ? '#555' : conn.color || '#c41e3a';
      drawString(c1.x, c1.y, c2.x, c2.y, color, 1, conn.correct === true ? 3 : 2);
    }
  });
}

// ============================================================
// GAME LOGIC
// ============================================================
function checkSolution() {
  correctConnections = 0;
  
  connections.forEach(conn => {
    const c1 = clues[conn.from];
    const c2 = clues[conn.to];
    if (!c1 || !c2) { conn.correct = false; return; }
    
    // Check against required connections
    const isRequired = currentCase.requiredConnections.some(rc => {
      return (rc[0] === conn.from && rc[1] === conn.to) || (rc[0] === conn.to && rc[1] === conn.from);
    });
    
    // Also check tag overlap
    const tags1 = new Set(c1.tags);
    const tags2 = new Set(c2.tags);
    const overlap = [...tags1].filter(t => tags2.has(t)).length > 0;
    
    if (isRequired) {
      conn.correct = true;
      correctConnections++;
    } else if (overlap) {
      conn.correct = true; // Related but not required
    } else {
      conn.correct = false;
    }
  });
  
  // Check win
  if (correctConnections >= totalRequired) {
    gameState = 'solved';
    revealAnim = 0;
    sfxSolve();
    
    // Save best time
    const key = `case_${caseIndex}`;
    if (!bestTimes[key] || solveTime < bestTimes[key]) {
      bestTimes[key] = Math.floor(solveTime);
      saveBest();
    }
  }
}

function worldToScreen(wx, wy) {
  return { x: (wx - camera.x) * camera.zoom + W/2, y: (wy - camera.y) * camera.zoom + H/2 };
}
function screenToWorld(sx, sy) {
  return { x: (sx - W/2) / camera.zoom + camera.x, y: (sy - H/2) / camera.zoom + camera.y };
}

function getClueAtPoint(wx, wy) {
  for (let i = clues.length - 1; i >= 0; i--) {
    const c = clues[i];
    if (!c.discovered) continue;
    const dx = wx - c.x, dy = wy - c.y;
    const cos = Math.cos(-c.rotation), sin = Math.sin(-c.rotation);
    const rx = dx * cos - dy * sin, ry = dx * sin + dy * cos;
    if (Math.abs(rx) < c.width/2 && Math.abs(ry) < c.height/2) return c;
  }
  return null;
}

function useHint() {
  if (hints.length === 0) return;
  
  // Find first unconnected required connection
  for (let i = 0; i < hints.length; i++) {
    const h = hints[i];
    const exists = connections.some(c => 
      (c.from === h[0] && c.to === h[1]) || (c.from === h[1] && c.to === h[0])
    );
    if (!exists) {
      // Highlight the two clues
      const c1 = clues[h[0]], c2 = clues[h[1]];
      c1.pinColor = c1.pinColor || nextPinColor();
      c2.pinColor = c2.pinColor || nextPinColor();
      
      // Auto-connect
      const color = nextPinColor();
      connections.push({ from: h[0], to: h[1], correct: null, color });
      sfxHint();
      hintsUsed++;
      
      checkSolution();
      return;
    }
  }
}

function removeConnection(wx, wy) {
  // Find nearest connection to tap point
  for (let i = connections.length - 1; i >= 0; i--) {
    const c = connections[i];
    const c1 = clues[c.from], c2 = clues[c.to];
    const mx = (c1.x + c2.x) / 2, my = (c1.y + c2.y) / 2;
    const dist = Math.sqrt((wx - mx)*(wx - mx) + (wy - my)*(wy - my));
    if (dist < 30 * scale) {
      connections.splice(i, 1);
      sfxRemove();
      // Re-check
      checkSolution();
      return true;
    }
  }
  return false;
}

// ============================================================
// INPUT
// ============================================================
let longPressTimer = null;
let lastTapTime = 0;

function handlePointerDown(x, y) {
  ensureAudio();
  const world = screenToWorld(x, y);
  const clue = getClueAtPoint(world.x, world.y);
  
  if (clue) {
    // Double-tap to start string
    const now = Date.now();
    if (selectedClue === clue && now - lastTapTime < 400) {
      // Start drawing string from this clue
      drawingString = true;
      stringStart = clue;
      stringCurrent = { x, y };
      sfxPin();
      clue.pinColor = clue.pinColor || nextPinColor();
      selectedClue = null;
      lastTapTime = 0;
      
      if (!tutorial.shown) { tutorial.step = 2; tutorial.timer = gameTime; }
      return;
    }
    
    // Select & start drag
    selectedClue = clue;
    lastTapTime = now;
    draggedClue = clue;
    dragOffset = { x: clue.x - world.x, y: clue.y - world.y };
    sfxPaper();
    
    // Move to top
    const idx = clues.indexOf(clue);
    clues.splice(idx, 1);
    clues.push(clue);
    
    if (!tutorial.shown && tutorial.step === 0) { tutorial.step = 1; tutorial.timer = gameTime; }
  } else {
    selectedClue = null;
    // Try removing a connection by tapping near it
    removeConnection(world.x, world.y);
  }
}

function handlePointerMove(x, y) {
  if (draggedClue && !drawingString) {
    const world = screenToWorld(x, y);
    draggedClue.x = world.x + dragOffset.x;
    draggedClue.y = world.y + dragOffset.y;
  }
  if (drawingString) {
    stringCurrent = { x, y };
  }
}

function handlePointerUp(x, y) {
  if (drawingString && stringStart) {
    const world = screenToWorld(x, y);
    const endClue = getClueAtPoint(world.x, world.y);
    
    if (endClue && endClue !== stringStart) {
      const exists = connections.some(c =>
        (c.from === stringStart.id && c.to === endClue.id) ||
        (c.from === endClue.id && c.to === stringStart.id)
      );
      
      if (!exists) {
        const color = stringStart.pinColor || nextPinColor();
        connections.push({ from: stringStart.id, to: endClue.id, correct: null, color });
        sfxString();
        endClue.pinColor = endClue.pinColor || nextPinColor();
        checkSolution();
        
        if (!tutorial.shown) { tutorial.step = 3; tutorial.timer = gameTime; tutorial.shown = true; }
      }
    }
    
    drawingString = false;
    stringStart = null;
  }
  
  draggedClue = null;
}

// Touch events
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (e.touches.length === 1) {
    const t = e.touches[0];
    handlePointerDown(t.clientX, t.clientY);
  } else if (e.touches.length === 2) {
    const t1 = e.touches[0], t2 = e.touches[1];
    pinchDist = Math.sqrt((t2.clientX-t1.clientX)**2 + (t2.clientY-t1.clientY)**2);
    draggedClue = null;
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (e.touches.length === 1) {
    handlePointerMove(e.touches[0].clientX, e.touches[0].clientY);
  } else if (e.touches.length === 2) {
    const t1 = e.touches[0], t2 = e.touches[1];
    const dist = Math.sqrt((t2.clientX-t1.clientX)**2 + (t2.clientY-t1.clientY)**2);
    if (pinchDist > 0) {
      camera.targetZoom = Math.max(0.4, Math.min(2, camera.targetZoom * (dist / pinchDist)));
    }
    pinchDist = dist;
  }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  if (e.touches.length === 0) { handlePointerUp(0, 0); pinchDist = 0; }
});

canvas.addEventListener('mousedown', (e) => handlePointerDown(e.clientX, e.clientY));
canvas.addEventListener('mousemove', (e) => handlePointerMove(e.clientX, e.clientY));
canvas.addEventListener('mouseup', (e) => handlePointerUp(e.clientX, e.clientY));
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  camera.targetZoom = Math.max(0.4, Math.min(2, camera.targetZoom * (e.deltaY > 0 ? 0.9 : 1.1)));
}, { passive: false });

// Menu clicks
canvas.addEventListener('click', (e) => {
  inputEvents.push({ type: 'tap', x: e.clientX, y: e.clientY });
});

// ============================================================
// UI
// ============================================================
function drawUI() {
  ctx.save();
  ctx.setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);
  
  if (gameState === 'menu') {
    drawCorkBG();
    
    // Decorative pins
    for (let i = 0; i < 6; i++) {
      const px = W * 0.15 + Math.sin(i*2.1) * W * 0.3;
      const py = H * 0.15 + i * H * 0.12;
      ctx.fillStyle = pinColors[i];
      ctx.beginPath(); ctx.arc(px, py, 4*scale, 0, Math.PI*2); ctx.fill();
    }
    
    // Title card
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);
    
    // Decorative strings
    for (let i = 0; i < 4; i++) {
      const sx = W * 0.1 + i * W * 0.25;
      drawString(sx, H * 0.1, sx + W * 0.15, H * 0.15, pinColors[i], 0.3, 1.5);
    }
    
    ctx.fillStyle = '#f5f0e6';
    ctx.font = `bold ${36 * scale}px 'Courier New', monospace`;
    ctx.textAlign = 'center';
    ctx.fillText('CONSPIRACY', W/2, H * 0.2);
    ctx.fillText('BOARD', W/2, H * 0.2 + 40*scale);
    
    // Magnifying glass icon
    ctx.font = `${40*scale}px sans-serif`;
    ctx.fillText('ðŸ”', W/2, H * 0.2 - 50*scale);
    
    ctx.font = `${13 * scale}px 'Courier New', monospace`;
    ctx.fillStyle = '#aaa';
    ctx.fillText('Connect the evidence. Solve the mystery.', W/2, H * 0.35);
    
    // Case cards
    const cardW = Math.min(300 * scale, W * 0.8);
    const cardH = 54 * scale;
    const startY = H * 0.36;
    
    caseTemplates.forEach((tmpl, i) => {
      const y = startY + i * (cardH + 8*scale);
      const hovered = false;
      
      // Card background
      ctx.fillStyle = '#463020';
      ctx.strokeStyle = '#8a7055';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.roundRect(W/2 - cardW/2, y - cardH/2, cardW, cardH, 8*scale); ctx.fill(); ctx.stroke();
      
      // Difficulty stars
      const stars = 'â­'.repeat(tmpl.difficulty);
      ctx.font = `${9*scale}px sans-serif`;
      ctx.textAlign = 'right';
      ctx.fillText(stars, W/2 + cardW/2 - 6*scale, y - 6*scale);

      // Title
      ctx.fillStyle = '#f5f0e6';
      ctx.font = `bold ${12 * scale}px 'Courier New', monospace`;
      ctx.textAlign = 'center';
      ctx.fillText(tmpl.title, W/2, y - 2*scale);

      // Type + best time
      ctx.font = `${9 * scale}px 'Courier New', monospace`;
      ctx.fillStyle = '#999';
      const typeEmoji = { murder: 'ðŸ”ª', heist: 'ðŸ’Ž', missing: 'ðŸ‘¤', sabotage: 'ðŸ§ª', fraud: 'ðŸ’°', arson: 'ðŸ”¥' }[tmpl.type] || 'ðŸ“‹';
      const best = bestTimes[`case_${i}`];
      const bestStr = best ? `Best: ${Math.floor(best/60)}:${(best%60).toString().padStart(2,'0')}` : 'New!';
      ctx.fillText(`${typeEmoji} ${tmpl.type.toUpperCase()} â€” ${bestStr}`, W/2, y + 12*scale);
      
      // Hit test
      if (inputEvents.length > 0) {
        const ev = inputEvents[0];
        if (ev.type === 'tap' &&
            ev.x > W/2 - cardW/2 && ev.x < W/2 + cardW/2 &&
            ev.y > y - cardH/2 && ev.y < y + cardH/2) {
          startCase(i);
        }
      }
    });
    
    // How to play
    ctx.fillStyle = '#666';
    ctx.font = `${10*scale}px 'Courier New', monospace`;
    ctx.textAlign = 'center';
    ctx.fillText('Double-tap a clue to start a string', W/2, H - 50*scale);
    ctx.fillText('Drag to another clue to connect them', W/2, H - 35*scale);
    ctx.fillText('Tap a string midpoint to remove it', W/2, H - 20*scale);
    
  } else if (gameState === 'playing') {
    // Top bar
    ctx.fillStyle = 'rgba(50,35,20,0.92)';
    ctx.fillRect(0, 0, W, 52 * scale);
    
    // Back button
    ctx.fillStyle = '#8a7055';
    ctx.beginPath(); ctx.roundRect(6*scale, 6*scale, 50*scale, 36*scale, 6*scale); ctx.fill();
    ctx.fillStyle = '#f5f0e6';
    ctx.font = `${12*scale}px 'Courier New', monospace`;
    ctx.textAlign = 'center';
    ctx.fillText('â† Back', 31*scale, 24*scale);
    
    // Title
    ctx.fillStyle = '#f5f0e6';
    ctx.font = `bold ${12 * scale}px 'Courier New', monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(currentCase.title, W/2, 15*scale);
    
    // Progress
    ctx.font = `${10 * scale}px 'Courier New', monospace`;
    ctx.fillStyle = correctConnections >= totalRequired ? '#4f4' : '#ddd';
    ctx.fillText(`ðŸ”— ${correctConnections}/${totalRequired}`, W/2, 35*scale);
    
    // Timer
    ctx.textAlign = 'right';
    const mins = Math.floor(solveTime / 60);
    const secs = Math.floor(solveTime % 60);
    ctx.fillStyle = '#aaa';
    ctx.fillText(`â± ${mins}:${secs.toString().padStart(2, '0')}`, W - 10*scale, 15*scale);
    
    // Hint count
    const hintsLeft = totalRequired - hintsUsed - correctConnections;
    ctx.fillText(`ðŸ’¡ Hints`, W - 10*scale, 35*scale);
    
    // Bottom bar
    const toolY = H - 50 * scale;
    ctx.fillStyle = 'rgba(50,35,20,0.92)';
    ctx.fillRect(0, toolY, W, 50 * scale);
    
    const btnW = 90 * scale;
    const btnH = 34 * scale;
    const btnY = toolY + 25*scale;
    
    // Hint button
    const hintX = W/2 - 55*scale;
    ctx.fillStyle = '#5a6a3a';
    ctx.beginPath(); ctx.roundRect(hintX - btnW/2, btnY - btnH/2, btnW, btnH, 6*scale); ctx.fill();
    ctx.fillStyle = '#f5f0e6';
    ctx.font = `${11*scale}px 'Courier New', monospace`;
    ctx.textAlign = 'center';
    ctx.fillText('ðŸ’¡ Hint', hintX, btnY);
    
    // Check button
    const checkX = W/2 + 55*scale;
    ctx.fillStyle = correctConnections >= totalRequired ? '#3a7a3a' : '#555540';
    ctx.beginPath(); ctx.roundRect(checkX - btnW/2, btnY - btnH/2, btnW, btnH, 6*scale); ctx.fill();
    ctx.fillStyle = '#f5f0e6';
    ctx.fillText('âœ… Check', checkX, btnY);
    
    // Button hit tests
    for (const ev of inputEvents) {
      if (ev.type !== 'tap') continue;
      // Back
      if (ev.x < 60*scale && ev.y < 50*scale) { gameState = 'menu'; sfxClick(); }
      // Hint
      if (Math.abs(ev.x - hintX) < btnW/2 && Math.abs(ev.y - btnY) < btnH/2) { useHint(); }
      // Check
      if (Math.abs(ev.x - checkX) < btnW/2 && Math.abs(ev.y - btnY) < btnH/2) { checkSolution(); sfxClick(); }
    }
    
    // Tutorial overlay
    if (!tutorial.shown && tutorial.step <= 2) {
      ctx.save();
      ctx.globalAlpha = 0.7 + Math.sin(gameTime * 3) * 0.2;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.font = `${12*scale}px 'Courier New', monospace`;
      ctx.textAlign = 'center';
      ctx.fillStyle = '#ffd700';
      
      if (tutorial.step === 0) {
        ctx.fillText('ðŸ“Œ Tap a clue to select it', W/2, H/2 + 80*scale);
        ctx.fillText('ðŸ“Œ Double-tap to start a string', W/2, H/2 + 100*scale);
      } else if (tutorial.step === 1) {
        ctx.fillText('ðŸ“Œ Double-tap this clue to start connecting!', W/2, H/2 + 80*scale);
      } else if (tutorial.step === 2) {
        ctx.fillText('ðŸ“Œ Now drag to another clue to connect!', W/2, H/2 + 80*scale);
      }
      ctx.restore();
    }
    
  } else if (gameState === 'solved') {
    // Victory overlay
    const alpha = Math.min(1, revealAnim * 1.5);
    ctx.fillStyle = `rgba(0,0,0,${alpha * 0.8})`;
    ctx.fillRect(0, 0, W, H);
    
    if (revealAnim > 0.5) {
      // Confetti strings
      for (let i = 0; i < 6; i++) {
        const sx = W * 0.15 + i * W * 0.14;
        const sy = H * 0.1 + Math.sin(gameTime + i) * 20;
        const ex = W * 0.2 + i * W * 0.12;
        const ey = H * 0.25 + Math.cos(gameTime * 1.3 + i) * 15;
        drawString(sx, sy, ex, ey, pinColors[i], 0.4, 1.5);
      }
      
      ctx.fillStyle = '#ffd700';
      ctx.font = `bold ${34 * scale}px 'Courier New', monospace`;
      ctx.textAlign = 'center';
      ctx.fillText('ðŸ” CASE SOLVED!', W/2, H * 0.3);
      
      ctx.fillStyle = '#f5f0e6';
      ctx.font = `${16 * scale}px 'Courier New', monospace`;
      ctx.fillText(`Time: ${Math.floor(solveTime / 60)}:${(Math.floor(solveTime % 60)).toString().padStart(2, '0')}`, W/2, H * 0.42);
      ctx.fillText(`Hints used: ${hintsUsed}`, W/2, H * 0.48);
      
      // Rating
      let rating = 'â­', rMsg = 'Good work!';
      if (hintsUsed === 0 && solveTime < 120) { rating = 'â­â­â­'; rMsg = 'Brilliant detective!'; }
      else if (hintsUsed <= 1 && solveTime < 180) { rating = 'â­â­'; rMsg = 'Sharp mind!'; }
      ctx.fillText(`${rating} ${rMsg}`, W/2, H * 0.55);
      
      // Buttons
      const btnW2 = 200 * scale;
      const btnH2 = 50 * scale;
      
      // Next case
      const nextY = H * 0.68;
      ctx.fillStyle = '#3a7a3a';
      ctx.beginPath(); ctx.roundRect(W/2 - btnW2/2, nextY - btnH2/2, btnW2, btnH2, 8*scale); ctx.fill();
      ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.roundRect(W/2 - btnW2/2, nextY - btnH2/2, btnW2, btnH2, 8*scale); ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${14*scale}px 'Courier New', monospace`;
      ctx.fillText('Next Case â†’', W/2, nextY);
      
      // Menu
      const menuY = nextY + 65*scale;
      ctx.fillStyle = '#463020';
      ctx.beginPath(); ctx.roundRect(W/2 - btnW2/2, menuY - btnH2/2, btnW2, btnH2, 8*scale); ctx.fill();
      ctx.strokeStyle = '#8a7055'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.roundRect(W/2 - btnW2/2, menuY - btnH2/2, btnW2, btnH2, 8*scale); ctx.stroke();
      ctx.fillStyle = '#f5f0e6';
      ctx.fillText('Case Select', W/2, menuY);
      
      // Hit tests
      for (const ev of inputEvents) {
        if (ev.type !== 'tap') continue;
        if (ev.x > W/2 - btnW2/2 && ev.x < W/2 + btnW2/2) {
          if (Math.abs(ev.y - nextY) < btnH2/2) { startCase((caseIndex + 1) % caseTemplates.length); sfxClick(); }
          if (Math.abs(ev.y - menuY) < btnH2/2) { gameState = 'menu'; sfxClick(); }
        }
      }
    }
  }
  
  ctx.restore();
}

// ============================================================
// GAME LOOP
// ============================================================
function gameLoop(time) {
  deltaTime = Math.min((time - lastTime) / 1000, 0.1);
  lastTime = time;
  gameTime = time * 0.001;
  
  if (gameState === 'playing') solveTime += deltaTime;
  if (gameState === 'solved') revealAnim += deltaTime;
  
  camera.zoom += (camera.targetZoom - camera.zoom) * (1 - Math.pow(0.9, deltaTime * 60));
  if (shakeAmount > 0.3) shakeAmount *= 0.9; else shakeAmount = 0;
  
  ctx.save();
  
  drawCorkBG();
  
  if (gameState !== 'menu') {
    ctx.translate(W/2, H/2);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-camera.x, -camera.y);
    
    if (shakeAmount > 0.3) ctx.translate((Math.random()-0.5)*shakeAmount, (Math.random()-0.5)*shakeAmount);
    
    drawConnections();
    
    if (drawingString && stringStart) {
      const startScreen = worldToScreen(stringStart.x, stringStart.y);
      ctx.save();
      ctx.resetTransform();
      const dpr = window.devicePixelRatio || 1;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      drawString(startScreen.x, startScreen.y, stringCurrent.x, stringCurrent.y, stringStart.pinColor || '#c41e3a', 0.6, 2);
      ctx.restore();
    }
    
    clues.forEach(clue => drawClue(clue));
  }
  
  ctx.restore();
  
  drawUI();
  inputEvents = [];
  
  requestAnimationFrame(gameLoop);
}

gameState = 'menu';
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
