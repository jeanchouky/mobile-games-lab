<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>Tower Defense</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;touch-action:none;-webkit-user-select:none;user-select:none}
body{background:#1a1a2e;overflow:hidden;font-family:-apple-system,system-ui,sans-serif;color:#fff}
canvas{display:block}
#hud{position:absolute;top:0;left:0;width:100%;padding:6px 10px;display:flex;justify-content:space-between;align-items:center;z-index:10;background:rgba(0,0,0,0.6);backdrop-filter:blur(8px);font-size:12px;font-weight:700}
.hud-item{display:flex;align-items:center;gap:3px}
#tower-panel{position:absolute;bottom:0;left:0;width:100%;display:flex;justify-content:center;gap:6px;padding:8px;z-index:10;background:rgba(0,0,0,0.6);backdrop-filter:blur(8px);overflow-x:auto}
.tower-btn{width:54px;min-width:54px;height:62px;border-radius:10px;border:2px solid rgba(255,255,255,0.2);background:rgba(255,255,255,0.05);display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;transition:all .15s}
.tower-btn.selected{border-color:#ffd93d;background:rgba(255,217,61,0.15);box-shadow:0 0 15px rgba(255,217,61,0.3)}
.tower-btn .icon{font-size:18px}
.tower-btn .cost{font-size:9px;color:#ffd93d;font-weight:700}
.tower-btn .name{font-size:7px;color:#aaa;text-transform:uppercase;letter-spacing:0.3px}
.tower-btn.cant-afford{opacity:0.4}
#menu-screen{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(26,26,46,0.97);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:30;padding:20px}
#menu-screen h1{font-size:32px;margin-bottom:4px;background:linear-gradient(135deg,#ffd93d,#e94560);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
#menu-screen p{color:#888;margin-bottom:16px;font-size:12px;text-align:center}
#menu-screen .section-title{color:#aaa;font-size:11px;text-transform:uppercase;letter-spacing:1px;margin:10px 0 6px}
.menu-row{display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap;justify-content:center}
.menu-btn{background:rgba(255,255,255,0.08);border:2px solid rgba(255,255,255,0.15);color:#fff;padding:10px 16px;border-radius:12px;font-size:13px;font-weight:700;cursor:pointer;transition:all .15s;min-width:80px;text-align:center}
.menu-btn:active{transform:scale(0.95)}
.menu-btn.sel{border-color:#ffd93d;background:rgba(255,217,61,0.15)}
.start-btn{background:linear-gradient(135deg,#e94560,#c23152);border:none;color:#fff;padding:14px 40px;border-radius:50px;font-size:16px;font-weight:700;cursor:pointer;margin-top:16px}
.start-btn:active{transform:scale(0.95)}
.hidden{display:none!important}
#wave-banner{position:absolute;top:45%;left:50%;transform:translate(-50%,-50%);font-size:26px;font-weight:900;pointer-events:none;z-index:10;opacity:0;text-shadow:0 0 20px rgba(233,69,96,0.8);transition:opacity .3s}
#game-over{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(26,26,46,0.94);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:25;text-align:center;padding:20px;overflow-y:auto}
#game-over h2{font-size:26px;margin-bottom:6px}
#game-over .stat{font-size:14px;color:#888;margin:3px}
#game-over .score-big{font-size:42px;font-weight:900;background:linear-gradient(135deg,#ffd93d,#e94560);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;margin:6px 0}
#game-over .mvp{color:#ffd93d;font-size:13px;margin:4px 0}
#game-over button{background:linear-gradient(135deg,#4d96ff,#6bcb77);border:none;color:#fff;padding:12px 32px;border-radius:50px;font-size:15px;font-weight:700;margin-top:10px;cursor:pointer}
#upgrade-panel{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(20,20,40,0.95);border:1px solid rgba(255,255,255,0.1);border-radius:16px;padding:14px;z-index:15;min-width:240px;max-width:300px;text-align:center;backdrop-filter:blur(10px)}
#upgrade-panel h3{margin-bottom:4px;font-size:14px}
#upgrade-panel p{font-size:10px;color:#888;margin:3px 0}
#upgrade-panel button{margin:3px;padding:7px 12px;border:none;border-radius:8px;font-size:11px;font-weight:700;cursor:pointer;color:#fff;min-height:32px}
#upgrade-panel .up-btn{background:#4d96ff}
#upgrade-panel .path-btn{background:#6bcb77;display:block;width:100%;margin:4px 0;padding:8px;text-align:left;border-radius:8px}
#upgrade-panel .path-btn:active{opacity:0.8}
#upgrade-panel .sell-btn{background:#e94560}
#upgrade-panel .close-btn{background:rgba(255,255,255,0.1)}
#upgrade-panel .target-btn{background:rgba(255,255,255,0.1);font-size:10px;padding:4px 8px}
#wave-preview{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(20,20,40,0.95);border:1px solid rgba(255,255,255,0.15);border-radius:16px;padding:16px;z-index:18;min-width:260px;max-width:320px;text-align:center;backdrop-filter:blur(10px)}
#wave-preview h3{margin-bottom:8px;font-size:15px}
#wave-preview .enemy-list{font-size:11px;color:#aaa;margin:6px 0;max-height:120px;overflow-y:auto}
#wave-preview .enemy-row{display:flex;justify-content:space-between;padding:3px 0;border-bottom:1px solid rgba(255,255,255,0.05)}
#wave-preview .send-btn{background:linear-gradient(135deg,#4d96ff,#6bcb77);border:none;color:#fff;padding:10px 24px;border-radius:50px;font-size:14px;font-weight:700;cursor:pointer;margin-top:8px}
#wave-preview .countdown{font-size:12px;color:#ffd93d;margin-top:6px}
#abilities-bar{position:absolute;bottom:80px;left:50%;transform:translateX(-50%);display:flex;gap:6px;z-index:10}
.ability-btn{width:44px;height:44px;border-radius:10px;border:2px solid rgba(255,255,255,0.2);background:rgba(255,255,255,0.08);display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:18px;position:relative;transition:all .15s}
.ability-btn.on-cd{opacity:0.4;pointer-events:none}
.ability-btn .cd-overlay{position:absolute;bottom:0;left:0;width:100%;background:rgba(0,0,0,0.7);border-radius:0 0 8px 8px;font-size:8px;text-align:center;color:#ffd93d;font-weight:700}
#boss-hp-bar{position:absolute;top:36px;left:50%;transform:translateX(-50%);width:60%;max-width:300px;height:14px;background:rgba(0,0,0,0.5);border-radius:7px;z-index:10;overflow:hidden;pointer-events:none}
#boss-hp-fill{height:100%;background:linear-gradient(90deg,#e94560,#ff6b6b);border-radius:7px;transition:width .2s}
#boss-hp-text{position:absolute;top:0;left:50%;transform:translateX(-50%);font-size:9px;font-weight:700;line-height:14px;text-shadow:0 1px 2px #000}
#wave-progress{position:absolute;top:30px;right:10px;width:80px;height:6px;background:rgba(0,0,0,0.4);border-radius:3px;z-index:10;overflow:hidden}
#wave-progress-fill{height:100%;background:#4d96ff;border-radius:3px;transition:width .3s}
#stats-display{position:absolute;top:30px;left:10px;font-size:9px;color:rgba(255,255,255,0.5);z-index:10;pointer-events:none}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
  <div class="hud-item">&#10084; <span id="lives">20</span></div>
  <div class="hud-item">&#128176; <span id="gold">100</span></div>
  <div class="hud-item">&#127754; <span id="wave-num">0</span>/<span id="max-wave">30</span></div>
  <div class="hud-item"><button id="speed-btn" style="background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:4px 8px;border-radius:6px;font-size:11px;cursor:pointer;min-height:28px">1x</button></div>
</div>
<div id="tower-panel"></div>
<div id="wave-banner"></div>
<div id="boss-hp-bar" class="hidden"><div id="boss-hp-fill" style="width:100%"></div><div id="boss-hp-text"></div></div>
<div id="wave-progress" class="hidden"><div id="wave-progress-fill" style="width:100%"></div></div>
<div id="stats-display"></div>
<div id="abilities-bar" class="hidden"></div>
<div id="menu-screen">
  <h1>Tower Defense</h1>
  <p>7 tower types with branching upgrades, special abilities,<br>30+ waves with bosses. Survive or go endless!</p>
  <div class="section-title">Difficulty</div>
  <div class="menu-row" id="diff-row"></div>
  <div class="section-title">Map</div>
  <div class="menu-row" id="map-row"></div>
  <button class="start-btn" id="start-btn">Start Game</button>
</div>
<div id="game-over" class="hidden"></div>
<div id="upgrade-panel" class="hidden"></div>
<div id="wave-preview" class="hidden"></div>
<script>
const C=document.getElementById('c'),Ctx=C.getContext('2d');
let W,H,dpr,cellSize;
const GRID_COLS=12,GRID_ROWS=18;
let grid=[],path=[],pathPixels=[];
let towers=[],enemies=[],projectiles=[],particles=[],floatingTexts=[],lightningChains=[];
let gold=100,lives=20,wave=0,maxWaves=30,gameActive=false,gamePaused=false;
let selectedType=null,selectedTower=null;
let spawnTimer=0,waveEnemies=0,waveSpawned=0,betweenWaves=true,waveDelay=3;
let shakeX=0,shakeY=0,shakeMag=0;
let gameSpeed=1;
let totalKills=0,totalGoldEarned=0,totalDamageDealt=0;
let mouseCell=null,mouseX=0,mouseY=0;
let difficulty='normal',mapChoice='meadow';
let wavePreviewShown=false,waveCountdown=0;
let activeBoss=null;
let repairUsed=false;
let endlessMode=false;

let abilityCooldowns={fire:0,freeze:0,goldrush:0,repair:0};
let abilityDurations={freeze:0,goldrush:0};
const ABILITY_MAX_CD={fire:60,freeze:45,goldrush:90,repair:120};

let audioCtx;
function ensureAudio(){if(!audioCtx)audioCtx=new(window.AudioContext||window.webkitAudioContext)();if(audioCtx.state==='suspended')audioCtx.resume();return audioCtx}
function snd(f,d,t='sine',v=0.08){try{let a=ensureAudio();const o=a.createOscillator(),g=a.createGain();o.type=t;o.frequency.value=f;g.gain.setValueAtTime(v,a.currentTime);g.gain.exponentialRampToValueAtTime(0.001,a.currentTime+d);o.connect(g);g.connect(a.destination);o.start();o.stop(a.currentTime+d)}catch(e){}}

const DIFFICULTIES={
  easy:{lives:30,gold:150,waveSpeedMult:0.8,label:'Easy',desc:'30 lives, slow'},
  normal:{lives:20,gold:100,waveSpeedMult:1,label:'Normal',desc:'20 lives'},
  hard:{lives:10,gold:80,waveSpeedMult:1.3,label:'Hard',desc:'10 lives, fast'},
  endless:{lives:20,gold:100,waveSpeedMult:1,label:'Endless',desc:'Never ends'}
};

const MAP_DEFS={
  meadow:{label:'Meadow',desc:'S-curve, beginner',color:'#4a7c59'},
  crossroads:{label:'Crossroads',desc:'Split path, mid',color:'#8b6914'},
  fortress:{label:'Fortress',desc:'Spiral, advanced',color:'#5a5a7a'}
};

const TOWER_TYPES={
  arrow:{cost:25,range:3,rate:0.8,dmg:10,color:'#ffd93d',name:'Arrow',icon:'\u{1F3F9}',desc:'Fast shooter',
    pathA:{name:'Triple Shot',desc:'Fires 3 arrows in spread',icon:'\u{1F3AF}'},
    pathB:{name:'Piercing',desc:'Arrows pass through enemies',icon:'\u{27A1}'}},
  freeze:{cost:40,range:2.5,rate:1.2,dmg:5,color:'#74b9ff',name:'Freeze',icon:'\u{2744}',slow:0.5,desc:'Slows enemies',
    pathA:{name:'Blizzard',desc:'AoE slow in range',icon:'\u{1F328}'},
    pathB:{name:'Ice Wall',desc:'Blocks path for 2s',icon:'\u{1F9CA}'}},
  splash:{cost:50,range:2,rate:1.5,dmg:15,color:'#e94560',name:'Splash',icon:'\u{1F4A5}',splash:1.5,desc:'Area damage',
    pathA:{name:'Napalm',desc:'Leaves burning ground',icon:'\u{1F525}'},
    pathB:{name:'Shockwave',desc:'Knocks enemies back',icon:'\u{1F4A8}'}},
  laser:{cost:60,range:3.5,rate:0.5,dmg:8,color:'#ff6b6b',name:'Laser',icon:'\u{1F534}',pierce:true,desc:'Pierces through',
    pathA:{name:'Death Ray',desc:'Continuous beam, +DMG',icon:'\u{2622}'},
    pathB:{name:'Scatter',desc:'Hits 3 targets at once',icon:'\u{2728}'}},
  poison:{cost:45,range:2.5,rate:1.8,dmg:3,color:'#6bcb77',name:'Poison',icon:'\u{2623}',dot:8,dotDur:3,desc:'Damage over time',
    pathA:{name:'Plague',desc:'Poison spreads to nearby',icon:'\u{1F9A0}'},
    pathB:{name:'Venom',desc:'Deals % max HP damage',icon:'\u{1F40D}'}},
  lightning:{cost:70,range:3,rate:1.4,dmg:20,color:'#a29bfe',name:'Chain',icon:'\u{26A1}',chain:3,desc:'Chains to 3',
    pathA:{name:'Tesla Coil',desc:'Auto-zaps nearby enemies',icon:'\u{1F50C}'},
    pathB:{name:'Storm',desc:'AoE lightning strikes',icon:'\u{26C8}'}},
  sniper:{cost:80,range:6,rate:2.5,dmg:80,color:'#dfe6e9',name:'Sniper',icon:'\u{1F3AF}',canHitFlying:true,desc:'Long range, anti-air',
    pathA:{name:'Railgun',desc:'Execute below 15% HP',icon:'\u{1F52B}'},
    pathB:{name:'Overwatch',desc:'+Range, +Crit chance',icon:'\u{1F441}'}}
};

const TARGETING_MODES=['first','last','strongest','weakest'];

function resize(){
  dpr=window.devicePixelRatio||1;W=window.innerWidth;H=window.innerHeight;
  C.width=W*dpr;C.height=H*dpr;C.style.width=W+'px';C.style.height=H+'px';
  Ctx.setTransform(dpr,0,0,dpr,0,0);
  cellSize=Math.min(W/GRID_COLS,(H-110)/GRID_ROWS);
  cachePathPixels();
}

function cachePathPixels(){
  pathPixels=[];
  for(let i=0;i<path.length;i++){
    pathPixels.push(cellToPixel(path[i].c,path[i].r));
  }
}

function generatePath(){
  path=[];grid=[];
  for(let r=0;r<GRID_ROWS;r++){grid[r]=[];for(let c=0;c<GRID_COLS;c++)grid[r][c]=0}
  if(mapChoice==='meadow') generateMeadow();
  else if(mapChoice==='crossroads') generateCrossroads();
  else generateFortress();
  for(let p of path) grid[p.r][p.c]=1;
  cachePathPixels();
}

function generateMeadow(){
  let c=0,r=0;
  path.push({c,r});
  let dir=1;
  while(r<GRID_ROWS-1){
    let target=dir===1?GRID_COLS-2:1;
    while(c!==target){c+=dir;path.push({c,r})}
    let down=Math.min(3,GRID_ROWS-1-r);
    for(let i=0;i<down;i++){r++;path.push({c,r})}
    dir*=-1;
  }
}

function generateCrossroads(){
  let c=0,r=0;
  path.push({c,r});
  while(c<5){c++;path.push({c,r})}
  for(let i=0;i<4;i++){r++;path.push({c,r})}
  while(c<GRID_COLS-2){c++;path.push({c,r})}
  for(let i=0;i<3;i++){r++;path.push({c,r})}
  while(c>6){c--;path.push({c,r})}
  for(let i=0;i<3;i++){r++;path.push({c,r})}
  while(c>1){c--;path.push({c,r})}
  for(let i=0;i<3;i++){r++;path.push({c,r})}
  while(c<GRID_COLS-2){c++;path.push({c,r})}
  while(r<GRID_ROWS-1){r++;path.push({c,r})}
}

function generateFortress(){
  let c=0,r=0;
  path.push({c,r});
  while(c<GRID_COLS-2){c++;path.push({c,r})}
  while(r<GRID_ROWS-2){r++;path.push({c,r})}
  while(c>1){c--;path.push({c,r})}
  while(r>3){r--;path.push({c,r})}
  while(c<GRID_COLS-4){c++;path.push({c,r})}
  while(r<GRID_ROWS-5){r++;path.push({c,r})}
  while(c>3){c--;path.push({c,r})}
  while(r<GRID_ROWS-1){r++;path.push({c,r})}
}

function cellToPixel(c,r){
  let ox=(W-GRID_COLS*cellSize)/2;
  return{x:ox+c*cellSize+cellSize/2,y:40+r*cellSize+cellSize/2};
}

function pixelToCell(px,py){
  let ox=(W-GRID_COLS*cellSize)/2;
  let c=Math.floor((px-ox)/cellSize);
  let r=Math.floor((py-40)/cellSize);
  if(c<0||c>=GRID_COLS||r<0||r>=GRID_ROWS)return null;
  return{c,r};
}

function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y)}

function buildTowerPanel(){
  let panel=document.getElementById('tower-panel');
  panel.innerHTML='';
  for(let key in TOWER_TYPES){
    let t=TOWER_TYPES[key];
    let div=document.createElement('div');
    div.className='tower-btn';
    div.dataset.type=key;
    div.innerHTML=`<div class="icon">${t.icon}</div><div class="cost">$${t.cost}</div><div class="name">${t.name}</div>`;
    div.addEventListener('click',()=>selectTower(key));
    div.addEventListener('touchstart',e=>{e.preventDefault();selectTower(key)});
    panel.appendChild(div);
  }
}

function updateTowerBtnStates(){
  document.querySelectorAll('.tower-btn').forEach(b=>{
    let type=b.dataset.type;
    let cost=TOWER_TYPES[type].cost;
    b.classList.toggle('cant-afford',gold<cost);
    b.classList.toggle('selected',type===selectedType);
  });
}

function selectTower(type){
  ensureAudio();
  if(selectedType===type){selectedType=null}else{selectedType=type;closeUpgrade()}
  updateTowerBtnStates();
}

function buildAbilitiesBar(){
  let bar=document.getElementById('abilities-bar');
  bar.innerHTML='';
  const abs=[
    {id:'fire',icon:'\u{1F525}',tip:'Rain of Fire'},
    {id:'freeze',icon:'\u{2744}',tip:'Freeze All'},
    {id:'goldrush',icon:'\u{1F4B0}',tip:'Gold Rush'},
    {id:'repair',icon:'\u{1F6E1}',tip:'Repair +5 Lives'}
  ];
  for(let ab of abs){
    let btn=document.createElement('div');
    btn.className='ability-btn';
    btn.id='ab-'+ab.id;
    btn.innerHTML=ab.icon;
    btn.title=ab.tip;
    btn.addEventListener('click',()=>useAbility(ab.id));
    btn.addEventListener('touchstart',e=>{e.preventDefault();useAbility(ab.id)});
    bar.appendChild(btn);
  }
  bar.classList.remove('hidden');
}

function useAbility(id){
  if(!gameActive||gamePaused)return;
  if(abilityCooldowns[id]>0)return;
  if(id==='repair'&&repairUsed)return;
  ensureAudio();
  abilityCooldowns[id]=ABILITY_MAX_CD[id];
  if(id==='fire'){
    snd(200,0.4,'sawtooth',0.1);
    for(let e of enemies){
      let dmg=30+wave*10;
      e.hp-=dmg;
      totalDamageDealt+=dmg;
      let pos=getEnemyPos(e);
      for(let j=0;j<5;j++){
        let a=Math.random()*Math.PI*2;
        particles.push({x:pos.x,y:pos.y,vx:Math.cos(a)*3,vy:Math.sin(a)*3-2,life:0.8,color:'#ff6b6b',size:4});
      }
      spawnFloatingText(pos.x,pos.y,'-'+dmg,'#ff6b6b');
    }
    shakeMag=8;
  }else if(id==='freeze'){
    snd(1200,0.3,'sine',0.08);
    abilityDurations.freeze=5;
    for(let e of enemies){e.slow=5}
  }else if(id==='goldrush'){
    snd(600,0.2,'triangle',0.08);
    abilityDurations.goldrush=10;
  }else if(id==='repair'){
    snd(400,0.3,'sine',0.1);
    let maxLives=DIFFICULTIES[difficulty].lives;
    lives=Math.min(lives+5,maxLives);
    repairUsed=true;
    updateHUD();
    spawnFloatingText(W/2,H/2,'+5 Lives','#6bcb77');
  }
}

function updateAbilitiesUI(dt){
  for(let id in abilityCooldowns){
    if(abilityCooldowns[id]>0)abilityCooldowns[id]=Math.max(0,abilityCooldowns[id]-dt);
  }
  for(let id in abilityDurations){
    if(abilityDurations[id]>0)abilityDurations[id]=Math.max(0,abilityDurations[id]-dt);
  }
  const abs=['fire','freeze','goldrush','repair'];
  for(let id of abs){
    let btn=document.getElementById('ab-'+id);
    if(!btn)continue;
    let cd=abilityCooldowns[id];
    let onCd=cd>0||(id==='repair'&&repairUsed);
    btn.classList.toggle('on-cd',onCd);
    let existing=btn.querySelector('.cd-overlay');
    if(onCd&&cd>0){
      if(!existing){existing=document.createElement('div');existing.className='cd-overlay';btn.appendChild(existing)}
      existing.textContent=Math.ceil(cd)+'s';
    }else if(existing){existing.remove()}
    if(id==='repair'&&repairUsed){
      btn.style.opacity='0.3';
      btn.style.pointerEvents='none';
    }
  }
}

function spawnFloatingText(x,y,text,color){
  floatingTexts.push({x,y,text,color,life:1.2,vy:-1.5});
}

C.addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY;mouseCell=pixelToCell(e.clientX,e.clientY)});
C.addEventListener('touchmove',e=>{e.preventDefault();let t=e.touches[0];mouseX=t.clientX;mouseY=t.clientY;mouseCell=pixelToCell(t.clientX,t.clientY)},{passive:false});

C.addEventListener('click',handleCanvasClick);
C.addEventListener('touchstart',e=>{
  e.preventDefault();
  let t=e.touches[0];
  mouseX=t.clientX;mouseY=t.clientY;
  handleCanvasClick({clientX:t.clientX,clientY:t.clientY});
},{passive:false});

function handleCanvasClick(e){
  if(!gameActive||gamePaused)return;
  ensureAudio();
  let cell=pixelToCell(e.clientX,e.clientY);
  if(!cell)return;
  let existing=towers.find(t=>t.c===cell.c&&t.r===cell.r);
  if(existing&&!selectedType){
    selectedTower=existing;
    showUpgrade(existing);
    return;
  }
  if(!selectedType)return;
  if(grid[cell.r][cell.c]!==0)return;
  let cost=TOWER_TYPES[selectedType].cost;
  if(gold<cost)return;
  gold-=cost;
  let tt=TOWER_TYPES[selectedType];
  let t={...tt,type:selectedType,c:cell.c,r:cell.r,level:1,cooldown:0,kills:0,totalDmg:0,
    targeting:'first',upgradePath:null,angle:0,
    teslaTimer:0,napalmZones:[],iceWalls:[]};
  towers.push(t);
  grid[cell.r][cell.c]=2;
  snd(600,0.1);
  updateHUD();
  updateTowerBtnStates();
}

function showUpgrade(t){
  let panel=document.getElementById('upgrade-panel');
  panel.classList.remove('hidden');
  let html=`<h3>${t.name}${t.upgradePath?' ('+t.upgradePath+')':''}</h3>`;
  html+=`<p>Level ${t.level}/3 | Kills: ${t.kills} | DMG: ${Math.floor(t.totalDmg)}</p>`;
  html+=`<p>ATK: ${t.dmg} | Range: ${t.range.toFixed(1)} | Rate: ${t.rate.toFixed(1)}s</p>`;
  let targetLabel=t.targeting.charAt(0).toUpperCase()+t.targeting.slice(1);
  html+=`<button class="target-btn" id="target-cycle">Target: ${targetLabel}</button>`;
  if(t.level===1){
    let cost=Math.floor(t.cost*0.8);
    html+=`<p style="color:#ffd93d;margin-top:6px">Choose upgrade path ($${cost}):</p>`;
    let tt=TOWER_TYPES[t.type];
    html+=`<button class="path-btn" id="path-a-btn">${tt.pathA.icon} <b>${tt.pathA.name}</b><br><span style="font-size:10px;font-weight:400">${tt.pathA.desc}</span></button>`;
    html+=`<button class="path-btn" id="path-b-btn">${tt.pathB.icon} <b>${tt.pathB.name}</b><br><span style="font-size:10px;font-weight:400">${tt.pathB.desc}</span></button>`;
  }else if(t.level===2){
    let cost=Math.floor(t.cost*1.6);
    html+=`<button class="up-btn" id="up-btn">Upgrade Lv3 $${cost}</button>`;
  }else{
    html+=`<p style="color:#ffd93d">MAX LEVEL</p>`;
  }
  let sellVal=Math.floor(t.cost*(0.5+t.level*0.15));
  html+=`<br><button class="sell-btn" id="sell-btn">Sell $${sellVal}</button>`;
  html+=` <button class="close-btn" id="close-btn">X</button>`;
  panel.innerHTML=html;
  document.getElementById('target-cycle').addEventListener('click',()=>{
    let idx=TARGETING_MODES.indexOf(t.targeting);
    t.targeting=TARGETING_MODES[(idx+1)%TARGETING_MODES.length];
    showUpgrade(t);
  });
  if(t.level===1){
    document.getElementById('path-a-btn').addEventListener('click',()=>upgradePathA());
    document.getElementById('path-b-btn').addEventListener('click',()=>upgradePathB());
  }else if(t.level===2){
    document.getElementById('up-btn').addEventListener('click',()=>upgradeLv3());
  }
  document.getElementById('sell-btn').addEventListener('click',()=>sellTower());
  document.getElementById('close-btn').addEventListener('click',()=>closeUpgrade());
}

function upgradePathA(){
  if(!selectedTower)return;
  let cost=Math.floor(selectedTower.cost*0.8);
  if(gold<cost)return;
  gold-=cost;
  selectedTower.level=2;
  selectedTower.upgradePath='A';
  applyUpgradeStats(selectedTower);
  snd(800,0.15);
  showUpgrade(selectedTower);
  updateHUD();
}

function upgradePathB(){
  if(!selectedTower)return;
  let cost=Math.floor(selectedTower.cost*0.8);
  if(gold<cost)return;
  gold-=cost;
  selectedTower.level=2;
  selectedTower.upgradePath='B';
  applyUpgradeStats(selectedTower);
  snd(800,0.15);
  showUpgrade(selectedTower);
  updateHUD();
}

function upgradeLv3(){
  if(!selectedTower||selectedTower.level!==2)return;
  let cost=Math.floor(selectedTower.cost*1.6);
  if(gold<cost)return;
  gold-=cost;
  selectedTower.level=3;
  applyUpgradeStats(selectedTower);
  snd(900,0.2);
  showUpgrade(selectedTower);
  updateHUD();
}

function applyUpgradeStats(t){
  let base=TOWER_TYPES[t.type];
  let lvlMult=t.level===2?1.6:2.5;
  t.dmg=Math.floor(base.dmg*lvlMult);
  t.range=base.range+t.level*0.3;
  t.rate=base.rate*Math.pow(0.85,t.level-1);
  if(base.dot)t.dot=Math.floor(base.dot*lvlMult);
  if(base.chain)t.chain=(base.chain||3)+t.level;
  if(base.splash)t.splash=base.splash+t.level*0.3;
  if(t.type==='sniper'){t.canHitFlying=true}
  if(t.type==='arrow'&&t.upgradePath==='A'){t.tripleShot=true}
  if(t.type==='arrow'&&t.upgradePath==='B'){t.piercingArrow=true}
  if(t.type==='freeze'&&t.upgradePath==='A'){t.blizzard=true;t.range+=0.5}
  if(t.type==='freeze'&&t.upgradePath==='B'){t.iceWall_enabled=true}
  if(t.type==='splash'&&t.upgradePath==='A'){t.napalm=true}
  if(t.type==='splash'&&t.upgradePath==='B'){t.knockback=true}
  if(t.type==='laser'&&t.upgradePath==='A'){t.deathRay=true;t.dmg=Math.floor(t.dmg*1.5)}
  if(t.type==='laser'&&t.upgradePath==='B'){t.scatter=true}
  if(t.type==='poison'&&t.upgradePath==='A'){t.plague=true}
  if(t.type==='poison'&&t.upgradePath==='B'){t.venom=true}
  if(t.type==='lightning'&&t.upgradePath==='A'){t.teslaCoil=true}
  if(t.type==='lightning'&&t.upgradePath==='B'){t.storm=true;t.range+=1}
  if(t.type==='sniper'&&t.upgradePath==='A'){t.railgun=true}
  if(t.type==='sniper'&&t.upgradePath==='B'){t.overwatch=true;t.range+=2;t.critChance=0.3}
}

function sellTower(){
  if(!selectedTower)return;
  let val=Math.floor(selectedTower.cost*(0.5+selectedTower.level*0.15));
  gold+=val;
  grid[selectedTower.r][selectedTower.c]=0;
  towers=towers.filter(t=>t!==selectedTower);
  closeUpgrade();
  updateHUD();
}

function closeUpgrade(){
  document.getElementById('upgrade-panel').classList.add('hidden');
  selectedTower=null;
}

function isBossWave(w){return w%5===0&&w>0}

function getWaveComposition(w){
  let comp=[];
  let boss=isBossWave(w);
  if(boss){
    let bossTypes=['shield_boss','split_boss','speed_boss','spawner_boss','mega_boss'];
    let bt=bossTypes[Math.floor((w/5-1)%bossTypes.length)];
    comp.push({type:bt,count:1,label:bt.replace('_',' ').toUpperCase()});
    if(w>=15){comp.push({type:'normal',count:Math.floor(w/3),label:'Guards'})}
  }else{
    let total=5+w*2;
    let remaining=total;
    if(w>=15&&Math.random()<0.2){let n=Math.min(3,remaining);comp.push({type:'stealth',count:n,label:'Stealth'});remaining-=n}
    if(w>=12&&Math.random()<0.2){let n=Math.min(2,remaining);comp.push({type:'split',count:n,label:'Splitter'});remaining-=n}
    if(w>=10&&Math.random()<0.2){let n=Math.min(3,remaining);comp.push({type:'shield_enemy',count:n,label:'Shielded'});remaining-=n}
    if(w>=18&&Math.random()<0.15){let n=Math.min(2,remaining);comp.push({type:'spawner',count:n,label:'Spawner'});remaining-=n}
    if(w>=8&&Math.random()<0.2){let n=Math.min(3,remaining);comp.push({type:'enraged',count:n,label:'Enraged'});remaining-=n}
    if(w>=12){let n=Math.min(Math.floor(remaining*0.15),3);if(n>0){comp.push({type:'flying',count:n,label:'Flying'});remaining-=n}}
    if(w>=8){let n=Math.min(Math.floor(remaining*0.15),3);if(n>0){comp.push({type:'healer',count:n,label:'Healer'});remaining-=n}}
    if(w>=6){let n=Math.min(Math.floor(remaining*0.2),4);if(n>0){comp.push({type:'tank',count:n,label:'Tank'});remaining-=n}}
    if(w>=3){let n=Math.min(Math.floor(remaining*0.3),5);if(n>0){comp.push({type:'fast',count:n,label:'Fast'});remaining-=n}}
    if(remaining>0){comp.push({type:'normal',count:remaining,label:'Normal'})}
  }
  return comp;
}

function showWavePreview(){
  gamePaused=true;
  wavePreviewShown=true;
  let nextW=wave+1;
  let comp=getWaveComposition(nextW);
  let preview=document.getElementById('wave-preview');
  preview.classList.remove('hidden');
  let boss=isBossWave(nextW);
  let html=`<h3>${boss?'\u{1F451} BOSS ':''} Wave ${nextW}</h3>`;
  html+='<div class="enemy-list">';
  let totalCount=0;
  for(let c of comp){
    totalCount+=c.count;
    let color=getEnemyColor(c.type);
    html+=`<div class="enemy-row"><span style="color:${color}">${c.label}</span><span>x${c.count}</span></div>`;
  }
  html+=`</div><p style="font-size:10px;color:#888">${totalCount} enemies total</p>`;
  html+=`<div class="countdown" id="wave-cd-text">Auto-send in <span id="cd-num">10</span>s</div>`;
  html+=`<button class="send-btn" id="send-wave-btn">Send Wave Now</button>`;
  preview.innerHTML=html;
  waveCountdown=10;
  document.getElementById('send-wave-btn').addEventListener('click',()=>{
    preview.classList.add('hidden');
    gamePaused=false;
    wavePreviewShown=false;
    startWave();
  });
}

function getEnemyColor(type){
  const colors={normal:'#e94560',fast:'#ffd93d',tank:'#a55eea',flying:'#81ecec',healer:'#6bcb77',
    stealth:'#636e72',split:'#fd79a8',shield_enemy:'#00cec9',spawner:'#e17055',enraged:'#d63031',
    shield_boss:'#ff6b6b',split_boss:'#ff6b6b',speed_boss:'#ff6b6b',spawner_boss:'#ff6b6b',mega_boss:'#ff4757'};
  return colors[type]||'#e94560';
}

let waveQueue=[];

function startWave(){
  wave++;
  let comp=getWaveComposition(wave);
  waveQueue=[];
  for(let c of comp){for(let i=0;i<c.count;i++)waveQueue.push(c.type)}
  for(let i=waveQueue.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[waveQueue[i],waveQueue[j]]=[waveQueue[j],waveQueue[i]]}
  if(isBossWave(wave)){
    let bossIdx=waveQueue.findIndex(t=>t.includes('boss'));
    if(bossIdx>0){[waveQueue[0],waveQueue[bossIdx]]=[waveQueue[bossIdx],waveQueue[0]]}
  }
  waveEnemies=waveQueue.length;
  waveSpawned=0;spawnTimer=0;betweenWaves=false;
  let b=document.getElementById('wave-banner');
  let boss=isBossWave(wave);
  b.textContent=boss?`BOSS WAVE ${wave}!`:`Wave ${wave}`;
  b.style.color=boss?'#ff6b6b':'#fff';
  b.style.opacity='1';
  setTimeout(()=>b.style.opacity='0',1500);
  document.getElementById('wave-progress').classList.remove('hidden');
  updateHUD();
}

function spawnEnemy(type){
  let hp=30+wave*25;
  let speed=(0.8+wave*0.08)*DIFFICULTIES[difficulty].waveSpeedMult;
  let flying=false,reward=5+wave;
  let color=getEnemyColor(type);
  let isBoss=type.includes('boss');
  let stealth=false,splitCount=0,shieldRegen=0,spawnerTimer=0,enraged=false;

  if(isBoss){
    hp*=8;speed*=0.6;reward*=5;
    if(type==='speed_boss'){speed*=2;hp*=0.5}
    if(type==='spawner_boss'){hp*=0.7}
  }else{
    if(type==='fast'){speed*=1.8;hp*=0.5}
    else if(type==='tank'){speed*=0.5;hp*=3}
    else if(type==='flying'){flying=true;speed*=0.9;hp*=0.6;reward+=3}
    else if(type==='healer'){speed*=0.8;hp*=1.2}
    else if(type==='stealth'){stealth=true;hp*=0.8;speed*=1.1}
    else if(type==='split'){hp*=1.5;splitCount=2}
    else if(type==='shield_enemy'){shieldRegen=3;hp*=0.9}
    else if(type==='spawner'){speed*=0.7;hp*=2;spawnerTimer=3}
    else if(type==='enraged'){hp*=1.3;enraged=true}
  }

  let e={
    pathIdx:0,progress:0,hp,maxHp:hp,speed,baseSpeed:speed,slow:0,type,flying,
    color,reward,dot:0,dotTimer:0,dotSource:null,healTimer:0,
    shield:isBoss&&type==='shield_boss'?3:0,
    splitOnDeath:type==='split_boss'||splitCount>0,
    splitCount:type==='split_boss'?3:splitCount,
    stealth,revealed:false,revealTimer:0,
    shieldRegen,shieldRegenTimer:shieldRegen>0?shieldRegen:0,shieldHP:shieldRegen>0?hp*0.3:0,shieldMaxHP:shieldRegen>0?hp*0.3:0,
    spawner:type==='spawner'||type==='spawner_boss',spawnerTimer:type==='spawner_boss'?2:spawnerTimer,spawnerCd:type==='spawner_boss'?2:3,
    enraged,wasEnraged:false,
    knockbackDist:0,isBoss
  };
  enemies.push(e);
  if(isBoss)activeBoss=e;
}

function getEnemyPos(e){
  if(e.flying){
    let start=cellToPixel(path[0].c,path[0].r);
    let end=cellToPixel(path[path.length-1].c,path[path.length-1].r);
    let prog=(e.pathIdx+e.progress)/path.length;
    return{x:start.x+(end.x-start.x)*prog,y:start.y+(end.y-start.y)*prog+Math.sin(Date.now()*0.003)*8};
  }
  let idx=Math.min(e.pathIdx,path.length-1);
  let nextIdx=Math.min(idx+1,path.length-1);
  let p1=cellToPixel(path[idx].c,path[idx].r);
  let p2=cellToPixel(path[nextIdx].c,path[nextIdx].r);
  let t=Math.min(e.progress,1);
  return{x:p1.x+(p2.x-p1.x)*t,y:p1.y+(p2.y-p1.y)*t};
}

function findTarget(tower,enemies){
  let tp=cellToPixel(tower.c,tower.r);
  let candidates=[];
  for(let e of enemies){
    if(e.stealth&&!e.revealed&&!isNearTower(e))continue;
    if(e.flying&&!tower.canHitFlying&&tower.type!=='splash'&&tower.type!=='arrow'&&tower.type!=='lightning')continue;
    let ep=getEnemyPos(e);
    let d=Math.hypot(ep.x-tp.x,ep.y-tp.y)/cellSize;
    if(d<=tower.range)candidates.push({enemy:e,dist:d,progress:e.pathIdx+e.progress});
  }
  if(candidates.length===0)return null;
  switch(tower.targeting){
    case'first':candidates.sort((a,b)=>b.progress-a.progress);break;
    case'last':candidates.sort((a,b)=>a.progress-b.progress);break;
    case'strongest':candidates.sort((a,b)=>b.enemy.hp-a.enemy.hp);break;
    case'weakest':candidates.sort((a,b)=>a.enemy.hp-b.enemy.hp);break;
  }
  return candidates[0].enemy;
}

function isNearTower(e){
  let ep=getEnemyPos(e);
  for(let t of towers){
    let tp=cellToPixel(t.c,t.r);
    if(Math.hypot(ep.x-tp.x,ep.y-tp.y)/cellSize<2)return true;
  }
  return false;
}

function applyDamage(enemy,tower,mult){
  mult=mult||1;
  let dmg=tower.dmg*mult;
  let crit=false;
  if(tower.overwatch&&tower.critChance&&Math.random()<tower.critChance){dmg*=2;crit=true}
  if(tower.railgun&&enemy.hp/enemy.maxHp<0.15){dmg=enemy.hp+1}
  if(tower.venom){dmg+=enemy.maxHp*0.04}
  if(enemy.shieldHP>0){
    let absorbed=Math.min(enemy.shieldHP,dmg);
    enemy.shieldHP-=absorbed;
    dmg-=absorbed;
  }
  if(enemy.shield>0){enemy.shield--;dmg*=0.1}
  enemy.hp-=dmg;
  totalDamageDealt+=dmg;
  tower.totalDmg=(tower.totalDmg||0)+dmg;
  if(tower.slow)enemy.slow=1.5;
  if(tower.dot){enemy.dot=tower.dot;enemy.dotSource=tower}
  if(tower.plague&&enemy.dot>0){
    let ep=getEnemyPos(enemy);
    for(let e of enemies){
      if(e===enemy)continue;
      let eep=getEnemyPos(e);
      if(Math.hypot(eep.x-ep.x,eep.y-ep.y)<cellSize*1.5){
        e.dot=Math.max(e.dot,tower.dot*0.5);
      }
    }
  }
  if(enemy.hp<=0){tower.kills=(tower.kills||0)+1}
  let pos=getEnemyPos(enemy);
  let txt=crit?Math.floor(dmg)+'!':Math.floor(dmg)+'';
  spawnFloatingText(pos.x+(Math.random()-0.5)*10,pos.y-10,txt,crit?'#ffd93d':'#fff');
}

function updateHUD(){
  document.getElementById('gold').textContent=gold;
  document.getElementById('lives').textContent=lives;
  document.getElementById('wave-num').textContent=wave;
  updateTowerBtnStates();
}

let napalmZones=[];

function update(dt){
  if(!gameActive||gamePaused){
    if(wavePreviewShown){
      waveCountdown-=dt/gameSpeed;
      let cdEl=document.getElementById('cd-num');
      if(cdEl)cdEl.textContent=Math.max(0,Math.ceil(waveCountdown));
      if(waveCountdown<=0){
        document.getElementById('wave-preview').classList.add('hidden');
        gamePaused=false;wavePreviewShown=false;
        startWave();
      }
    }
    return;
  }

  updateAbilitiesUI(dt);

  if(!betweenWaves&&waveSpawned<waveEnemies){
    spawnTimer-=dt;
    let spawnRate=isBossWave(wave)?1.5:0.4;
    if(spawnTimer<=0){
      let type=waveQueue[waveSpawned]||'normal';
      spawnEnemy(type);
      waveSpawned++;
      spawnTimer=spawnRate;
    }
  }

  if(!betweenWaves&&waveSpawned>=waveEnemies&&enemies.length===0){
    if(!endlessMode&&wave>=maxWaves){gameActive=false;endGame(true);return}
    betweenWaves=true;waveDelay=1.5;
    let bonus=20+wave*5;
    if(abilityDurations.goldrush>0)bonus*=2;
    gold+=bonus;totalGoldEarned+=bonus;
    document.getElementById('wave-progress').classList.add('hidden');
    document.getElementById('boss-hp-bar').classList.add('hidden');
    activeBoss=null;
    updateHUD();
  }
  if(betweenWaves){
    waveDelay-=dt;
    if(waveDelay<=0){showWavePreview()}
  }

  let waveProgEl=document.getElementById('wave-progress-fill');
  if(!betweenWaves){
    let killed=waveEnemies-enemies.length-(waveEnemies-waveSpawned);
    let pct=waveEnemies>0?killed/waveEnemies:0;
    waveProgEl.style.width=(pct*100)+'%';
  }

  if(activeBoss&&activeBoss.hp>0){
    document.getElementById('boss-hp-bar').classList.remove('hidden');
    document.getElementById('boss-hp-fill').style.width=(activeBoss.hp/activeBoss.maxHp*100)+'%';
    document.getElementById('boss-hp-text').textContent=activeBoss.type.replace('_',' ').toUpperCase()+' '+Math.ceil(activeBoss.hp);
  }else if(activeBoss&&activeBoss.hp<=0){
    document.getElementById('boss-hp-bar').classList.add('hidden');
    activeBoss=null;
  }

  for(let i=napalmZones.length-1;i>=0;i--){
    let nz=napalmZones[i];
    nz.life-=dt;
    nz.dmgTimer-=dt;
    if(nz.dmgTimer<=0){
      nz.dmgTimer=0.5;
      for(let e of enemies){
        let ep=getEnemyPos(e);
        if(Math.hypot(ep.x-nz.x,ep.y-nz.y)<cellSize*1.2){
          e.hp-=nz.dmg;totalDamageDealt+=nz.dmg;
          spawnFloatingText(ep.x,ep.y-5,Math.floor(nz.dmg)+'','#ff6b6b');
        }
      }
    }
    if(nz.life<=0)napalmZones.splice(i,1);
  }

  for(let i=enemies.length-1;i>=0;i--){
    let e=enemies[i];
    let currentSpeed=e.speed;
    if(e.slow>0){currentSpeed*=0.4;e.slow=Math.max(0,e.slow-dt)}
    if(abilityDurations.freeze>0){currentSpeed*=0.3}
    if(e.enraged&&!e.wasEnraged&&e.hp<e.maxHp*0.5){
      e.wasEnraged=true;
      e.speed=e.baseSpeed*1.8;
      let pos=getEnemyPos(e);
      spawnFloatingText(pos.x,pos.y-15,'ENRAGED!','#d63031');
      for(let j=0;j<6;j++){
        let a=Math.random()*Math.PI*2;
        particles.push({x:pos.x,y:pos.y,vx:Math.cos(a)*2,vy:Math.sin(a)*2,life:0.6,color:'#d63031',size:3});
      }
    }
    if(e.wasEnraged)currentSpeed=e.speed*(e.slow>0?0.5:1);

    if(e.stealth&&!e.revealed){
      if(isNearTower(e)){e.revealed=true;e.revealTimer=3}
    }
    if(e.revealed){e.revealTimer-=dt;if(e.revealTimer<=0){e.revealed=false}}

    if(e.shieldRegen>0){
      e.shieldRegenTimer-=dt;
      if(e.shieldRegenTimer<=0&&e.shieldHP<e.shieldMaxHP){
        e.shieldHP=e.shieldMaxHP;
        e.shieldRegenTimer=e.shieldRegen;
        let pos=getEnemyPos(e);
        spawnFloatingText(pos.x,pos.y-15,'SHIELD!','#00cec9');
      }
    }

    if(e.spawner){
      e.spawnerTimer-=dt;
      if(e.spawnerTimer<=0){
        e.spawnerTimer=e.spawnerCd;
        let miniHP=15+wave*5;
        enemies.push({
          pathIdx:e.pathIdx,progress:e.progress,hp:miniHP,maxHp:miniHP,
          speed:e.speed*1.5,baseSpeed:e.speed*1.5,slow:0,type:'fast',flying:false,
          color:'#ffd93d',reward:Math.floor(e.reward/4),dot:0,dotTimer:0,dotSource:null,
          healTimer:0,shield:0,splitOnDeath:false,splitCount:0,
          stealth:false,revealed:false,revealTimer:0,shieldRegen:0,shieldRegenTimer:0,
          shieldHP:0,shieldMaxHP:0,spawner:false,spawnerTimer:0,spawnerCd:0,
          enraged:false,wasEnraged:false,knockbackDist:0,isBoss:false
        });
      }
    }

    if(e.dot>0){
      e.dotTimer-=dt;
      if(e.dotTimer<=0){
        e.hp-=e.dot;totalDamageDealt+=e.dot;e.dotTimer=0.5;
        let pos=getEnemyPos(e);
        particles.push({x:pos.x,y:pos.y,vx:(Math.random()-0.5)*2,vy:-2,life:0.5,color:'#6bcb77',size:2});
      }
    }

    if(e.type==='healer'){
      e.healTimer-=dt;
      if(e.healTimer<=0){
        e.healTimer=1;
        let pos=getEnemyPos(e);
        for(let j of enemies){
          if(j===e)continue;
          let jp=getEnemyPos(j);
          if(Math.hypot(jp.x-pos.x,jp.y-pos.y)<cellSize*2){
            j.hp=Math.min(j.maxHp,j.hp+j.maxHp*0.05);
          }
        }
        particles.push({x:pos.x,y:pos.y,vx:0,vy:0,life:0.4,color:'#6bcb77',size:cellSize*0.6,isRing:true});
      }
    }

    if(e.knockbackDist>0){
      let kb=Math.min(e.knockbackDist,dt*3);
      e.progress-=kb;
      while(e.progress<0&&e.pathIdx>0){e.pathIdx--;e.progress+=1}
      if(e.progress<0)e.progress=0;
      e.knockbackDist-=kb;
    }else{
      let spd=currentSpeed*dt;
      e.progress+=spd;
      while(e.progress>=1&&e.pathIdx<path.length-1){e.progress-=1;e.pathIdx++}
    }

    if(e.pathIdx>=path.length-1&&e.progress>=0.9){
      let dmg=e.isBoss?5:1;
      enemies.splice(i,1);lives-=dmg;
      shakeMag=5;snd(200,0.2,'square',0.1);
      if(e===activeBoss){activeBoss=null;document.getElementById('boss-hp-bar').classList.add('hidden')}
      updateHUD();
      if(lives<=0){gameActive=false;endGame(false)}
      continue;
    }

    if(e.hp<=0){
      enemies.splice(i,1);
      let rew=e.reward;
      if(abilityDurations.goldrush>0)rew*=2;
      gold+=rew;totalGoldEarned+=rew;totalKills++;

      if(e.splitOnDeath&&e.splitCount>0){
        for(let s=0;s<e.splitCount;s++){
          let splitHP=e.maxHp*0.25;
          enemies.push({
            pathIdx:e.pathIdx,progress:e.progress+(Math.random()-0.5)*0.3,
            hp:splitHP,maxHp:splitHP,speed:e.baseSpeed*1.3,baseSpeed:e.baseSpeed*1.3,slow:0,
            type:'fast',flying:false,color:'#ffd93d',reward:Math.floor(e.reward/3),
            dot:0,dotTimer:0,dotSource:null,healTimer:0,shield:0,splitOnDeath:false,splitCount:0,
            stealth:false,revealed:false,revealTimer:0,shieldRegen:0,shieldRegenTimer:0,
            shieldHP:0,shieldMaxHP:0,spawner:false,spawnerTimer:0,spawnerCd:0,
            enraged:false,wasEnraged:false,knockbackDist:0,isBoss:false
          });
        }
      }

      if(e===activeBoss){activeBoss=null;document.getElementById('boss-hp-bar').classList.add('hidden')}
      let pos=getEnemyPos(e);
      let pCount=e.isBoss?20:10;
      for(let j=0;j<pCount;j++){
        let a=Math.random()*Math.PI*2;
        let spd=1+Math.random()*3;
        particles.push({x:pos.x,y:pos.y,vx:Math.cos(a)*spd,vy:Math.sin(a)*spd,life:0.8+Math.random()*0.4,color:e.color,size:2+Math.random()*3});
      }
      snd(300,0.1,'triangle');
      updateHUD();
    }
  }

  for(let t of towers){
    t.cooldown=Math.max(0,t.cooldown-dt);

    if(t.teslaCoil){
      t.teslaTimer=(t.teslaTimer||0)-dt;
      if(t.teslaTimer<=0){
        t.teslaTimer=0.5;
        let tp=cellToPixel(t.c,t.r);
        let zapTarget=null,zapDist=Infinity;
        for(let e of enemies){
          if(e.stealth&&!e.revealed)continue;
          let ep=getEnemyPos(e);
          let d=Math.hypot(ep.x-tp.x,ep.y-tp.y)/cellSize;
          if(d<=t.range*0.8&&d<zapDist){zapTarget=e;zapDist=d}
        }
        if(zapTarget){
          let ep=getEnemyPos(zapTarget);
          let teslaDmg=t.dmg*0.3;
          zapTarget.hp-=teslaDmg;totalDamageDealt+=teslaDmg;
          t.totalDmg+=teslaDmg;
          if(zapTarget.hp<=0)t.kills++;
          lightningChains.push({x1:tp.x,y1:tp.y,x2:ep.x,y2:ep.y,life:0.15});
          spawnFloatingText(ep.x,ep.y-5,Math.floor(teslaDmg)+'','#a29bfe');
        }
      }
    }

    if(t.blizzard){
      let tp=cellToPixel(t.c,t.r);
      for(let e of enemies){
        let ep=getEnemyPos(e);
        if(Math.hypot(ep.x-tp.x,ep.y-tp.y)/cellSize<=t.range){
          e.slow=Math.max(e.slow,0.3);
        }
      }
    }

    if(t.cooldown>0)continue;

    let best=findTarget(t,enemies);
    if(!best)continue;

    let tp=cellToPixel(t.c,t.r);
    let ep=getEnemyPos(best);
    t.angle=Math.atan2(ep.y-tp.y,ep.x-tp.x);
    t.cooldown=t.rate;

    if(t.type==='laser'){
      if(t.scatter){
        let targets=[];
        for(let e of enemies){
          if(e.stealth&&!e.revealed)continue;
          let eep=getEnemyPos(e);
          if(Math.hypot(eep.x-tp.x,eep.y-tp.y)/cellSize<=t.range)targets.push(e);
          if(targets.length>=3)break;
        }
        for(let tgt of targets){
          applyDamage(tgt,t,0.7);
          let tep=getEnemyPos(tgt);
          particles.push({x:tp.x,y:tp.y,x2:tep.x,y2:tep.y,life:0.15,color:'#ff6b6b',size:2,isBeam:true});
        }
      }else{
        let angle=Math.atan2(ep.y-tp.y,ep.x-tp.x);
        let laserLen=t.range*cellSize;
        let dmgMult=t.deathRay?1.5:1;
        for(let e of enemies){
          if(e.stealth&&!e.revealed)continue;
          let eep=getEnemyPos(e);
          let dx=eep.x-tp.x,dy=eep.y-tp.y;
          let proj=dx*Math.cos(angle)+dy*Math.sin(angle);
          if(proj<0||proj>laserLen)continue;
          let perp=Math.abs(-dx*Math.sin(angle)+dy*Math.cos(angle));
          if(perp<cellSize*0.4){applyDamage(e,t,dmgMult)}
        }
        let beamWidth=t.deathRay?4:2;
        particles.push({x:tp.x,y:tp.y,x2:tp.x+Math.cos(angle)*laserLen,y2:tp.y+Math.sin(angle)*laserLen,life:t.deathRay?0.3:0.15,color:t.deathRay?'#ff0000':t.color,size:beamWidth,isBeam:true});
      }
      snd(900,0.08,'sawtooth',0.04);
    }else if(t.type==='lightning'){
      if(t.storm){
        let tp2=cellToPixel(t.c,t.r);
        for(let e of enemies){
          if(e.stealth&&!e.revealed)continue;
          let eep=getEnemyPos(e);
          if(Math.hypot(eep.x-tp2.x,eep.y-tp2.y)/cellSize<=t.range){
            applyDamage(e,t,0.6);
            lightningChains.push({x1:tp2.x+Math.random()*20-10,y1:tp2.y-cellSize*t.range,x2:eep.x,y2:eep.y,life:0.25});
          }
        }
        snd(400,0.15,'square',0.06);
      }else{
        let targets=[best];
        let lastTarget=best;
        for(let ci=0;ci<(t.chain||3);ci++){
          let lastPos=getEnemyPos(lastTarget);
          let nextBest=null,nextBestD=Infinity;
          for(let e of enemies){
            if(targets.includes(e))continue;
            if(e.stealth&&!e.revealed)continue;
            let eep=getEnemyPos(e);
            let d=Math.hypot(eep.x-lastPos.x,eep.y-lastPos.y);
            if(d<cellSize*2.5&&d<nextBestD){nextBest=e;nextBestD=d}
          }
          if(nextBest){targets.push(nextBest);lastTarget=nextBest}else break;
        }
        for(let ci=0;ci<targets.length;ci++){
          applyDamage(targets[ci],t);
          let p1=ci>0?getEnemyPos(targets[ci-1]):tp;
          let p2=getEnemyPos(targets[ci]);
          lightningChains.push({x1:p1.x,y1:p1.y,x2:p2.x,y2:p2.y,life:0.2});
        }
        snd(600,0.1,'square',0.06);
      }
    }else{
      if(t.type==='arrow'&&t.tripleShot){
        let baseAngle=Math.atan2(ep.y-tp.y,ep.x-tp.x);
        for(let ai=-1;ai<=1;ai++){
          let a=baseAngle+ai*0.2;
          let tx=tp.x+Math.cos(a)*200,ty=tp.y+Math.sin(a)*200;
          projectiles.push({x:tp.x,y:tp.y,tx,ty,target:ai===0?best:null,tower:t,speed:350,color:t.color,piercing:false,angle:a});
        }
      }else if(t.type==='arrow'&&t.piercingArrow){
        projectiles.push({x:tp.x,y:tp.y,tx:ep.x,ty:ep.y,target:best,tower:t,speed:350,color:t.color,piercing:true,pierceHit:new Set(),angle:Math.atan2(ep.y-tp.y,ep.x-tp.x)});
      }else if(t.type==='freeze'&&t.iceWall_enabled){
        let wallPos=getEnemyPos(best);
        let wallPathIdx=best.pathIdx;
        for(let e of enemies){
          if(Math.abs(e.pathIdx-wallPathIdx)<=1){
            e.slow=2;
            e.knockbackDist=0.5;
          }
        }
        particles.push({x:wallPos.x,y:wallPos.y,vx:0,vy:0,life:2,color:'rgba(116,185,255,0.5)',size:cellSize*0.8,isWall:true});
        snd(1000,0.15,'sine',0.06);
        applyDamage(best,t);
      }else{
        projectiles.push({x:tp.x,y:tp.y,tx:ep.x,ty:ep.y,target:best,tower:t,speed:300,color:t.color,piercing:false});
      }
      snd(800,0.05,'sine',0.03);
    }
  }

  for(let i=projectiles.length-1;i>=0;i--){
    let p=projectiles[i];
    let targetPos;
    if(p.piercing){
      targetPos={x:p.x+Math.cos(p.angle)*10,y:p.y+Math.sin(p.angle)*10};
      p.x+=Math.cos(p.angle)*p.speed*dt;
      p.y+=Math.sin(p.angle)*p.speed*dt;
      let tp=cellToPixel(0,0);
      if(p.x<-50||p.x>W+50||p.y<-50||p.y>H+50){projectiles.splice(i,1);continue}
      for(let e of enemies){
        if(p.pierceHit.has(e))continue;
        let ep=getEnemyPos(e);
        if(Math.hypot(ep.x-p.x,ep.y-p.y)<cellSize*0.4){
          applyDamage(e,p.tower);
          p.pierceHit.add(e);
        }
      }
    }else{
      targetPos=p.target&&p.target.hp>0?getEnemyPos(p.target):{x:p.tx,y:p.ty};
      let dx=targetPos.x-p.x,dy=targetPos.y-p.y,d=Math.hypot(dx,dy);
      if(d<10){
        if(p.target&&p.target.hp>0){
          applyDamage(p.target,p.tower);
          if(p.tower.splash){
            let splashR=p.tower.splash;
            for(let e of enemies){
              if(e===p.target)continue;
              let eep=getEnemyPos(e);
              if(Math.hypot(eep.x-targetPos.x,eep.y-targetPos.y)/cellSize<splashR){
                applyDamage(e,p.tower,0.5);
              }
            }
            if(p.tower.knockback){
              for(let e of enemies){
                let eep=getEnemyPos(e);
                if(Math.hypot(eep.x-targetPos.x,eep.y-targetPos.y)/cellSize<splashR){
                  e.knockbackDist=1.5;
                }
              }
            }
            if(p.tower.napalm){
              napalmZones.push({x:targetPos.x,y:targetPos.y,life:4,dmg:p.tower.dmg*0.2,dmgTimer:0});
            }
            for(let j=0;j<8;j++){
              let a=Math.random()*Math.PI*2;
              particles.push({x:targetPos.x,y:targetPos.y,vx:Math.cos(a)*4,vy:Math.sin(a)*4,life:0.6,color:'#e94560',size:4});
            }
          }
        }
        projectiles.splice(i,1);continue;
      }
      p.x+=dx/d*p.speed*dt;p.y+=dy/d*p.speed*dt;
    }
  }

  for(let i=lightningChains.length-1;i>=0;i--){
    lightningChains[i].life-=dt;
    if(lightningChains[i].life<=0)lightningChains.splice(i,1);
  }

  for(let i=floatingTexts.length-1;i>=0;i--){
    let ft=floatingTexts[i];
    ft.y+=ft.vy;ft.life-=dt;
    if(ft.life<=0)floatingTexts.splice(i,1);
  }

  for(let i=particles.length-1;i>=0;i--){
    let p=particles[i];
    if(p.isBeam||p.isRing||p.isWall){p.life-=dt;if(p.life<=0)particles.splice(i,1);continue}
    p.x+=p.vx;p.y+=p.vy;p.vy+=0.1;p.life-=dt*2;
    if(p.life<=0)particles.splice(i,1);
  }

  if(shakeMag>0)shakeMag*=0.9;if(shakeMag<0.3)shakeMag=0;

  let statsEl=document.getElementById('stats-display');
  statsEl.textContent=`DMG: ${formatNum(totalDamageDealt)} | Kills: ${totalKills}`;
}

function formatNum(n){
  if(n>=1000000)return(n/1000000).toFixed(1)+'M';
  if(n>=1000)return(n/1000).toFixed(1)+'K';
  return Math.floor(n)+'';
}

function drawPathDecorations(){
  let ox=(W-GRID_COLS*cellSize)/2;
  for(let r=0;r<GRID_ROWS;r++){
    for(let c=0;c<GRID_COLS;c++){
      if(grid[r][c]===0){
        let seed=(r*GRID_COLS+c)*1337;
        let hash=((seed^(seed>>16))*0x45d9f3b)&0xffffff;
        if(hash%7===0){
          let x=ox+c*cellSize+cellSize/2;
          let y=40+r*cellSize+cellSize/2;
          Ctx.fillStyle=MAP_DEFS[mapChoice].color;
          Ctx.globalAlpha=0.15;
          let sz=cellSize*0.15;
          Ctx.beginPath();Ctx.arc(x+(hash%10-5),y+((hash>>4)%10-5),sz,0,Math.PI*2);Ctx.fill();
          Ctx.globalAlpha=1;
        }
        if(hash%13===0){
          let x=ox+c*cellSize+cellSize/2;
          let y=40+r*cellSize+cellSize/2;
          Ctx.fillStyle='#555';
          Ctx.globalAlpha=0.12;
          let sz=cellSize*0.1;
          Ctx.fillRect(x-sz,y-sz,sz*2,sz*1.5);
          Ctx.globalAlpha=1;
        }
      }
    }
  }
}

function render(){
  Ctx.clearRect(0,0,W,H);
  let sx=shakeMag?(Math.random()-0.5)*shakeMag:0;
  let sy=shakeMag?(Math.random()-0.5)*shakeMag:0;
  Ctx.save();Ctx.translate(sx,sy);
  let ox=(W-GRID_COLS*cellSize)/2;

  for(let r=0;r<GRID_ROWS;r++){
    for(let c=0;c<GRID_COLS;c++){
      let x=ox+c*cellSize,y=40+r*cellSize;
      if(grid[r][c]===1){
        Ctx.fillStyle='rgba(255,255,255,0.05)';
        Ctx.fillRect(x+1,y+1,cellSize-2,cellSize-2);
      }
    }
  }

  Ctx.strokeStyle='rgba(255,217,61,0.1)';Ctx.lineWidth=cellSize*0.7;Ctx.lineCap='round';Ctx.lineJoin='round';
  Ctx.beginPath();
  for(let i=0;i<path.length;i++){
    let p=cellToPixel(path[i].c,path[i].r);
    i===0?Ctx.moveTo(p.x,p.y):Ctx.lineTo(p.x,p.y);
  }
  Ctx.stroke();

  Ctx.strokeStyle='rgba(255,217,61,0.04)';Ctx.lineWidth=cellSize*0.9;
  Ctx.beginPath();
  for(let i=0;i<path.length;i++){
    let p=cellToPixel(path[i].c,path[i].r);
    i===0?Ctx.moveTo(p.x,p.y):Ctx.lineTo(p.x,p.y);
  }
  Ctx.stroke();

  drawPathDecorations();

  if(selectedType&&mouseCell&&grid[mouseCell.r]&&grid[mouseCell.r][mouseCell.c]===0){
    let mp=cellToPixel(mouseCell.c,mouseCell.r);
    let range=TOWER_TYPES[selectedType].range;
    let canAfford=gold>=TOWER_TYPES[selectedType].cost;
    Ctx.beginPath();Ctx.arc(mp.x,mp.y,range*cellSize,0,Math.PI*2);
    Ctx.fillStyle=canAfford?'rgba(100,255,100,0.08)':'rgba(255,100,100,0.08)';Ctx.fill();
    Ctx.strokeStyle=canAfford?'rgba(100,255,100,0.3)':'rgba(255,100,100,0.3)';Ctx.lineWidth=1;Ctx.stroke();
    Ctx.fillStyle=canAfford?'rgba(100,255,100,0.2)':'rgba(255,100,100,0.2)';
    Ctx.fillRect(ox+mouseCell.c*cellSize+2,40+mouseCell.r*cellSize+2,cellSize-4,cellSize-4);
  }

  for(let nz of napalmZones){
    Ctx.globalAlpha=nz.life/4*0.4;
    Ctx.fillStyle='#ff6b6b';
    Ctx.beginPath();Ctx.arc(nz.x,nz.y,cellSize*1.2,0,Math.PI*2);Ctx.fill();
    Ctx.globalAlpha=1;
  }

  for(let t of towers){
    let p=cellToPixel(t.c,t.r);
    let s=cellSize*0.35;

    if(t===selectedTower){
      Ctx.beginPath();Ctx.arc(p.x,p.y,t.range*cellSize,0,Math.PI*2);
      Ctx.fillStyle='rgba(255,255,255,0.05)';Ctx.fill();
      Ctx.strokeStyle='rgba(255,255,255,0.15)';Ctx.lineWidth=1;Ctx.stroke();
    }

    Ctx.save();
    Ctx.translate(p.x,p.y);
    Ctx.rotate(t.angle||0);

    Ctx.fillStyle=t.color;
    Ctx.shadowColor=t.color;Ctx.shadowBlur=6+t.level*3;

    if(t.type==='sniper'){
      Ctx.beginPath();
      Ctx.moveTo(s*1.2,0);Ctx.lineTo(0,-s*0.6);Ctx.lineTo(-s*0.6,0);Ctx.lineTo(0,s*0.6);
      Ctx.closePath();Ctx.fill();
    }else if(t.type==='lightning'){
      Ctx.beginPath();
      for(let i=0;i<5;i++){
        let a=Math.PI*2/5*i-Math.PI/2;
        Ctx.lineTo(Math.cos(a)*s,Math.sin(a)*s);
        let a2=a+Math.PI/5;
        Ctx.lineTo(Math.cos(a2)*s*0.4,Math.sin(a2)*s*0.4);
      }
      Ctx.closePath();Ctx.fill();
    }else if(t.type==='poison'){
      Ctx.beginPath();Ctx.arc(0,0,s*0.7,0,Math.PI*2);Ctx.fill();
    }else if(t.type==='laser'){
      Ctx.fillRect(-s*0.5,-s*0.5,s*1.2,s);
    }else if(t.type==='freeze'){
      Ctx.beginPath();
      for(let i=0;i<6;i++){
        let a=Math.PI*2/6*i;
        Ctx.lineTo(Math.cos(a)*s*0.8,Math.sin(a)*s*0.8);
      }
      Ctx.closePath();Ctx.fill();
    }else if(t.type==='splash'){
      Ctx.beginPath();Ctx.arc(0,0,s*0.6,0,Math.PI*2);Ctx.fill();
      Ctx.fillStyle='rgba(233,69,96,0.4)';
      Ctx.beginPath();Ctx.arc(0,0,s*0.9,0,Math.PI*2);Ctx.fill();
    }else{
      Ctx.beginPath();
      Ctx.moveTo(s,0);Ctx.lineTo(-s*0.6,-s*0.7);Ctx.lineTo(-s*0.6,s*0.7);
      Ctx.closePath();Ctx.fill();
    }
    Ctx.shadowBlur=0;
    Ctx.restore();

    if(t.upgradePath){
      Ctx.fillStyle=t.upgradePath==='A'?'#ffd93d':'#74b9ff';
      Ctx.font=`bold ${Math.max(8,cellSize*0.2)}px sans-serif`;
      Ctx.textAlign='center';
      Ctx.fillText(t.upgradePath,p.x,p.y+s+cellSize*0.25);
    }

    for(let l=0;l<t.level;l++){
      Ctx.fillStyle='#fff';Ctx.beginPath();
      Ctx.arc(p.x-4+l*4,p.y+s+cellSize*0.35,1.5,0,Math.PI*2);Ctx.fill();
    }

    if(t.teslaCoil){
      let pulse=(Date.now()%1000)/1000;
      Ctx.globalAlpha=0.1+pulse*0.1;
      Ctx.strokeStyle='#a29bfe';Ctx.lineWidth=1;
      Ctx.beginPath();Ctx.arc(p.x,p.y,t.range*cellSize*0.8*pulse,0,Math.PI*2);Ctx.stroke();
      Ctx.globalAlpha=1;
    }
    if(t.blizzard){
      let pulse=(Date.now()%2000)/2000;
      Ctx.globalAlpha=0.05;
      Ctx.fillStyle='#74b9ff';
      Ctx.beginPath();Ctx.arc(p.x,p.y,t.range*cellSize,0,Math.PI*2);Ctx.fill();
      Ctx.globalAlpha=1;
    }
  }

  for(let e of enemies){
    if(e.stealth&&!e.revealed){
      let pos=getEnemyPos(e);
      Ctx.globalAlpha=0.15;
      Ctx.fillStyle='#636e72';
      Ctx.beginPath();Ctx.arc(pos.x,pos.y,cellSize*0.2,0,Math.PI*2);Ctx.fill();
      Ctx.globalAlpha=1;
      continue;
    }

    let pos=getEnemyPos(e);
    let r=cellSize*0.3*(e.isBoss?1.6:e.type==='tank'?1.3:e.type==='fast'?0.7:e.flying?0.6:1);

    let bw=r*2;
    Ctx.fillStyle='rgba(0,0,0,0.5)';Ctx.fillRect(pos.x-bw/2,pos.y-r-8,bw,4);
    let hpPct=e.hp/e.maxHp;
    Ctx.fillStyle=hpPct>0.5?'#6bcb77':hpPct>0.25?'#ffd93d':'#e94560';
    Ctx.fillRect(pos.x-bw/2,pos.y-r-8,bw*Math.max(0,hpPct),4);

    if(e.shieldHP>0){
      let shieldPct=e.shieldHP/e.shieldMaxHP;
      Ctx.fillStyle='rgba(0,206,209,0.4)';
      Ctx.fillRect(pos.x-bw/2,pos.y-r-12,bw*shieldPct,3);
    }

    if(e.shield>0){
      Ctx.strokeStyle='rgba(100,200,255,0.6)';Ctx.lineWidth=2;
      Ctx.beginPath();Ctx.arc(pos.x,pos.y,r+4,0,Math.PI*2);Ctx.stroke();
    }

    Ctx.fillStyle=e.slow>0?'#74b9ff':e.dot>0?'#6bcb77':e.wasEnraged?'#d63031':e.color;
    Ctx.shadowColor=e.color;Ctx.shadowBlur=e.isBoss?15:6;

    if(e.flying){
      Ctx.beginPath();
      Ctx.moveTo(pos.x+r,pos.y);Ctx.lineTo(pos.x,pos.y-r*1.5);
      Ctx.lineTo(pos.x-r*0.5,pos.y);Ctx.lineTo(pos.x,pos.y+r*1.5);
      Ctx.closePath();Ctx.fill();
    }else if(e.type==='healer'){
      Ctx.fillRect(pos.x-r*0.3,pos.y-r,r*0.6,r*2);
      Ctx.fillRect(pos.x-r,pos.y-r*0.3,r*2,r*0.6);
    }else if(e.type==='tank'){
      Ctx.fillRect(pos.x-r,pos.y-r*0.7,r*2,r*1.4);
    }else if(e.type==='stealth'){
      Ctx.globalAlpha=e.revealed?0.8:0.3;
      Ctx.beginPath();
      Ctx.moveTo(pos.x,pos.y-r);Ctx.lineTo(pos.x+r,pos.y+r);Ctx.lineTo(pos.x-r,pos.y+r);
      Ctx.closePath();Ctx.fill();
      Ctx.globalAlpha=1;
    }else if(e.type==='split'){
      Ctx.beginPath();
      for(let j=0;j<6;j++){
        let a=Math.PI*2/6*j;
        Ctx.lineTo(pos.x+Math.cos(a)*r,pos.y+Math.sin(a)*r);
      }
      Ctx.closePath();Ctx.fill();
    }else if(e.type==='shield_enemy'){
      Ctx.beginPath();Ctx.arc(pos.x,pos.y,r,0,Math.PI*2);Ctx.fill();
      if(e.shieldHP>0){
        Ctx.strokeStyle='rgba(0,206,201,0.8)';Ctx.lineWidth=3;
        Ctx.beginPath();Ctx.arc(pos.x,pos.y,r+2,0,Math.PI*2*(e.shieldHP/e.shieldMaxHP));Ctx.stroke();
      }
    }else if(e.spawner){
      Ctx.beginPath();
      Ctx.moveTo(pos.x,pos.y-r*1.1);
      Ctx.lineTo(pos.x+r*1.1,pos.y+r*0.5);
      Ctx.lineTo(pos.x-r*1.1,pos.y+r*0.5);
      Ctx.closePath();Ctx.fill();
      Ctx.fillStyle='#ffd93d';
      Ctx.beginPath();Ctx.arc(pos.x,pos.y+r*0.1,r*0.3,0,Math.PI*2);Ctx.fill();
    }else if(e.enraged||e.wasEnraged){
      Ctx.beginPath();Ctx.arc(pos.x,pos.y,r,0,Math.PI*2);Ctx.fill();
      if(e.wasEnraged){
        Ctx.strokeStyle='rgba(214,48,49,0.6)';Ctx.lineWidth=2;
        let pulse=Math.sin(Date.now()*0.01)*0.3+0.7;
        Ctx.beginPath();Ctx.arc(pos.x,pos.y,r+3*pulse,0,Math.PI*2);Ctx.stroke();
      }
    }else{
      Ctx.beginPath();Ctx.arc(pos.x,pos.y,r,0,Math.PI*2);Ctx.fill();
    }
    Ctx.shadowBlur=0;

    if(e.isBoss){
      Ctx.fillStyle='#ffd93d';
      Ctx.font=`${Math.max(10,r*0.8)}px sans-serif`;
      Ctx.textAlign='center';
      Ctx.fillText('\u{1F451}',pos.x,pos.y-r-12);
    }
  }

  for(let lc of lightningChains){
    Ctx.strokeStyle=`rgba(162,155,254,${Math.min(1,lc.life*5)})`;
    Ctx.lineWidth=2;
    Ctx.beginPath();
    let dx=lc.x2-lc.x1,dy=lc.y2-lc.y1;
    let steps=5;
    Ctx.moveTo(lc.x1,lc.y1);
    for(let s=1;s<steps;s++){
      let t=s/steps;
      Ctx.lineTo(lc.x1+dx*t+(Math.random()-0.5)*15,lc.y1+dy*t+(Math.random()-0.5)*15);
    }
    Ctx.lineTo(lc.x2,lc.y2);
    Ctx.stroke();
  }

  for(let p of projectiles){
    Ctx.fillStyle=p.color;Ctx.shadowColor=p.color;Ctx.shadowBlur=6;
    Ctx.beginPath();Ctx.arc(p.x,p.y,3,0,Math.PI*2);Ctx.fill();
    Ctx.shadowBlur=0;
  }

  for(let p of particles){
    if(p.isBeam){
      Ctx.globalAlpha=Math.min(1,p.life*6);Ctx.strokeStyle=p.color;Ctx.lineWidth=p.size;
      Ctx.beginPath();Ctx.moveTo(p.x,p.y);Ctx.lineTo(p.x2,p.y2);Ctx.stroke();
    }else if(p.isRing){
      Ctx.globalAlpha=p.life*2;
      Ctx.strokeStyle=p.color;Ctx.lineWidth=2;
      Ctx.beginPath();Ctx.arc(p.x,p.y,p.size*(1-p.life),0,Math.PI*2);Ctx.stroke();
    }else if(p.isWall){
      Ctx.globalAlpha=Math.min(1,p.life*0.8);
      Ctx.fillStyle=p.color;
      Ctx.fillRect(p.x-p.size/2,p.y-p.size/2,p.size,p.size);
    }else{
      Ctx.globalAlpha=Math.max(0,p.life);
      Ctx.fillStyle=p.color;
      Ctx.beginPath();Ctx.arc(p.x,p.y,Math.max(0.5,p.size*p.life),0,Math.PI*2);Ctx.fill();
    }
  }
  Ctx.globalAlpha=1;

  Ctx.font='bold 11px sans-serif';
  Ctx.textAlign='center';
  for(let ft of floatingTexts){
    Ctx.globalAlpha=Math.max(0,ft.life);
    Ctx.fillStyle=ft.color;
    Ctx.fillText(ft.text,ft.x,ft.y);
  }
  Ctx.globalAlpha=1;

  drawMinimap();

  Ctx.restore();
  requestAnimationFrame(render);
}

function drawMinimap(){
  let mw=60,mh=80;
  let mx=W-mw-8,my=H-mh-90;
  Ctx.fillStyle='rgba(0,0,0,0.4)';
  Ctx.fillRect(mx,my,mw,mh);
  Ctx.strokeStyle='rgba(255,255,255,0.15)';Ctx.lineWidth=1;
  Ctx.strokeRect(mx,my,mw,mh);
  let scaleX=mw/GRID_COLS,scaleY=mh/GRID_ROWS;
  for(let p of path){
    Ctx.fillStyle='rgba(255,217,61,0.3)';
    Ctx.fillRect(mx+p.c*scaleX,my+p.r*scaleY,scaleX,scaleY);
  }
  for(let t of towers){
    Ctx.fillStyle=t.color;
    Ctx.fillRect(mx+t.c*scaleX,my+t.r*scaleY,scaleX,scaleY);
  }
  for(let e of enemies){
    if(e.stealth&&!e.revealed)continue;
    let pos=getEnemyPos(e);
    let ox=(W-GRID_COLS*cellSize)/2;
    let ex=(pos.x-ox)/cellSize*scaleX;
    let ey=(pos.y-40)/cellSize*scaleY;
    Ctx.fillStyle=e.color;
    Ctx.fillRect(mx+ex-1,my+ey-1,2,2);
  }
}

let lastT=0;
function loop(t){
  let dt=Math.min((t-lastT)/1000,0.05)*gameSpeed;lastT=t;
  update(dt);
  requestAnimationFrame(loop);
}

function endGame(won){
  let score=totalKills*10+wave*100+(won?1000:0)+gold;
  let mvp=null,mvpKills=0;
  let topDmgTower=null,topDmg=0;
  for(let t of towers){
    if(t.kills>mvpKills){mvp=t;mvpKills=t.kills}
    if((t.totalDmg||0)>topDmg){topDmgTower=t;topDmg=t.totalDmg||0}
  }
  let go=document.getElementById('game-over');
  let mvpText=mvp?`${mvp.name}${mvp.upgradePath?' ('+mvp.upgradePath+')':''} at [${mvp.c},${mvp.r}] - ${mvp.kills} kills`:'N/A';
  let dmgText=topDmgTower?`${topDmgTower.name} - ${formatNum(topDmg)} total damage`:'N/A';
  go.innerHTML=`
    <h2>${won?'Victory!':'Defeated'}</h2>
    <div class="score-big">${score}</div>
    <p class="stat">Waves: ${wave}/${endlessMode?'\u{221E}':maxWaves}</p>
    <p class="stat">Kills: ${totalKills}</p>
    <p class="stat">Gold earned: ${totalGoldEarned}</p>
    <p class="stat">Towers: ${towers.length}</p>
    <p class="stat">Total DMG: ${formatNum(totalDamageDealt)}</p>
    <p class="stat">Difficulty: ${DIFFICULTIES[difficulty].label}</p>
    <p class="stat">Map: ${MAP_DEFS[mapChoice].label}</p>
    <div class="mvp">MVP Tower: ${mvpText}</div>
    <div class="mvp">Top Damage: ${dmgText}</div>
    <button onclick="resetToMenu()">Play Again</button>
  `;
  go.classList.remove('hidden');
}

function resetToMenu(){
  document.getElementById('game-over').classList.add('hidden');
  document.getElementById('menu-screen').classList.remove('hidden');
  document.getElementById('abilities-bar').classList.add('hidden');
  document.getElementById('boss-hp-bar').classList.add('hidden');
  document.getElementById('wave-progress').classList.add('hidden');
  gameActive=false;
}

function buildMenuUI(){
  let diffRow=document.getElementById('diff-row');
  diffRow.innerHTML='';
  for(let key in DIFFICULTIES){
    let d=DIFFICULTIES[key];
    let btn=document.createElement('div');
    btn.className='menu-btn'+(key===difficulty?' sel':'');
    btn.innerHTML=`<b>${d.label}</b><br><span style="font-size:10px;color:#888">${d.desc}</span>`;
    btn.addEventListener('click',()=>{
      difficulty=key;
      diffRow.querySelectorAll('.menu-btn').forEach(b=>b.classList.remove('sel'));
      btn.classList.add('sel');
    });
    diffRow.appendChild(btn);
  }
  let mapRow=document.getElementById('map-row');
  mapRow.innerHTML='';
  for(let key in MAP_DEFS){
    let m=MAP_DEFS[key];
    let btn=document.createElement('div');
    btn.className='menu-btn'+(key===mapChoice?' sel':'');
    btn.innerHTML=`<b>${m.label}</b><br><span style="font-size:10px;color:#888">${m.desc}</span>`;
    btn.addEventListener('click',()=>{
      mapChoice=key;
      mapRow.querySelectorAll('.menu-btn').forEach(b=>b.classList.remove('sel'));
      btn.classList.add('sel');
    });
    mapRow.appendChild(btn);
  }
  document.getElementById('start-btn').addEventListener('click',startGame);
}

document.getElementById('speed-btn').addEventListener('click',()=>{
  gameSpeed=gameSpeed===1?2:gameSpeed===2?3:1;
  document.getElementById('speed-btn').textContent=gameSpeed+'x';
});

function startGame(){
  ensureAudio();
  document.getElementById('menu-screen').classList.add('hidden');
  document.getElementById('game-over').classList.add('hidden');
  endlessMode=difficulty==='endless';
  maxWaves=endlessMode?999:30;
  document.getElementById('max-wave').textContent=endlessMode?'\u{221E}':maxWaves;
  generatePath();
  let diff=DIFFICULTIES[difficulty];
  gold=diff.gold;lives=diff.lives;wave=0;
  towers=[];enemies=[];projectiles=[];particles=[];lightningChains=[];floatingTexts=[];napalmZones=[];
  totalKills=0;totalGoldEarned=0;totalDamageDealt=0;
  betweenWaves=true;waveDelay=1;
  gameActive=true;gamePaused=false;
  selectedType=null;selectedTower=null;
  activeBoss=null;repairUsed=false;
  abilityCooldowns={fire:0,freeze:0,goldrush:0,repair:0};
  abilityDurations={freeze:0,goldrush:0};
  wavePreviewShown=false;
  buildTowerPanel();
  buildAbilitiesBar();
  updateHUD();
}

window.addEventListener('resize',resize);
resize();
buildMenuUI();
buildTowerPanel();
requestAnimationFrame(render);
requestAnimationFrame(loop);
</script>
</body>
</html>
