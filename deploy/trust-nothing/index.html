<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Trust Nothing</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #000;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  font-family: 'Segoe UI', system-ui, sans-serif;
}
canvas {
  display: block;
  width: 100%; height: 100%;
  image-rendering: auto;
}
#overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 10;
}
#overlay.active { pointer-events: auto; }
#overlay-content {
  position: absolute; top: 0; left: 0; width: 100%; height: 100%;
  display: flex; align-items: center; justify-content: center;
}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="overlay"><div id="overlay-content"></div></div>
<script>
'use strict';

// ============================================================
// TRUST NOTHING â€” HTML5 Canvas Game
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const overlayContent = document.getElementById('overlay-content');

// --- GLOBALS ---
let W, H, scale, centerX, centerY;
let gameTime = 0, deltaTime = 0, lastTime = 0;
let totalDeaths = 0;
let currentRoom = 0;
let roomDeaths = 0; // deaths in current room
let shakeAmount = 0, shakeDecay = 0.9;
let slowMo = false, slowMoTimer = 0;
let particles = [];
let transitioning = false, transitionAlpha = 0, transitionDir = 0, transitionCallback = null;
let inputEvents = []; // queued tap/click events
let dragState = { active: false, startX: 0, startY: 0, x: 0, y: 0, dx: 0, dy: 0, target: null };
let roomState = {}; // per-room state, reset on room entry
let deathMessage = '';
let deathAnimTimer = 0;
let deathAnimType = '';
let showingDeath = false;
let stickFigure = { x: 0, y: 0, eyeState: 'normal', breathPhase: 0, lookDir: 0, visible: true, scale: 1 };
let hintLevel = 0; // increases with deaths in room
let audioMuted = false; // global mute state
let highestRoom = 0;

// Save/load progress
try { 
  const s = localStorage.getItem('trustnothing');
  if (s) { const d = JSON.parse(s); highestRoom = d.highestRoom || 0; totalDeaths = d.totalDeaths || 0; }
} catch(e) {}
function saveGameProgress() { 
  try { localStorage.setItem('trustnothing', JSON.stringify({ highestRoom, totalDeaths })); } catch(e) {} 
}

// --- RESIZE ---
function resize() {
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  scale = Math.min(W / 400, H / 700);
  centerX = W / 2;
  centerY = H / 2;
}
window.addEventListener('resize', resize);
resize();

// ============================================================
// AUDIO ENGINE (Web Audio API) - Enhanced
// ============================================================
let audioCtx = null;
let masterGain = null;
let musicGain = null;
let sfxGain = null;

// Background music state
let bgMusicNodes = [];
let currentAmbientNodes = [];

function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create gain hierarchy
    masterGain = audioCtx.createGain();
    masterGain.gain.value = audioMuted ? 0 : 1;
    masterGain.connect(audioCtx.destination);
    
    musicGain = audioCtx.createGain();
    musicGain.gain.value = 0.06;
    musicGain.connect(masterGain);
    
    sfxGain = audioCtx.createGain();
    sfxGain.gain.value = 1;
    sfxGain.connect(masterGain);
    
    startBackgroundMusic();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function toggleMute() {
  audioMuted = !audioMuted;
  if (audioCtx && masterGain) {
    masterGain.gain.setValueAtTime(audioMuted ? 0 : 1, audioCtx.currentTime);
  }
  if (audioMuted) {
    stopAllAmbient();
  } else {
    startRoomAmbient(currentRoom);
  }
}

// === CHIPTUNE BACKGROUND MUSIC ===
function startBackgroundMusic() {
  if (!audioCtx || audioMuted) return;
  stopBackgroundMusic();
  
  // Chiptune melody - C major pentatonic scale
  const melody = [261.63, 293.66, 329.63, 392.00, 440.00]; // C D E G A
  const bassNotes = [130.81, 164.81, 196.00]; // C E G
  
  // Melody oscillator
  const melodyOsc = audioCtx.createOscillator();
  melodyOsc.type = 'square';
  melodyOsc.frequency.value = melody[0];
  
  const melodyGainNode = audioCtx.createGain();
  melodyGainNode.gain.value = 0.04;
  
  melodyOsc.connect(melodyGainNode);
  melodyGainNode.connect(musicGain);
  melodyOsc.start();
  
  // Bass oscillator
  const bassOsc = audioCtx.createOscillator();
  bassOsc.type = 'triangle';
  bassOsc.frequency.value = bassNotes[0];
  
  const bassGainNode = audioCtx.createGain();
  bassGainNode.gain.value = 0.06;
  
  bassOsc.connect(bassGainNode);
  bassGainNode.connect(musicGain);
  bassOsc.start();
  
  // Arpeggio oscillator
  const arpOsc = audioCtx.createOscillator();
  arpOsc.type = 'square';
  arpOsc.frequency.value = melody[0] * 2;
  
  const arpGainNode = audioCtx.createGain();
  arpGainNode.gain.value = 0.04;
  
  arpOsc.connect(arpGainNode);
  arpGainNode.connect(musicGain);
  arpOsc.start();
  
  bgMusicNodes.push({ osc: melodyOsc, gain: melodyGainNode });
  bgMusicNodes.push({ osc: bassOsc, gain: bassGainNode });
  bgMusicNodes.push({ osc: arpOsc, gain: arpGainNode });
  
  // Animate the melody - 8-step pattern
  const melodyPattern = [0, 2, 4, 2, 3, 1, 2, 0]; // Indices into melody array
  const bassPattern = [0, 0, 2, 2, 1, 1, 0, 0];
  const arpPattern = [0, 4, 2, 3, 1, 2, 4, 0];
  
  let step = 0;
  const noteLength = 0.4; // slower, more ambient feel
  
  function updateMelody() {
    if (!bgMusicNodes.length || audioMuted) return;
    
    const now = audioCtx.currentTime;
    const nextNoteTime = now + 0.01;
    
    // Melody
    melodyOsc.frequency.setValueAtTime(melody[melodyPattern[step % 8]], nextNoteTime);
    
    // Bass (plays half-speed)
    if (step % 2 === 0) {
      bassOsc.frequency.setValueAtTime(bassNotes[bassPattern[step % 8]], nextNoteTime);
    }
    
    // Arpeggio (plays double-speed)
    arpOsc.frequency.setValueAtTime(melody[arpPattern[step % 8]] * 2, nextNoteTime);
    
    step++;
    setTimeout(updateMelody, noteLength * 1000);
  }
  
  updateMelody();
}

function stopBackgroundMusic() {
  bgMusicNodes.forEach(node => {
    try {
      node.osc.stop();
    } catch(e) {}
  });
  bgMusicNodes = [];
}

// === ROOM-SPECIFIC AMBIENT SOUNDS ===
function startRoomAmbient(roomIndex) {
  stopAllAmbient();
  if (audioMuted || !audioCtx) return;
  
  const now = audioCtx.currentTime;
  
  switch(roomIndex) {
    case 2: // Timer Panic - ticking clock
      startTickingClock();
      break;
    case 5: // System Alert - subtle typing sounds
      startTypingSounds();
      break;
    case 6: // Helpful Arrow - wind ambience
      startWindAmbience();
      break;
    case 8: // Mirror Room - eerie echo
      startEchoAmbience();
      break;
    case 9: // Trust the Troll - troll breathing
      startTrollAmbience();
      break;
  }
}

function startTickingClock() {
  const tick = () => {
    if (currentRoom !== 2 || audioMuted || roomState.expired) return;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.frequency.value = 800;
    osc.type = 'sine';

    gain.gain.setValueAtTime(0.04, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);

    osc.connect(gain);
    gain.connect(sfxGain);

    osc.start();
    osc.stop(audioCtx.currentTime + 0.05);

    ambientTimeoutIds.push(setTimeout(tick, 500));
  };
  tick();
}

function startTypingSounds() {
  const type = () => {
    if (currentRoom !== 5 || audioMuted || roomState.dismissed) return;

    if (Math.random() < 0.3) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.frequency.value = 100 + Math.random() * 200;
      osc.type = 'square';

      gain.gain.setValueAtTime(0.02, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.03);

      osc.connect(gain);
      gain.connect(sfxGain);

      osc.start();
      osc.stop(audioCtx.currentTime + 0.03);
    }

    ambientTimeoutIds.push(setTimeout(type, 50 + Math.random() * 150));
  };
  type();
}

function startWindAmbience() {
  const noise = audioCtx.createBufferSource();
  const bufSize = audioCtx.sampleRate * 2;
  const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  
  for (let i = 0; i < bufSize; i++) {
    data[i] = (Math.random() * 2 - 1) * 0.3;
  }
  
  noise.buffer = buf;
  noise.loop = true;
  
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = 400;
  
  const gain = audioCtx.createGain();
  gain.gain.value = 0.03;
  
  noise.connect(filter);
  filter.connect(gain);
  gain.connect(sfxGain);
  
  noise.start();
  currentAmbientNodes.push({ node: noise, type: 'wind' });
}

function startEchoAmbience() {
  const pulse = () => {
    if (currentRoom !== 8 || audioMuted) return;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.frequency.value = 220;
    osc.type = 'sine';

    gain.gain.setValueAtTime(0, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0.02, audioCtx.currentTime + 0.1);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2);

    osc.connect(gain);
    gain.connect(sfxGain);

    osc.start();
    osc.stop(audioCtx.currentTime + 2);

    ambientTimeoutIds.push(setTimeout(pulse, 3000 + Math.random() * 2000));
  };
  pulse();
}

function startTrollAmbience() {
  const breathe = () => {
    if (currentRoom !== 9 || audioMuted) return;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.frequency.value = 80;
    osc.type = 'sawtooth';

    gain.gain.setValueAtTime(0, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0.015, audioCtx.currentTime + 0.8);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.6);

    osc.connect(gain);
    gain.connect(sfxGain);

    osc.start();
    osc.stop(audioCtx.currentTime + 1.6);

    ambientTimeoutIds.push(setTimeout(breathe, 2000));
  };
  breathe();
}

let ambientTimeoutIds = [];
function stopAllAmbient() {
  currentAmbientNodes.forEach(ambient => {
    try { ambient.node.stop(); } catch(e) {}
  });
  currentAmbientNodes = [];
  ambientTimeoutIds.forEach(id => clearTimeout(id));
  ambientTimeoutIds = [];
}

// === SOUND EFFECTS ===
function playTone(freq, duration, type = 'square', vol = 0.15) {
  if (audioMuted) return;
  ensureAudio();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(sfxGain);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function playNoise(duration, vol = 0.1) {
  if (audioMuted) return;
  ensureAudio();
  const bufSize = audioCtx.sampleRate * duration;
  const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
  const src = audioCtx.createBufferSource();
  const gain = audioCtx.createGain();
  src.buffer = buf;
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  src.connect(gain);
  gain.connect(sfxGain);
  src.start();
}

// Death sounds - varied and comical
function sfxDeath() {
  const deathType = Math.floor(Math.random() * 5);
  
  switch(deathType) {
    case 0: // Sad descending
      playTone(200, 0.15, 'sawtooth', 0.2);
      setTimeout(() => playTone(100, 0.3, 'sawtooth', 0.15), 150);
      break;
    case 1: // Boing
      playTone(150, 0.05, 'sine', 0.2);
      setTimeout(() => playTone(100, 0.05, 'sine', 0.15), 50);
      setTimeout(() => playTone(80, 0.1, 'sine', 0.12), 100);
      break;
    case 2: // Splat
      playNoise(0.15, 0.25);
      break;
    case 3: // Deflate
      for (let i = 0; i < 10; i++) {
        setTimeout(() => playTone(300 - i * 25, 0.05, 'square', 0.1), i * 30);
      }
      break;
    case 4: // Cartoon pop
      playTone(400, 0.05, 'sine', 0.2);
      setTimeout(() => playNoise(0.1, 0.15), 50);
      break;
  }
}

function sfxClick() {
  if (audioMuted) return;
  playTone(800, 0.05, 'sine', 0.1);
}

function sfxHover() {
  if (audioMuted) return;
  playTone(600, 0.03, 'sine', 0.05);
}

function sfxDrag() {
  if (audioMuted) return;
  playTone(400 + Math.random() * 200, 0.02, 'sine', 0.04);
}

// Victory jingle - enhanced
function sfxWin() {
  if (audioMuted) return;
  ensureAudio();
  
  const notes = [523.25, 659.25, 783.99, 1046.50]; // C E G C
  notes.forEach((freq, i) => {
    setTimeout(() => {
      playTone(freq, 0.15, 'sine', 0.15);
      if (i === notes.length - 1) {
        // Final flourish
        setTimeout(() => playTone(freq * 2, 0.3, 'sine', 0.12), 100);
      }
    }, i * 100);
  });
}

function sfxExplosion() {
  if (audioMuted) return;
  playNoise(0.4, 0.2);
  playTone(80, 0.4, 'sawtooth', 0.2);
}

function sfxTick() {
  if (audioMuted) return;
  playTone(1000, 0.03, 'sine', 0.08);
}

function sfxChime() {
  if (audioMuted) return;
  playTone(880, 0.15, 'sine', 0.1);
  setTimeout(() => playTone(1100, 0.15, 'sine', 0.1), 120);
}

function sfxSadTrombone() {
  if (audioMuted) return;
  playTone(293, 0.3, 'sawtooth', 0.12);
  setTimeout(() => playTone(277, 0.3, 'sawtooth', 0.12), 300);
  setTimeout(() => playTone(261, 0.3, 'sawtooth', 0.12), 600);
  setTimeout(() => playTone(246, 0.5, 'sawtooth', 0.12), 900);
}

function sfxDing() {
  if (audioMuted) return;
  playTone(1200, 0.05, 'sine', 0.2);
}

// Troll laugh - evil and comical
function sfxTrollLaugh() {
  if (audioMuted) return;
  ensureAudio();
  
  // Ha ha ha ha!
  const laughs = [
    { freq: 300, delay: 0 },
    { freq: 250, delay: 150 },
    { freq: 320, delay: 300 },
    { freq: 280, delay: 450 },
    { freq: 350, delay: 600 },
  ];
  
  laughs.forEach(laugh => {
    setTimeout(() => {
      playTone(laugh.freq, 0.1, 'sawtooth', 0.15);
      playTone(laugh.freq * 1.5, 0.08, 'square', 0.08);
    }, laugh.delay);
  });
  
  // Evil rising pitch at end
  setTimeout(() => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.5);
    
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
    
    osc.connect(gain);
    gain.connect(sfxGain);
    
    osc.start();
    osc.stop(audioCtx.currentTime + 0.5);
  }, 800);
}

// ============================================================
// DRAWING HELPERS â€” Hand-drawn aesthetic
// ============================================================

function wobble(amt = 1.5) { return (Math.random() - 0.5) * amt * scale; }

// Wobbly line
function wobblyLine(x1, y1, x2, y2, color = '#222', width = 2) {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = width * scale;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(x1 + wobble(), y1 + wobble());
  const steps = Math.max(3, Math.floor(Math.hypot(x2 - x1, y2 - y1) / (20 * scale)));
  for (let i = 1; i <= steps; i++) {
    const t = i / steps;
    ctx.lineTo(
      x1 + (x2 - x1) * t + wobble(),
      y1 + (y2 - y1) * t + wobble()
    );
  }
  ctx.stroke();
  ctx.restore();
}

// Wobbly rectangle
function wobblyRect(x, y, w, h, color = '#222', fill = null, lineWidth = 2) {
  if (fill) {
    ctx.save();
    ctx.fillStyle = fill;
    ctx.beginPath();
    ctx.moveTo(x + wobble(), y + wobble());
    ctx.lineTo(x + w + wobble(), y + wobble());
    ctx.lineTo(x + w + wobble(), y + h + wobble());
    ctx.lineTo(x + wobble(), y + h + wobble());
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
  wobblyLine(x, y, x + w, y, color, lineWidth);
  wobblyLine(x + w, y, x + w, y + h, color, lineWidth);
  wobblyLine(x + w, y + h, x, y + h, color, lineWidth);
  wobblyLine(x, y + h, x, y, color, lineWidth);
}

// Wobbly circle
function wobblyCircle(cx, cy, r, color = '#222', fill = null, lineWidth = 2) {
  ctx.save();
  const pts = 24;
  ctx.beginPath();
  for (let i = 0; i <= pts; i++) {
    const a = (i / pts) * Math.PI * 2;
    const rr = r + wobble(2);
    const px = cx + Math.cos(a) * rr;
    const py = cy + Math.sin(a) * rr;
    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.closePath();
  if (fill) { ctx.fillStyle = fill; ctx.fill(); }
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth * scale;
  ctx.lineCap = 'round';
  ctx.stroke();
  ctx.restore();
}

// Sketch-style button
function drawSketchButton(x, y, w, h, label, color = '#222', fillColor = '#f5f0e6', highlight = false) {
  const bx = x - w/2, by = y - h/2;
  if (highlight) {
    wobblyRect(bx - 3*scale, by - 3*scale, w + 6*scale, h + 6*scale, color, '#ffd700', 3);
  }
  wobblyRect(bx, by, w, h, color, fillColor, 2.5);
  ctx.save();
  ctx.fillStyle = color;
  ctx.font = `bold ${16 * scale}px 'Comic Sans MS', 'Marker Felt', cursive, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(label, x + wobble(0.5), y + wobble(0.5));
  ctx.restore();
}

// Clean UI button (for fake system stuff)
function drawCleanButton(x, y, w, h, label, bg = '#007AFF', fg = '#fff', radius = 8) {
  ctx.save();
  ctx.fillStyle = bg;
  roundRect(x - w/2, y - h/2, w, h, radius * scale);
  ctx.fill();
  ctx.fillStyle = fg;
  ctx.font = `600 ${15 * scale}px -apple-system, 'Segoe UI', sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(label, x, y);
  ctx.restore();
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.arcTo(x + w, y, x + w, y + r, r);
  ctx.lineTo(x + w, y + h - r);
  ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
  ctx.lineTo(x + r, y + h);
  ctx.arcTo(x, y + h, x, y + h - r, r);
  ctx.lineTo(x, y + r);
  ctx.arcTo(x, y, x + r, y, r);
  ctx.closePath();
}

// Draw text with sketch feel
function drawText(text, x, y, size = 16, color = '#222', align = 'center', font = null) {
  ctx.save();
  ctx.fillStyle = color;
  ctx.font = `${size * scale}px ${font || "'Comic Sans MS', 'Marker Felt', cursive, sans-serif"}`;
  ctx.textAlign = align;
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x + wobble(0.3), y + wobble(0.3));
  ctx.restore();
}

function drawCleanText(text, x, y, size = 16, color = '#333', align = 'center', fontWeight = '400') {
  ctx.save();
  ctx.fillStyle = color;
  ctx.font = `${fontWeight} ${size * scale}px -apple-system, 'Segoe UI', 'Helvetica Neue', sans-serif`;
  ctx.textAlign = align;
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x, y);
  ctx.restore();
}

// ============================================================
// STICK FIGURE
// ============================================================
function drawStickFigure(x, y, scl = 1, eyeState = 'normal') {
  if (!stickFigure.visible) return;
  const s = 20 * scale * scl;
  const breath = Math.sin(stickFigure.breathPhase) * 1.5 * scale;
  
  ctx.save();
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 2 * scale;
  ctx.lineCap = 'round';
  
  // Legs
  ctx.beginPath();
  ctx.moveTo(x, y + s * 0.7);
  ctx.lineTo(x - s * 0.35 + wobble(0.5), y + s * 1.4 + wobble(0.5));
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x, y + s * 0.7);
  ctx.lineTo(x + s * 0.35 + wobble(0.5), y + s * 1.4 + wobble(0.5));
  ctx.stroke();
  
  // Body
  ctx.beginPath();
  ctx.moveTo(x + wobble(0.3), y - s * 0.2 + breath);
  ctx.lineTo(x + wobble(0.3), y + s * 0.7);
  ctx.stroke();
  
  // Arms
  const armWave = Math.sin(gameTime * 2) * (eyeState === 'panic' ? 8 : 2) * scale;
  ctx.beginPath();
  ctx.moveTo(x, y + s * 0.15 + breath);
  ctx.lineTo(x - s * 0.45 + wobble(0.5), y + s * 0.4 + armWave + wobble(0.5));
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x, y + s * 0.15 + breath);
  ctx.lineTo(x + s * 0.45 + wobble(0.5), y + s * 0.4 - armWave + wobble(0.5));
  ctx.stroke();
  
  // Head
  const headY = y - s * 0.55 + breath;
  wobblyCircle(x, headY, s * 0.35, '#222', '#f5f0e6', 2);
  
  // Eyes
  const eyeSpread = s * 0.12;
  const eyeY = headY - s * 0.02;
  const lookX = stickFigure.lookDir * s * 0.04;
  
  if (eyeState === 'normal') {
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.arc(x - eyeSpread + lookX, eyeY, 2 * scale, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + eyeSpread + lookX, eyeY, 2 * scale, 0, Math.PI * 2); ctx.fill();
  } else if (eyeState === 'panic') {
    // Wide eyes
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.arc(x - eyeSpread, eyeY, 3.5 * scale, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + eyeSpread, eyeY, 3.5 * scale, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#f5f0e6';
    ctx.beginPath(); ctx.arc(x - eyeSpread + scale, eyeY - scale, 1.2 * scale, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + eyeSpread + scale, eyeY - scale, 1.2 * scale, 0, Math.PI * 2); ctx.fill();
  } else if (eyeState === 'dead') {
    // X eyes
    const es = 3 * scale;
    ctx.lineWidth = 2 * scale;
    ctx.beginPath(); ctx.moveTo(x - eyeSpread - es, eyeY - es); ctx.lineTo(x - eyeSpread + es, eyeY + es); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x - eyeSpread + es, eyeY - es); ctx.lineTo(x - eyeSpread - es, eyeY + es); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x + eyeSpread - es, eyeY - es); ctx.lineTo(x + eyeSpread + es, eyeY + es); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x + eyeSpread + es, eyeY - es); ctx.lineTo(x + eyeSpread - es, eyeY + es); ctx.stroke();
  } else if (eyeState === 'happy') {
    // ^ ^ eyes
    ctx.lineWidth = 2 * scale;
    ctx.beginPath(); ctx.moveTo(x - eyeSpread - 3*scale, eyeY + scale); ctx.lineTo(x - eyeSpread, eyeY - 2*scale); ctx.lineTo(x - eyeSpread + 3*scale, eyeY + scale); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x + eyeSpread - 3*scale, eyeY + scale); ctx.lineTo(x + eyeSpread, eyeY - 2*scale); ctx.lineTo(x + eyeSpread + 3*scale, eyeY + scale); ctx.stroke();
  } else if (eyeState === 'confused') {
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.arc(x - eyeSpread, eyeY, 2 * scale, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + eyeSpread, eyeY + 2*scale, 2 * scale, 0, Math.PI * 2); ctx.fill();
    // Question mark above head
    drawText('?', x + s*0.3, headY - s*0.5, 12, '#222');
  }
  
  // Mouth based on state
  if (eyeState === 'panic') {
    ctx.beginPath(); ctx.arc(x, headY + s*0.15, 3*scale, 0, Math.PI); ctx.stroke();
  } else if (eyeState === 'happy') {
    ctx.beginPath(); ctx.arc(x, headY + s*0.1, 4*scale, 0, Math.PI); ctx.stroke();
  }
  
  ctx.restore();
}

// ============================================================
// PARTICLES
// ============================================================
function spawnParticles(x, y, count, color = '#ff4444', spread = 3) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * spread * scale,
      vy: (Math.random() - 0.5) * spread * scale - 2 * scale,
      life: 1,
      decay: 0.02 + Math.random() * 0.02,
      size: (2 + Math.random() * 4) * scale,
      color
    });
  }
}

function updateParticles() {
  const d60 = deltaTime * 60;
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * d60;
    p.y += p.vy * d60;
    p.vy += 0.15 * scale * d60;
    p.life -= p.decay * d60;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    ctx.restore();
  }
}

// ============================================================
// SCREEN SHAKE
// ============================================================
function shake(amount = 10) {
  shakeAmount = amount * scale;
}

function applyShake() {
  if (shakeAmount > 0.5) {
    const sx = (Math.random() - 0.5) * shakeAmount;
    const sy = (Math.random() - 0.5) * shakeAmount;
    ctx.translate(sx, sy);
    shakeAmount *= shakeDecay;
  } else {
    shakeAmount = 0;
  }
}

// ============================================================
// TRANSITIONS
// ============================================================
function fadeToRoom(roomIndex) {
  if (transitioning) return;
  transitioning = true;
  transitionDir = 1;
  transitionAlpha = 0;
  transitionCallback = () => {
    currentRoom = roomIndex;
    roomDeaths = 0;
    hintLevel = 0;
    roomState = {};
    showingDeath = false;
    if (roomIndex > highestRoom) { highestRoom = roomIndex; }
    saveGameProgress();
    initRoom(roomIndex);
    transitionDir = -1;
  };
}

function updateTransition() {
  if (!transitioning) return;
  if (transitionDir === 1) {
    transitionAlpha += 0.05;
    if (transitionAlpha >= 1) {
      transitionAlpha = 1;
      if (transitionCallback) { transitionCallback(); transitionCallback = null; }
    }
  } else {
    transitionAlpha -= 0.05;
    if (transitionAlpha <= 0) {
      transitionAlpha = 0;
      transitioning = false;
    }
  }
}

function drawTransition() {
  if (transitionAlpha > 0) {
    ctx.save();
    ctx.globalAlpha = transitionAlpha;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);
    ctx.restore();
  }
}

// ============================================================
// DEATH SYSTEM
// ============================================================
function die(message, animType = 'default', shakeAmt = 12) {
  if (showingDeath || transitioning) return;
  ensureAudio();
  sfxDeath();
  showingDeath = true;
  deathMessage = message;
  deathAnimType = animType;
  deathAnimTimer = 0;
  totalDeaths++;
  roomDeaths++;
  hintLevel = Math.min(10, Math.floor(roomDeaths / 2));
  shake(shakeAmt);
  spawnParticles(stickFigure.x || centerX, stickFigure.y || centerY, 15, '#ff4444');
  stickFigure.eyeState = 'dead';
  
  // Achievement checks
  if (totalDeaths === 1) unlock('firstdeath');
  if (totalDeaths >= 50) unlock('persistent');
  if (totalDeaths >= 100) unlock('masochist');

  // Auto-respawn after delay
  setTimeout(() => {
    showingDeath = false;
    deathAnimTimer = 0;
    stickFigure.eyeState = 'normal';
    stickFigure.visible = true;
    roomState = {};
    initRoom(currentRoom);
  }, 1800);
}

function drawDeathOverlay() {
  if (!showingDeath) return;
  deathAnimTimer += deltaTime;
  
  ctx.save();
  ctx.globalAlpha = Math.min(1, deathAnimTimer * 3);
  
  // Dark overlay
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, 0, W, H);
  
  // Death icon (varied)
  const deathIcons = ['ðŸ’€', 'â˜ ï¸', 'ðŸ’¥', 'ðŸª¦', 'ðŸ˜µ', 'ðŸ« '];
  const iconIdx = totalDeaths % deathIcons.length;
  const skullY = centerY - 40 * scale;
  const iconBounce = Math.sin(deathAnimTimer * 8) * 5 * scale * Math.max(0, 1 - deathAnimTimer);
  ctx.font = `${(40 + iconBounce) * scale}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillStyle = '#fff';
  ctx.fillText(deathIcons[iconIdx], centerX, skullY + iconBounce);
  
  // Death message
  ctx.font = `bold ${14 * scale}px 'Comic Sans MS', cursive, sans-serif`;
  ctx.fillStyle = '#ff6b6b';
  ctx.textAlign = 'center';
  
  // Word wrap
  const words = deathMessage.split(' ');
  let lines = [];
  let line = '';
  for (const word of words) {
    const test = line + word + ' ';
    if (ctx.measureText(test).width > W * 0.8) {
      lines.push(line.trim());
      line = word + ' ';
    } else {
      line = test;
    }
  }
  lines.push(line.trim());
  
  const lineH = 20 * scale;
  const startY = skullY + 40 * scale;
  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], centerX, startY + i * lineH);
  }
  
  ctx.restore();
}

// Death counter skull + room progress (always visible)
function drawDeathCounter() {
  ctx.save();
  ctx.font = `${12 * scale}px sans-serif`;
  ctx.textAlign = 'right';
  ctx.fillStyle = totalDeaths > 20 ? '#cc4444' : '#666';
  ctx.fillText(`ðŸ’€ ${totalDeaths}`, W - 12 * scale, 24 * scale);
  
  // Room progress dots
  if (!chapterComplete && currentRoom > 0) {
    const dotSize = 4 * scale;
    const dotGap = 10 * scale;
    const totalRooms = 13;
    const dotsWidth = totalRooms * dotGap;
    const startX = centerX - dotsWidth / 2;
    const dotY = H - 12 * scale;
    for (let i = 0; i < totalRooms; i++) {
      ctx.fillStyle = i < currentRoom ? '#22aa22' : (i === currentRoom ? '#ffd700' : 'rgba(0,0,0,0.15)');
      ctx.beginPath();
      ctx.arc(startX + i * dotGap, dotY, i === currentRoom ? dotSize * 1.3 : dotSize, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  ctx.restore();
}

// Mute button (always visible)
function drawMuteButton() {
  const btnX = 20 * scale;
  const btnY = 20 * scale;
  const btnSize = 30 * scale;
  
  // Check if mouse/touch is hovering
  const isHovering = lastMouseX >= btnX - btnSize/2 && lastMouseX <= btnX + btnSize/2 &&
                     lastMouseY >= btnY - btnSize/2 && lastMouseY <= btnY + btnSize/2;
  
  ctx.save();
  
  // Button background
  ctx.fillStyle = isHovering ? 'rgba(255,255,255,0.2)' : 'rgba(255,255,255,0.1)';
  ctx.beginPath();
  ctx.arc(btnX, btnY, btnSize/2, 0, Math.PI * 2);
  ctx.fill();
  
  // Icon
  ctx.font = `${18 * scale}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = audioMuted ? '#cc3333' : '#666';
  ctx.fillText(audioMuted ? 'ðŸ”‡' : 'ðŸ”Š', btnX, btnY);
  
  ctx.restore();
  
  // Store button bounds for click detection
  muteButtonBounds = { x: btnX, y: btnY, size: btnSize };
}

let muteButtonBounds = null;
let lastMouseX = 0;
let lastMouseY = 0;

// ============================================================
// SKETCHBOOK BACKGROUND
// ============================================================
function drawSketchBackground() {
  // Paper color
  ctx.fillStyle = '#f5f0e6';
  ctx.fillRect(0, 0, W, H);
  
  // Subtle ruled lines
  ctx.save();
  ctx.strokeStyle = 'rgba(180,210,240,0.3)';
  ctx.lineWidth = 1;
  const lineSpacing = 28 * scale;
  for (let y = lineSpacing; y < H; y += lineSpacing) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }
  // Left margin line
  ctx.strokeStyle = 'rgba(220,140,140,0.3)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(40 * scale, 0);
  ctx.lineTo(40 * scale, H);
  ctx.stroke();
  ctx.restore();
}

// ============================================================
// INPUT HANDLING
// ============================================================
function getEventPos(e) {
  if (e.touches) {
    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
  return { x: e.clientX, y: e.clientY };
}

function hitTest(px, py, x, y, w, h) {
  return px >= x - w/2 && px <= x + w/2 && py >= y - h/2 && py <= y + h/2;
}

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  ensureAudio();
  const pos = getEventPos(e);
  lastMouseX = pos.x;
  lastMouseY = pos.y;
  
  // Check mute button
  if (muteButtonBounds) {
    const dist = Math.hypot(pos.x - muteButtonBounds.x, pos.y - muteButtonBounds.y);
    if (dist < muteButtonBounds.size / 2) {
      toggleMute();
      sfxClick();
      return;
    }
  }
  
  inputEvents.push({ type: 'tap', x: pos.x, y: pos.y });
  dragState.active = true;
  dragState.startX = pos.x;
  dragState.startY = pos.y;
  dragState.x = pos.x;
  dragState.y = pos.y;
  dragState.dx = 0;
  dragState.dy = 0;
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (dragState.active) {
    const pos = getEventPos(e);
    dragState.dx = pos.x - dragState.x;
    dragState.dy = pos.y - dragState.y;
    dragState.x = pos.x;
    dragState.y = pos.y;
    lastMouseX = pos.x;
    lastMouseY = pos.y;
    sfxDrag();
    inputEvents.push({ type: 'drag', x: pos.x, y: pos.y, dx: dragState.dx, dy: dragState.dy, startX: dragState.startX, startY: dragState.startY });
  }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  if (dragState.active) {
    inputEvents.push({ type: 'release', x: dragState.x, y: dragState.y, startX: dragState.startX, startY: dragState.startY });
    dragState.active = false;
  }
});

canvas.addEventListener('mousedown', (e) => {
  ensureAudio();
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
  
  // Check mute button
  if (muteButtonBounds) {
    const dist = Math.hypot(e.clientX - muteButtonBounds.x, e.clientY - muteButtonBounds.y);
    if (dist < muteButtonBounds.size / 2) {
      toggleMute();
      sfxClick();
      return;
    }
  }
  
  inputEvents.push({ type: 'tap', x: e.clientX, y: e.clientY });
  dragState.active = true;
  dragState.startX = e.clientX;
  dragState.startY = e.clientY;
  dragState.x = e.clientX;
  dragState.y = e.clientY;
  dragState.dx = 0;
  dragState.dy = 0;
});

canvas.addEventListener('mousemove', (e) => {
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
  
  if (dragState.active) {
    dragState.dx = e.clientX - dragState.x;
    dragState.dy = e.clientY - dragState.y;
    dragState.x = e.clientX;
    dragState.y = e.clientY;
    sfxDrag();
    inputEvents.push({ type: 'drag', x: e.clientX, y: e.clientY, dx: dragState.dx, dy: dragState.dy, startX: dragState.startX, startY: dragState.startY });
  }
});

canvas.addEventListener('mouseup', (e) => {
  if (dragState.active) {
    inputEvents.push({ type: 'release', x: dragState.x, y: dragState.y, startX: dragState.startX, startY: dragState.startY });
    dragState.active = false;
  }
});

// ============================================================
// ROOMS
// ============================================================

const rooms = [];

// --- ROOM 0: Press Start ---
rooms[0] = {
  init() {
    roomState.tapCount = 0;
    roomState.holdTimer = 0;
    roomState.holding = false;
    roomState.btnPulse = 0;
    stickFigure.x = centerX;
    stickFigure.y = centerY + 30 * scale;
    stickFigure.visible = true;
    stickFigure.eyeState = 'normal';
  },
  update() {
    roomState.btnPulse = (roomState.btnPulse || 0) + deltaTime * 3;
    stickFigure.breathPhase += deltaTime * 2;
    stickFigure.lookDir = Math.sin(gameTime * 0.7) * 0.5;
    
    if (roomState.holding) {
      roomState.holdTimer += deltaTime;
      if (roomState.holdTimer > 1.5) {
        roomState.holding = false;
        die('ðŸ’€ Oh, you held it. That\'s worse.', 'explode', 18);
        sfxExplosion();
        return;
      }
    }
    
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      if (ev.type === 'tap') {
        // START button area
        const btnW = 200 * scale, btnH = 60 * scale;
        const btnX = centerX, btnY = centerY + 50 * scale;
        if (hitTest(ev.x, ev.y, btnX, btnY, btnW, btnH)) {
          sfxClick();
          roomState.holding = true;
          roomState.holdTimer = 0;
          roomState.tapCount = (roomState.tapCount || 0) + 1;
          
          // Don't die on tap â€” die on release (so hold can be detected)
        }
        
        // Skip text area
        const skipX = W - 45 * scale, skipY = H - 35 * scale;
        if (hitTest(ev.x, ev.y, skipX, skipY, 70 * scale, 30 * scale)) {
          sfxWin();
          spawnParticles(ev.x, ev.y, 8, '#44ff44');
          fadeToRoom(1);
          return;
        }

        // Speedrun toggle
        const srX = 50 * scale, srY = H - 35 * scale;
        if (hitTest(ev.x, ev.y, srX, srY, 80 * scale, 30 * scale)) {
          sfxClick();
          speedrunMode = !speedrunMode;
          if (speedrunMode) speedrunStartTime = gameTime;
          return;
        }
      }
      if (ev.type === 'release') {
        if (roomState.holding) {
          roomState.holding = false;
          const count = roomState.tapCount;
          if (count === 1) {
            sfxExplosion();
            die('ðŸ’€ That button was load-bearing.', 'explode');
          } else if (count === 2) {
            sfxExplosion();
            die('ðŸ’€ Safety equipment not rated for this.', 'explode');
          } else {
            sfxExplosion();
            die('ðŸ’€ You\'d think you\'d learn.', 'explode', 20);
          }
        }
      }
    }
  },
  draw() {
    drawSketchBackground();
    
    // Title
    const titleY = centerY - 100 * scale;
    ctx.save();
    ctx.font = `bold ${36 * scale}px 'Comic Sans MS', 'Marker Felt', cursive, sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = '#222';
    ctx.fillText('TRUST', centerX + wobble(0.5), titleY - 20 * scale + wobble(0.5));
    ctx.fillStyle = '#cc3333';
    ctx.fillText('NOTHING', centerX + wobble(0.5), titleY + 25 * scale + wobble(0.5));
    ctx.restore();
    
    // Stick figure on the button
    stickFigure.x = centerX;
    stickFigure.y = centerY - 5 * scale;
    drawStickFigure(stickFigure.x, stickFigure.y, 0.8, stickFigure.eyeState);
    
    // START button - big, pulsing, golden
    const btnY = centerY + 50 * scale;
    const pulse = Math.sin(roomState.btnPulse || 0) * 4 * scale;
    const btnW = (200 + pulse) * scale;
    const btnH = (60 + pulse * 0.5) * scale;
    
    // Glow
    ctx.save();
    ctx.shadowColor = '#ffd700';
    ctx.shadowBlur = 20 * scale + pulse * 2;
    ctx.fillStyle = '#ffd700';
    roundRect(centerX - btnW/2, btnY - btnH/2, btnW, btnH, 12 * scale);
    ctx.fill();
    ctx.restore();
    
    // Button body
    ctx.save();
    ctx.fillStyle = '#ff8c00';
    roundRect(centerX - btnW/2, btnY - btnH/2, btnW, btnH, 12 * scale);
    ctx.fill();
    ctx.strokeStyle = '#cc6600';
    ctx.lineWidth = 3 * scale;
    roundRect(centerX - btnW/2, btnY - btnH/2, btnW, btnH, 12 * scale);
    ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${22 * scale}px 'Comic Sans MS', cursive, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('START GAME', centerX, btnY);
    ctx.restore();
    
    // Particle sparkles around button
    if (Math.random() < 0.3) {
      spawnParticles(
        centerX + (Math.random()-0.5) * btnW,
        btnY + (Math.random()-0.5) * btnH,
        1, '#ffd700', 1
      );
    }
    
    // Speedrun toggle
    ctx.save();
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = speedrunMode ? '#00ff88' : '#888';
    ctx.font = `${10 * scale}px sans-serif`;
    ctx.textAlign = 'left';
    ctx.fillText(speedrunMode ? 'â± ON' : 'â± speedrun', 15 * scale, H - 25 * scale);
    ctx.restore();

    // Skip text â€” becomes more visible with deaths
    const skipAlpha = 0.12 + hintLevel * 0.12 + (roomState.tapCount > 0 ? 0.15 : 0);
    ctx.save();
    ctx.globalAlpha = Math.min(0.9, skipAlpha);
    ctx.fillStyle = hintLevel >= 2 ? '#22aa22' : '#999';
    const skipSize = hintLevel >= 3 ? 11 : 8;
    ctx.font = `${skipSize * scale}px sans-serif`;
    ctx.textAlign = 'right';
    const skipBob = hintLevel >= 3 ? Math.sin(gameTime * 3) * 3 * scale : 0;
    ctx.fillText('skip â†’', W - 15 * scale, H - 25 * scale + skipBob);
    if (hintLevel >= 5) {
      ctx.globalAlpha = 0.3 + Math.sin(gameTime * 4) * 0.2;
      ctx.beginPath();
      ctx.arc(W - 35 * scale, H - 28 * scale, 20 * scale, 0, Math.PI * 2);
      ctx.fillStyle = '#44ff44';
      ctx.fill();
    }
    ctx.restore();
  }
};

// --- ROOM 1: The Door ---
rooms[1] = {
  init() {
    roomState.titleX = 0;
    roomState.dragging = false;
    roomState.doorFell = false;
    roomState.wallTaps = 0;
    stickFigure.x = centerX - 60 * scale;
    stickFigure.y = centerY + 40 * scale;
    stickFigure.visible = true;
    stickFigure.eyeState = 'normal';
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    stickFigure.lookDir = Math.sin(gameTime * 0.5);
    
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      
      // Title bar drag detection
      const titleBarY = 45 * scale;
      const titleBarH = 35 * scale;
      
      if (ev.type === 'tap') {
        // Tap on title bar area
        if (ev.y < titleBarY + titleBarH && ev.y > titleBarY - titleBarH/2) {
          roomState.dragging = true;
          sfxClick();
        }
        
        // Tap on door
        const doorX = centerX + 80 * scale;
        const doorY = centerY + 10 * scale;
        if (hitTest(ev.x, ev.y, doorX, doorY, 60 * scale, 100 * scale)) {
          sfxClick();
          die('ðŸ’€ It wasn\'t even a real door. It was just leaning there.');
        }
        
        // Tap on door handle
        const handleX = centerX + 60 * scale;
        const handleY = centerY + 15 * scale;
        if (hitTest(ev.x, ev.y, handleX, handleY, 20 * scale, 20 * scale)) {
          die('ðŸ’€ Handle with care. Or don\'t.');
        }
        
        // Tap on walls
        if (ev.y > 100 * scale && ev.y < H - 50 * scale) {
          if (ev.x < centerX - 100 * scale || (ev.x > centerX + 120 * scale)) {
            roomState.wallTaps = (roomState.wallTaps || 0) + 1;
            if (roomState.wallTaps >= 2) {
              die('ðŸ’€ The walls have feelings too. And grudges.');
            }
          }
        }
      }
      
      if (ev.type === 'drag' && roomState.dragging) {
        roomState.titleX = (roomState.titleX || 0) + ev.dx;
      }
      
      if (ev.type === 'release' && roomState.dragging) {
        roomState.dragging = false;
        // Check if dragged enough to solve
        if ((roomState.titleX || 0) > W * 0.35) {
          sfxWin();
          spawnParticles(centerX, 45 * scale, 15, '#44ff44');
          fadeToRoom(2);
          return;
        }
      }
    }
  },
  draw() {
    drawSketchBackground();
    
    // Room walls
    const floorY = centerY + 100 * scale;
    wobblyLine(50 * scale, 90 * scale, 50 * scale, floorY, '#555', 3);
    wobblyLine(W - 50 * scale, 90 * scale, W - 50 * scale, floorY, '#555', 3);
    wobblyLine(50 * scale, floorY, W - 50 * scale, floorY, '#555', 3);
    
    // Brick pattern on walls
    for (let y = 100 * scale; y < floorY; y += 18 * scale) {
      const offset = (Math.floor(y / (18 * scale)) % 2) * 15 * scale;
      for (let x = 55 * scale + offset; x < W - 50 * scale; x += 30 * scale) {
        wobblyRect(x, y, 25 * scale, 14 * scale, 'rgba(150,100,80,0.3)');
      }
    }
    
    // Door (scenery)
    const doorX = centerX + 50 * scale;
    const doorY = centerY - 30 * scale;
    const doorW = 55 * scale;
    const doorH = 90 * scale;
    wobblyRect(doorX, doorY, doorW, doorH, '#8B4513', '#a0522d', 2.5);
    // Handle
    wobblyCircle(doorX + doorW - 12 * scale, doorY + doorH/2, 5 * scale, '#DAA520', '#DAA520');
    
    // Stick figure
    drawStickFigure(stickFigure.x, stickFigure.y, 1, stickFigure.eyeState);
    
    // Title bar (draggable)
    const txOff = roomState.titleX || 0;
    const titleBarX = txOff;
    ctx.save();
    ctx.fillStyle = 'rgba(240,235,220,0.95)';
    ctx.fillRect(titleBarX, 20 * scale, W + 20, 40 * scale);
    ctx.strokeStyle = '#aaa';
    ctx.lineWidth = 1;
    ctx.strokeRect(titleBarX, 20 * scale, W + 20, 40 * scale);
    ctx.restore();
    
    // Title text
    const wobbleAmt = hintLevel > 2 ? Math.sin(gameTime * 4) * 2 * scale : 0;
    drawText('Room 2: The Door', centerX + txOff + wobbleAmt, 42 * scale, 18, '#444');
    
    // Hint: reveal exit behind title bar when dragged
    if (txOff > 20) {
      const revealW = Math.min(txOff, W * 0.5);
      ctx.save();
      ctx.fillStyle = '#44dd44';
      ctx.globalAlpha = 0.4;
      ctx.fillRect(0, 20 * scale, revealW, 40 * scale);
      ctx.restore();
      // Exit glow
      wobblyRect(5 * scale, 25 * scale, Math.min(revealW - 10, 40 * scale), 30 * scale, '#22aa22', 'rgba(68,221,68,0.6)');
      drawText('EXIT', 25 * scale + Math.min(revealW/2, 20*scale), 42 * scale, 10, '#fff');
    }
  }
};

// --- ROOM 2: Timer Panic ---
rooms[2] = {
  init() {
    roomState.timer = 10;
    roomState.expired = false;
    roomState.tickInterval = 0;
    stickFigure.x = centerX;
    stickFigure.y = centerY + 80 * scale;
    stickFigure.visible = true;
    stickFigure.eyeState = 'panic';
    startRoomAmbient(2);
  },
  update() {
    stickFigure.breathPhase += deltaTime * 4; // breathing fast
    
    if (!roomState.expired) {
      roomState.timer -= deltaTime;
      roomState.tickInterval += deltaTime;
      if (roomState.tickInterval > 0.5) {
        roomState.tickInterval = 0;
        // Ticking handled by ambient now
      }
      if (roomState.timer <= 0) {
        roomState.timer = 0;
        roomState.expired = true;
        stickFigure.eyeState = 'happy';
        sfxChime();
        stopAllAmbient();
        // Chirpy birds after a moment
        setTimeout(() => {
          if (currentRoom === 2 && roomState.expired && !showingDeath) {
            sfxWin();
          }
        }, 800);
      }
    }
    
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      
      if (ev.type === 'tap') {
        if (roomState.expired) {
          // Tap the door that appeared
          const doorX = centerX;
          const doorY = centerY;
          if (hitTest(ev.x, ev.y, doorX, doorY, 80 * scale, 100 * scale)) {
            sfxWin();
            fadeToRoom(3);
            return;
          }
        }
        
        // DEFUSE button
        const defuseX = centerX - 70 * scale;
        const defuseY = centerY + 40 * scale;
        if (hitTest(ev.x, ev.y, defuseX, defuseY, 110 * scale, 45 * scale)) {
          sfxExplosion();
          die('ðŸ’€ Bold choice. Wrong wire. All the wires were wrong.');
        }
        
        // ESCAPE button
        const escapeX = centerX + 70 * scale;
        const escapeY = centerY + 40 * scale;
        if (hitTest(ev.x, ev.y, escapeX, escapeY, 110 * scale, 45 * scale)) {
          die('ðŸ’€ That was the escape alright. Straight down.');
        }
        
        // Tap the timer
        const timerX = centerX;
        const timerY = centerY - 60 * scale;
        if (hitTest(ev.x, ev.y, timerX, timerY, 160 * scale, 60 * scale)) {
          roomState.timer = Math.max(0.5, roomState.timer - 5);
          sfxExplosion();
          die('ðŸ’€ You made it angry.');
        }
      }
    }
  },
  draw() {
    // Red urgent background
    if (!roomState.expired) {
      const urgency = Math.sin(gameTime * 8) * 0.1;
      ctx.fillStyle = `rgb(${180 + urgency * 100}, ${30}, ${30})`;
      ctx.fillRect(0, 0, W, H);
      
      // Screen shake from urgency
      if (roomState.timer < 3) {
        ctx.save();
        ctx.translate((Math.random()-0.5) * 3 * scale, (Math.random()-0.5) * 3 * scale);
      }
    } else {
      // Peaceful meadow
      ctx.fillStyle = '#90ee90';
      ctx.fillRect(0, 0, W, H);
      // Sky
      const grad = ctx.createLinearGradient(0, 0, 0, H * 0.5);
      grad.addColorStop(0, '#87CEEB');
      grad.addColorStop(1, '#90ee90');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H * 0.6);
      
      // Simple flowers
      for (let i = 0; i < 8; i++) {
        const fx = W * 0.1 + (i / 8) * W * 0.8;
        const fy = H * 0.65 + Math.sin(i * 2) * 20 * scale;
        wobblyCircle(fx, fy, 5 * scale, '#ff69b4', '#ff69b4');
        wobblyLine(fx, fy + 5 * scale, fx, fy + 20 * scale, '#228B22', 1.5);
      }
      
      // Door
      wobblyRect(centerX - 25 * scale, centerY - 50 * scale, 50 * scale, 80 * scale, '#8B4513', '#a0522d', 2);
      drawText('ðŸšª', centerX, centerY, 20);
    }
    
    if (!roomState.expired) {
      // Timer display
      const mins = '00';
      const secs = String(Math.max(0, Math.ceil(roomState.timer))).padStart(2, '0');
      
      ctx.save();
      ctx.font = `bold ${64 * scale}px 'Courier New', monospace`;
      ctx.textAlign = 'center';
      ctx.fillStyle = '#fff';
      ctx.fillText(`${mins}:${secs}`, centerX, centerY - 60 * scale);
      ctx.restore();
      
      // Defuse button
      drawSketchButton(centerX - 70 * scale, centerY + 40 * scale, 110 * scale, 45 * scale, 'DEFUSE', '#fff', '#cc0000');
      
      // Escape button
      drawSketchButton(centerX + 70 * scale, centerY + 40 * scale, 110 * scale, 45 * scale, 'ESCAPE', '#fff', '#0044cc');
      
      // Hint
      if (hintLevel >= 3 && roomState.timer < 3) {
        ctx.save();
        ctx.globalAlpha = 0.4;
        drawText('â™ª', centerX + 80 * scale, centerY - 80 * scale, 12, '#ffd700');
        ctx.restore();
      }
      
      if (roomState.timer < 3) ctx.restore();
    }
    
    // Stick figure
    stickFigure.x = centerX;
    stickFigure.y = roomState.expired ? centerY + 40 * scale : centerY + 80 * scale;
    drawStickFigure(stickFigure.x, stickFigure.y, 0.7, stickFigure.eyeState);
    
    // Room label
    drawText('Room 3: Timer Panic', centerX, 20 * scale, 12, roomState.expired ? '#333' : '#faa');
  }
};

// --- ROOM 3: Fake Ad ---
rooms[3] = {
  init() {
    roomState.showAd = false;
    roomState.adTimer = 0;
    roomState.xTaps = 0;
    stickFigure.x = centerX;
    stickFigure.y = centerY;
    stickFigure.visible = true;
    stickFigure.eyeState = 'normal';
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    roomState.adTimer += deltaTime;
    
    if (roomState.adTimer > 1 && !roomState.showAd) {
      roomState.showAd = true;
      sfxDing();
    }
    
    for (const ev of inputEvents) {
      if (showingDeath || !roomState.showAd) continue;
      
      if (ev.type === 'tap') {
        const popW = 280 * scale;
        const popH = 220 * scale;
        const popX = centerX;
        const popY = centerY;
        
        // CLAIM NOW button
        const claimX = popX;
        const claimY = popY + 40 * scale;
        if (hitTest(ev.x, ev.y, claimX, claimY, 160 * scale, 40 * scale)) {
          sfxExplosion();
          die('ðŸ’€ You\'ve subscribed to 47 newsletters.');
          return;
        }
        
        // Fake X (obvious, bottom right of popup)
        const fakeXx = popX + popW/2 - 20 * scale;
        const fakeXy = popY + popH/2 - 20 * scale;
        if (hitTest(ev.x, ev.y, fakeXx, fakeXy, 30 * scale, 30 * scale)) {
          roomState.xTaps = (roomState.xTaps || 0) + 1;
          if (roomState.xTaps === 1) {
            die('ðŸ’€ That X was a lie. Like all the Xs before it.');
          } else {
            die('ðŸ’€ The Xs are multiplying.');
          }
          return;
        }
        
        // Real X (subtle, offset from the fake one)
        const realXx = popX + popW/2 - 50 * scale;
        const realXy = popY + popH/2 - 20 * scale;
        if (hitTest(ev.x, ev.y, realXx, realXy, 18 * scale, 18 * scale)) {
          sfxWin();
          spawnParticles(ev.x, ev.y, 12, '#44ff44');
          fadeToRoom(4);
          return;
        }
        
        // Tap anywhere else on the popup â€” swipe death
        if (hitTest(ev.x, ev.y, popX, popY, popW, popH)) {
          die('ðŸ’€ Nice try. This ad has a no-swipe policy.');
          return;
        }
      }
    }
  },
  draw() {
    drawSketchBackground();
    drawText('Room 4: Fake Ad', centerX, 25 * scale, 12, '#999');
    
    // Brief room glimpse
    wobblyRect(centerX - 30 * scale, centerY + 60 * scale, 60 * scale, 80 * scale, '#228B22', 'rgba(34,139,34,0.3)');
    drawText('EXIT', centerX, centerY + 100 * scale, 10, '#228B22');
    
    drawStickFigure(stickFigure.x, stickFigure.y - 40 * scale, 0.6, stickFigure.eyeState);
    
    if (roomState.showAd) {
      // Fake ad popup â€” clean, high-fidelity style
      const popW = 280 * scale;
      const popH = 220 * scale;
      const popX = centerX - popW/2;
      const popY = centerY - popH/2;
      
      // Shadow
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.3)';
      ctx.shadowBlur = 20 * scale;
      ctx.shadowOffsetY = 5 * scale;
      ctx.fillStyle = '#fff';
      roundRect(popX, popY, popW, popH, 12 * scale);
      ctx.fill();
      ctx.restore();
      
      // Border
      ctx.save();
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      roundRect(popX, popY, popW, popH, 12 * scale);
      ctx.stroke();
      ctx.restore();
      
      // Confetti emojis
      drawCleanText('ðŸŽ‰ CONGRATULATIONS!!! ðŸŽ‰', centerX, popY + 30 * scale, 16, '#ff4444', 'center', '700');
      drawCleanText('You are the 1,000,000th', centerX, popY + 60 * scale, 13, '#333');
      drawCleanText('player! Tap to claim your', centerX, popY + 80 * scale, 13, '#333');
      drawCleanText('FREE PRIZE!', centerX, popY + 100 * scale, 15, '#ff8800', 'center', '700');
      
      // CLAIM NOW button
      drawCleanButton(centerX, popY + 140 * scale, 160 * scale, 40 * scale, 'CLAIM NOW!!!', '#ff4444');
      
      // Fake X (obvious)
      const fakeXx = popX + popW - 20 * scale;
      const fakeXy = popY + popH - 20 * scale;
      ctx.save();
      ctx.font = `bold ${18 * scale}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillStyle = '#999';
      ctx.fillText('âœ•', fakeXx, fakeXy);
      ctx.restore();
      
      // Real X (subtle, slightly different shade)
      const realXx = popX + popW - 50 * scale;
      const realXy = popY + popH - 20 * scale;
      const realXalpha = 0.15 + hintLevel * 0.1;
      ctx.save();
      ctx.globalAlpha = Math.min(0.8, realXalpha);
      ctx.font = `${11 * scale}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillStyle = '#bbb';
      ctx.fillText('Ã—', realXx, realXy);
      ctx.restore();
      
      // Hint: pulse on real X
      if (hintLevel >= 3) {
        ctx.save();
        ctx.globalAlpha = 0.2 + Math.sin(gameTime * 4) * 0.15;
        ctx.beginPath();
        ctx.arc(realXx, realXy, 10 * scale, 0, Math.PI * 2);
        ctx.fillStyle = '#44ff44';
        ctx.fill();
        ctx.restore();
      }
    }
  }
};

// --- ROOM 4: Color Blind ---
rooms[4] = {
  init() {
    roomState.waitTimer = 0;
    stickFigure.x = centerX;
    stickFigure.y = centerY + 100 * scale;
    stickFigure.visible = true;
    stickFigure.eyeState = 'confused';
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    roomState.waitTimer += deltaTime;
    
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      
      if (ev.type === 'tap') {
        const btnW = 80 * scale;
        const btnH = 55 * scale;
        const btnY = centerY + 20 * scale;
        
        // Left button (labeled RED, colored GREEN) â€” CORRECT
        const leftX = centerX - 100 * scale;
        if (hitTest(ev.x, ev.y, leftX, btnY, btnW, btnH)) {
          sfxWin();
          spawnParticles(ev.x, ev.y, 15, '#44ff44');
          fadeToRoom(5);
          return;
        }
        
        // Middle button (labeled GREEN, colored RED)
        const midX = centerX;
        if (hitTest(ev.x, ev.y, midX, btnY, btnW, btnH)) {
          sfxExplosion();
          die('ðŸ’€ You read the label. The label lied.');
          return;
        }
        
        // Right button (labeled BLUE, colored BLUE)
        const rightX = centerX + 100 * scale;
        if (hitTest(ev.x, ev.y, rightX, btnY, btnW, btnH)) {
          sfxSadTrombone();
          die('ðŸ’€ Nobody asked you to press blue. But points for confidence.');
          return;
        }
      }
    }
    
    // Die from indecision
    if (roomState.waitTimer > 10 && !showingDeath) {
      die('ðŸ’€ Indecision is also a choice. A bad one.');
      roomState.waitTimer = 0;
    }
  },
  draw() {
    drawSketchBackground();
    drawText('Room 5: Color Blind', centerX, 25 * scale, 12, '#999');
    
    // Prompt
    const promptY = centerY - 80 * scale;
    const hintFlash = hintLevel >= 3 && Math.sin(gameTime * 6) > 0.7;
    drawText('Press the GREEN button.', centerX, promptY, 22, hintFlash ? '#22aa22' : '#222');
    
    const btnW = 80 * scale;
    const btnH = 55 * scale;
    const btnY = centerY + 20 * scale;
    
    // Left: labeled RED, colored GREEN
    const leftX = centerX - 100 * scale;
    ctx.save();
    ctx.fillStyle = '#22aa22';
    roundRect(leftX - btnW/2, btnY - btnH/2, btnW, btnH, 8 * scale);
    ctx.fill();
    ctx.strokeStyle = '#1a8a1a';
    ctx.lineWidth = 2 * scale;
    roundRect(leftX - btnW/2, btnY - btnH/2, btnW, btnH, 8 * scale);
    ctx.stroke();
    drawCleanText('RED', leftX, btnY, 16, '#fff', 'center', '700');
    ctx.restore();
    
    // Middle: labeled GREEN, colored RED
    const midX = centerX;
    ctx.save();
    ctx.fillStyle = '#cc3333';
    roundRect(midX - btnW/2, btnY - btnH/2, btnW, btnH, 8 * scale);
    ctx.fill();
    ctx.strokeStyle = '#aa2222';
    ctx.lineWidth = 2 * scale;
    roundRect(midX - btnW/2, btnY - btnH/2, btnW, btnH, 8 * scale);
    ctx.stroke();
    drawCleanText('GREEN', midX, btnY, 16, '#fff', 'center', '700');
    ctx.restore();
    
    // Right: labeled BLUE, colored BLUE
    const rightX = centerX + 100 * scale;
    ctx.save();
    ctx.fillStyle = '#3366cc';
    roundRect(rightX - btnW/2, btnY - btnH/2, btnW, btnH, 8 * scale);
    ctx.fill();
    ctx.strokeStyle = '#2255aa';
    ctx.lineWidth = 2 * scale;
    roundRect(rightX - btnW/2, btnY - btnH/2, btnW, btnH, 8 * scale);
    ctx.stroke();
    drawCleanText('BLUE', rightX, btnY, 16, '#fff', 'center', '700');
    ctx.restore();
    
    drawStickFigure(stickFigure.x, stickFigure.y, 0.7, stickFigure.eyeState);
  }
};

// --- ROOM 5: System Alert ---
rooms[5] = {
  init() {
    roomState.dialogX = 0;
    roomState.dialogY = 0;
    roomState.dragging = false;
    roomState.dismissed = false;
    roomState.secondDialog = false;
    roomState.dragTotalDist = 0;
    stickFigure.x = centerX;
    stickFigure.y = centerY + 100 * scale;
    stickFigure.visible = true;
    stickFigure.eyeState = 'normal';
    startRoomAmbient(5);
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      
      if (roomState.dismissed) {
        // Tap exit door
        if (ev.type === 'tap') {
          const doorX = centerX;
          const doorY = centerY;
          if (hitTest(ev.x, ev.y, doorX, doorY, 70 * scale, 90 * scale)) {
            sfxWin();
            fadeToRoom(6);
            return;
          }
        }
        continue;
      }
      
      const dw = 260 * scale;
      const dh = 180 * scale;
      const dx = centerX + (roomState.dialogX || 0);
      const dy = centerY + (roomState.dialogY || 0);
      
      if (ev.type === 'tap') {
        // Allow button
        const allowX = dx + 50 * scale;
        const allowY = dy + 50 * scale;
        if (hitTest(ev.x, ev.y, allowX, allowY, 80 * scale, 35 * scale)) {
          die('ðŸ’€ Soul access: GRANTED. You had one of those, right?');
          return;
        }
        
        // Deny button
        const denyX = dx - 50 * scale;
        const denyY = dy + 50 * scale;
        if (hitTest(ev.x, ev.y, denyX, denyY, 80 * scale, 35 * scale)) {
          die('ðŸ’€ Permission denied. Life also denied.');
          return;
        }
        
        // Check if tap is on dialog body (for dragging)
        if (hitTest(ev.x, ev.y, dx, dy, dw, dh)) {
          roomState.dragging = true;
          // If tapping outside buttons but inside dialog
          if (!hitTest(ev.x, ev.y, allowX, allowY, 80 * scale, 35 * scale) && 
              !hitTest(ev.x, ev.y, denyX, denyY, 80 * scale, 35 * scale)) {
            // this is fine, start drag
          }
        } else {
          // Tap outside dialog
          if (!roomState.secondDialog) {
            roomState.secondDialog = true;
            die('ðŸ’€ You played yourself.');
            return;
          }
        }
      }
      
      if (ev.type === 'drag' && roomState.dragging) {
        roomState.dialogX = (roomState.dialogX || 0) + ev.dx;
        roomState.dialogY = (roomState.dialogY || 0) + ev.dy;
        roomState.dragTotalDist = (roomState.dragTotalDist || 0) + Math.abs(ev.dx) + Math.abs(ev.dy);
      }
      
      if (ev.type === 'release' && roomState.dragging) {
        roomState.dragging = false;
        // Check if dragged off screen
        const offX = Math.abs(roomState.dialogX || 0);
        const offY = Math.abs(roomState.dialogY || 0);
        if (offX > W * 0.35 || offY > H * 0.35) {
          roomState.dismissed = true;
          sfxWin();
          stopAllAmbient();
          spawnParticles(centerX, centerY, 15, '#44ff44');
        }
      }
    }
  },
  draw() {
    drawSketchBackground();
    drawText('Room 6: System Alert', centerX, 25 * scale, 12, '#999');
    
    // Room behind dialog
    wobblyRect(centerX - 30 * scale, centerY - 40 * scale, 60 * scale, 80 * scale, '#228B22', 'rgba(34,139,34,0.3)');
    drawText('EXIT', centerX, centerY, 10, '#228B22');
    
    drawStickFigure(stickFigure.x, stickFigure.y, 0.6, stickFigure.eyeState);
    
    if (!roomState.dismissed) {
      // System dialog - pixel perfect
      const dx = centerX + (roomState.dialogX || 0);
      const dy = centerY + (roomState.dialogY || 0);
      const dw = 260 * scale;
      const dh = 180 * scale;
      
      // Wobble hint
      const wobAmt = hintLevel >= 3 ? Math.sin(gameTime * 3) * 3 * scale : 0;
      
      // Shadow
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 15 * scale;
      ctx.fillStyle = '#f8f8f8';
      roundRect(dx - dw/2 + wobAmt, dy - dh/2, dw, dh, 14 * scale);
      ctx.fill();
      ctx.restore();
      
      // Dialog body
      ctx.save();
      ctx.fillStyle = '#f8f8f8';
      roundRect(dx - dw/2 + wobAmt, dy - dh/2, dw, dh, 14 * scale);
      ctx.fill();
      ctx.restore();
      
      drawCleanText('"Trust Nothing" wants to', dx + wobAmt, dy - 55 * scale, 14, '#000', 'center', '600');
      drawCleanText('access your soul.', dx + wobAmt, dy - 35 * scale, 14, '#000', 'center', '600');
      drawCleanText('This app requires eternal', dx + wobAmt, dy - 5 * scale, 11, '#666');
      drawCleanText('damnation permissions.', dx + wobAmt, dy + 12 * scale, 11, '#666');
      
      // Buttons
      drawCleanButton(dx - 50 * scale + wobAmt, dy + 55 * scale, 90 * scale, 35 * scale, 'Deny', '#e0e0e0', '#333');
      drawCleanButton(dx + 50 * scale + wobAmt, dy + 55 * scale, 90 * scale, 35 * scale, 'Allow', '#007AFF', '#fff');
    }
  }
};

// --- ROOM 6: The Helpful Arrow ---
rooms[6] = {
  init() {
    roomState.playerPos = 0.5; // 0-1, 0=left, 1=right
    roomState.fell = false;
    stickFigure.visible = true;
    stickFigure.eyeState = 'normal';
    startRoomAmbient(6);
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      
      if (ev.type === 'tap') {
        // Right button
        const rBtnX = centerX + 60 * scale;
        const rBtnY = H - 80 * scale;
        if (hitTest(ev.x, ev.y, rBtnX, rBtnY, 60 * scale, 50 * scale)) {
          roomState.playerPos = Math.min(1, (roomState.playerPos || 0.5) + 0.2);
          sfxClick();
          if (roomState.playerPos >= 0.8) {
            die('ðŸ’€ The arrow was not your friend.');
            sfxTrollLaugh(); // Troll laugh when arrow betrays
          }
          return;
        }
        
        // Left button
        const lBtnX = centerX - 60 * scale;
        const lBtnY = H - 80 * scale;
        if (hitTest(ev.x, ev.y, lBtnX, lBtnY, 60 * scale, 50 * scale)) {
          roomState.playerPos = Math.max(0, (roomState.playerPos || 0.5) - 0.2);
          sfxClick();
          if (roomState.playerPos <= 0.1) {
            sfxWin();
            spawnParticles(stickFigure.x, stickFigure.y, 15, '#44ff44');
            fadeToRoom(7);
            return;
          }
          return;
        }
        
        // Tap the arrow itself
        const arrowX = centerX + 30 * scale;
        const arrowY = centerY - 40 * scale;
        if (hitTest(ev.x, ev.y, arrowX, arrowY, 80 * scale, 60 * scale)) {
          die('ðŸ’€ Never touch a strange arrow.');
          return;
        }
      }
    }
  },
  draw() {
    drawSketchBackground();
    drawText('Room 7: The Helpful Arrow', centerX, 25 * scale, 12, '#999');
    
    const groundY = centerY + 60 * scale;
    
    // Platform
    wobblyLine(50 * scale, groundY, W - 50 * scale, groundY, '#555', 3);
    
    // Dark pit on left
    const pitFlicker = hintLevel >= 3 && Math.sin(gameTime * 5) > 0.8;
    if (!pitFlicker) {
      ctx.save();
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(50 * scale, groundY, 80 * scale, 80 * scale);
      ctx.restore();
      // Jagged edges
      for (let i = 0; i < 5; i++) {
        wobblyLine(50 * scale + i * 16 * scale, groundY, 55 * scale + i * 16 * scale, groundY + 15 * scale, '#333', 2);
      }
    } else {
      // Reveal it's just paint
      ctx.save();
      ctx.fillStyle = '#ddd';
      ctx.fillRect(50 * scale, groundY, 80 * scale, 80 * scale);
      drawText('(paint)', 90 * scale, groundY + 40 * scale, 8, '#999');
      ctx.restore();
      // EXIT behind it
      wobblyRect(60 * scale, groundY + 5 * scale, 50 * scale, 50 * scale, '#22aa22', 'rgba(34,221,34,0.5)');
      drawText('EXIT', 85 * scale, groundY + 30 * scale, 8, '#fff');
    }
    
    // Treasure chest on right
    wobblyRect(W - 120 * scale, groundY - 40 * scale, 50 * scale, 40 * scale, '#DAA520', '#FFD700', 2);
    drawText('âœ¨', W - 95 * scale, groundY - 45 * scale, 16);
    
    // Bouncy arrow pointing right
    const arrowBounce = Math.sin(gameTime * 4) * 10 * scale;
    const arrowX = centerX + 30 * scale;
    const arrowY = centerY - 40 * scale + arrowBounce;
    ctx.save();
    ctx.fillStyle = '#ffcc00';
    ctx.beginPath();
    ctx.moveTo(arrowX + 30 * scale, arrowY);
    ctx.lineTo(arrowX, arrowY - 20 * scale);
    ctx.lineTo(arrowX, arrowY - 8 * scale);
    ctx.lineTo(arrowX - 30 * scale, arrowY - 8 * scale);
    ctx.lineTo(arrowX - 30 * scale, arrowY + 8 * scale);
    ctx.lineTo(arrowX, arrowY + 8 * scale);
    ctx.lineTo(arrowX, arrowY + 20 * scale);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = '#cc9900';
    ctx.lineWidth = 2 * scale;
    ctx.stroke();
    ctx.restore();
    
    // Player position
    const ppos = roomState.playerPos || 0.5;
    stickFigure.x = 100 * scale + ppos * (W - 200 * scale);
    stickFigure.y = groundY - 25 * scale;
    drawStickFigure(stickFigure.x, stickFigure.y, 0.8, stickFigure.eyeState);
    
    // Direction buttons
    drawSketchButton(centerX - 60 * scale, H - 80 * scale, 60 * scale, 50 * scale, 'â†');
    drawSketchButton(centerX + 60 * scale, H - 80 * scale, 60 * scale, 50 * scale, 'â†’');
  }
};

// --- ROOM 7: Loading Screen ---
rooms[7] = {
  init() {
    roomState.progress = 38;
    roomState.dragging = false;
    roomState.tapCount = 0;
    roomState.waitTime = 0;
    roomState.tipIndex = 0;
    roomState.tipTimer = 0;
    stickFigure.visible = false;
  },
  update() {
    roomState.waitTime += deltaTime;
    roomState.tipTimer += deltaTime;
    
    if (roomState.tipTimer > 5) {
      roomState.tipTimer = 0;
      roomState.tipIndex = (roomState.tipIndex || 0) + 1;
    }
    
    // Die from waiting too long
    if (roomState.waitTime > 60 && !showingDeath && !roomState.dragging) {
      die('ðŸ’€ Patience is a virtue. But not here.');
      roomState.waitTime = 0;
    }
    
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      
      const barX = 50 * scale;
      const barY = centerY;
      const barW = W - 100 * scale;
      const barH = 30 * scale;
      
      if (ev.type === 'tap') {
        // Check if tapping on the progress bar area
        const handleX = barX + (roomState.progress / 100) * barW;
        if (hitTest(ev.x, ev.y, handleX, barY, 40 * scale, 50 * scale) ||
            hitTest(ev.x, ev.y, centerX, barY, barW, barH + 30*scale)) {
          roomState.dragging = true;
        } else {
          // Impatient tapping
          roomState.tapCount = (roomState.tapCount || 0) + 1;
          if (roomState.tapCount >= 5) {
            die('ðŸ’€ Tapping harder doesn\'t make it load faster. You know this.');
            roomState.tapCount = 0;
          }
        }
      }
      
      if (ev.type === 'drag' && roomState.dragging) {
        const barX2 = 50 * scale;
        const barW2 = W - 100 * scale;
        const pct = Math.max(0, Math.min(100, ((ev.x - barX2) / barW2) * 100));
        roomState.progress = pct;
        
        if (pct < 10) {
          die('ðŸ’€ You un-loaded the game. Impressive, actually.');
          return;
        }
      }
      
      if (ev.type === 'release' && roomState.dragging) {
        roomState.dragging = false;
        if (roomState.progress >= 98) {
          sfxWin();
          spawnParticles(centerX, centerY, 20, '#44ff44');
          fadeToRoom(8);
          return;
        }
      }
    }
  },
  draw() {
    // Dark loading screen
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, W, H);
    
    // Loading text
    drawCleanText('Loading Room 8...', centerX, centerY - 60 * scale, 18, '#ccc');
    
    // Progress bar background
    const barX = 50 * scale;
    const barY = centerY - 15 * scale;
    const barW = W - 100 * scale;
    const barH = 30 * scale;
    
    ctx.save();
    ctx.fillStyle = '#333';
    roundRect(barX, barY, barW, barH, 6 * scale);
    ctx.fill();
    
    // Progress fill
    const fillW = (roomState.progress / 100) * barW;
    ctx.fillStyle = '#4CAF50';
    roundRect(barX, barY, Math.max(0, fillW), barH, 6 * scale);
    ctx.fill();
    ctx.restore();
    
    // Handle glow hint
    if (hintLevel >= 3) {
      const handleX = barX + fillW;
      ctx.save();
      ctx.globalAlpha = 0.4 + Math.sin(gameTime * 3) * 0.2;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(handleX, barY + barH/2, 12 * scale, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    
    // Percentage
    drawCleanText(`${Math.floor(roomState.progress)}%`, centerX, centerY + 30 * scale, 14, '#888');
    
    // Tip
    const tips = [
      'ðŸ’¡ Tip: Trust nothing, not even loading screens.',
      'ðŸ’¡ Tip: Have you tried dragging things?',
      'ðŸ’¡ Tip: This tip is a hint.',
      'ðŸ’¡ Tip: We\'re not sorry.',
      'ðŸ’¡ Tip: The game is lying to you right now.'
    ];
    const tipIdx = (roomState.tipIndex || 0) % tips.length;
    drawCleanText(tips[tipIdx], centerX, H - 60 * scale, 11, '#555');
  }
};

// --- ROOM 8: Mirror Room ---
rooms[8] = {
  init() {
    // Simple maze grid - 0=open, 1=wall, 2=spike, 3=exit
    roomState.maze = [
      [1,1,1,1,1,1,1],
      [1,0,0,2,0,0,1],
      [1,0,1,1,1,0,1],
      [1,0,0,0,2,0,1],
      [1,1,1,0,1,0,1],
      [1,0,0,0,0,0,1],
      [1,1,1,1,1,3,1],
    ];
    roomState.px = 1; // player grid position
    roomState.py = 1;
    roomState.titleFlash = 0;
    stickFigure.visible = true;
    stickFigure.eyeState = 'confused';
    startRoomAmbient(8);
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    roomState.titleFlash = (roomState.titleFlash || 0) + deltaTime;
    
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      
      if (ev.type === 'tap') {
        const btnSize = 55 * scale;
        const btnCenterX = centerX;
        const btnCenterY = H - 100 * scale;
        
        let dx = 0, dy = 0;
        
        // Up button (INVERTED: moves down)
        if (hitTest(ev.x, ev.y, btnCenterX, btnCenterY - btnSize, btnSize, btnSize)) { dy = 1; }
        // Down button (INVERTED: moves up)
        if (hitTest(ev.x, ev.y, btnCenterX, btnCenterY + btnSize, btnSize, btnSize)) { dy = -1; }
        // Left button (INVERTED: moves right)
        if (hitTest(ev.x, ev.y, btnCenterX - btnSize, btnCenterY, btnSize, btnSize)) { dx = 1; }
        // Right button (INVERTED: moves left)
        if (hitTest(ev.x, ev.y, btnCenterX + btnSize, btnCenterY, btnSize, btnSize)) { dx = -1; }
        
        if (dx !== 0 || dy !== 0) {
          sfxClick();
          const nx = roomState.px + dx;
          const ny = roomState.py + dy;
          
          if (nx < 0 || nx >= 7 || ny < 0 || ny >= 7) {
            // Out of bounds
            return;
          }
          
          const cell = roomState.maze[ny][nx];
          if (cell === 1) {
            die('ðŸ’€ The walls are not the exit. We checked.');
            return;
          }
          if (cell === 2) {
            die('ðŸ’€ You went left. Wait, you went right. Wait â€” which way is left?');
            return;
          }
          if (cell === 3) {
            sfxWin();
            spawnParticles(stickFigure.x, stickFigure.y, 20, '#44ff44');
            fadeToRoom(9);
            return;
          }
          
          roomState.px = nx;
          roomState.py = ny;
        }
      }
    }
  },
  draw() {
    drawSketchBackground();
    
    // Mirror aesthetic - subtle reflection
    ctx.save();
    ctx.globalAlpha = 0.05;
    ctx.scale(1, -1);
    ctx.translate(0, -H);
    drawSketchBackground();
    ctx.restore();
    
    // Title (mirrored)
    const showNormal = hintLevel >= 3 && Math.sin(roomState.titleFlash * 3) > 0.9;
    drawText(showNormal ? 'Room 9: Mirror' : 'Room 9: rorriM', centerX, 25 * scale, 12, '#999');
    
    // Draw maze
    const cellSize = 35 * scale;
    const mazeX = centerX - 3.5 * cellSize;
    const mazeY = 60 * scale;
    
    for (let y = 0; y < 7; y++) {
      for (let x = 0; x < 7; x++) {
        const cx = mazeX + x * cellSize + cellSize/2;
        const cy = mazeY + y * cellSize + cellSize/2;
        const cell = roomState.maze[y][x];
        
        if (cell === 1) {
          wobblyRect(mazeX + x * cellSize, mazeY + y * cellSize, cellSize, cellSize, '#666', '#888');
        } else if (cell === 2) {
          // Spikes
          ctx.save();
          ctx.fillStyle = 'rgba(255,0,0,0.3)';
          ctx.fillRect(mazeX + x * cellSize, mazeY + y * cellSize, cellSize, cellSize);
          drawText('â–²', cx, cy, 14, '#cc3333');
          ctx.restore();
        } else if (cell === 3) {
          wobblyRect(mazeX + x * cellSize, mazeY + y * cellSize, cellSize, cellSize, '#22aa22', 'rgba(34,170,34,0.3)');
          drawText('EXIT', cx, cy, 7, '#22aa22');
        }
      }
    }
    
    // Player in maze
    const pCellX = mazeX + roomState.px * cellSize + cellSize/2;
    const pCellY = mazeY + roomState.py * cellSize + cellSize/2;
    stickFigure.x = pCellX;
    stickFigure.y = pCellY;
    drawStickFigure(pCellX, pCellY, 0.4, stickFigure.eyeState);
    
    // Direction buttons
    const btnSize = 55 * scale;
    const btnCenterX = centerX;
    const btnCenterY = H - 100 * scale;
    
    drawSketchButton(btnCenterX, btnCenterY - btnSize, btnSize, btnSize, 'â†‘');
    drawSketchButton(btnCenterX, btnCenterY + btnSize, btnSize, btnSize, 'â†“');
    drawSketchButton(btnCenterX - btnSize, btnCenterY, btnSize, btnSize, 'â†');
    drawSketchButton(btnCenterX + btnSize, btnCenterY, btnSize, btnSize, 'â†’');
  }
};

// --- ROOM 9: Trust the Troll ---
rooms[9] = {
  init() {
    roomState.glassTaps = 0;
    roomState.glassBroken = false;
    roomState.trollTaps = 0;
    roomState.waitTimer = 0;
    roomState.glassRepairTimer = 0;
    stickFigure.x = centerX - 80 * scale;
    stickFigure.y = centerY + 60 * scale;
    stickFigure.visible = true;
    stickFigure.eyeState = 'normal';
    startRoomAmbient(9);
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    roomState.waitTimer += deltaTime;
    
    // Glass repair timer
    if (roomState.glassBroken && !showingDeath) {
      roomState.glassRepairTimer = (roomState.glassRepairTimer || 0) + deltaTime;
      if (roomState.glassRepairTimer > 8) {
        roomState.glassBroken = false;
        roomState.glassTaps = 0;
        roomState.glassRepairTimer = 0;
      }
    }
    
    // Die from waiting
    if (roomState.waitTimer > 20 && !showingDeath) {
      die('ðŸ’€ Doing nothing worked once. The troll is not a timer.');
      roomState.waitTimer = 0;
    }
    
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      
      if (ev.type === 'tap') {
        roomState.waitTimer = 0;
        
        // Troll area
        const trollX = centerX + 60 * scale;
        const trollY = centerY - 30 * scale;
        if (hitTest(ev.x, ev.y, trollX, trollY, 80 * scale, 100 * scale)) {
          roomState.trollTaps = (roomState.trollTaps || 0) + 1;
          if (roomState.trollTaps >= 5) {
            die('ðŸ’€ Don\'t poke the troll.');
            sfxTrollLaugh();
          }
          return;
        }
        
        // Door behind troll
        const doorX = W - 60 * scale;
        const doorY = centerY;
        if (hitTest(ev.x, ev.y, doorX, doorY, 50 * scale, 80 * scale)) {
          die('ðŸ’€ The troll didn\'t say the door was safe either.');
          sfxTrollLaugh();
          return;
        }
        
        // Glass case / button area
        const btnX = centerX - 30 * scale;
        const btnY = centerY + 20 * scale;
        
        if (!roomState.glassBroken) {
          // Tap glass
          if (hitTest(ev.x, ev.y, btnX, btnY, 70 * scale, 70 * scale)) {
            roomState.glassTaps = (roomState.glassTaps || 0) + 1;
            sfxClick();
            spawnParticles(ev.x, ev.y, 3, '#aaddff');
            if (roomState.glassTaps >= 3) {
              roomState.glassBroken = true;
              roomState.glassRepairTimer = 0;
              sfxExplosion();
              spawnParticles(btnX, btnY, 15, '#ccddff');
            }
          }
        } else {
          // Tap the exposed button
          if (hitTest(ev.x, ev.y, btnX, btnY, 50 * scale, 50 * scale)) {
            sfxWin();
            spawnParticles(ev.x, ev.y, 30, '#44ff44');
            fadeToRoom(10);
            return;
          }
        }
      }
      
      // Drag troll attempt
      if (ev.type === 'drag') {
        const trollX = centerX + 60 * scale;
        const trollY = centerY - 30 * scale;
        if (hitTest(ev.startX, ev.startY, trollX, trollY, 80 * scale, 100 * scale)) {
          die('ðŸ’€ He\'s heavier than he looks. And angrier.');
          sfxTrollLaugh();
          return;
        }
      }
    }
  },
  draw() {
    drawSketchBackground();
    drawText('Room 10: Trust the Troll', centerX, 25 * scale, 12, '#999');
    
    // Door behind troll (partially visible)
    const doorX = W - 80 * scale;
    const doorY = centerY - 40 * scale;
    wobblyRect(doorX, doorY, 45 * scale, 80 * scale, '#8B4513', '#a0522d');
    
    // Troll
    const trollX = centerX + 60 * scale;
    const trollY = centerY - 30 * scale;
    
    // Troll body
    wobblyCircle(trollX, trollY, 35 * scale, '#228B22', '#2d8f2d', 2.5);
    // Troll face
    // Eyes (mischievous)
    ctx.save();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(trollX - 12*scale, trollY - 8*scale, 8*scale, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(trollX + 12*scale, trollY - 8*scale, 8*scale, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#222';
    ctx.beginPath(); ctx.arc(trollX - 10*scale, trollY - 6*scale, 4*scale, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(trollX + 14*scale, trollY - 6*scale, 4*scale, 0, Math.PI*2); ctx.fill();
    // Grin
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2.5*scale;
    ctx.beginPath();
    ctx.arc(trollX, trollY + 5*scale, 18*scale, 0.1, Math.PI - 0.1);
    ctx.stroke();
    ctx.restore();
    
    // Speech bubble
    const bubbleX = centerX - 20 * scale;
    const bubbleY = centerY - 130 * scale;
    const bubbleW = 220 * scale;
    const bubbleH = 80 * scale;
    
    ctx.save();
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2 * scale;
    roundRect(bubbleX - bubbleW/2, bubbleY - bubbleH/2, bubbleW, bubbleH, 10 * scale);
    ctx.fill();
    roundRect(bubbleX - bubbleW/2, bubbleY - bubbleH/2, bubbleW, bubbleH, 10 * scale);
    ctx.stroke();
    // Tail
    ctx.beginPath();
    ctx.moveTo(bubbleX + 30*scale, bubbleY + bubbleH/2);
    ctx.lineTo(trollX - 15*scale, trollY - 35*scale);
    ctx.lineTo(bubbleX + 50*scale, bubbleY + bubbleH/2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
    
    // Speech text
    drawText("DON'T press this", bubbleX, bubbleY - 20*scale, 11, '#222');
    drawText("button. Seriously.", bubbleX, bubbleY - 5*scale, 11, '#222');
    drawText("I'm warning you.", bubbleX, bubbleY + 10*scale, 11, '#222');
    
    // Hint asterisk
    if (hintLevel >= 4) {
      ctx.save();
      ctx.globalAlpha = 0.5 + Math.sin(gameTime * 3) * 0.3;
      drawText('*actually true', bubbleX + 60*scale, bubbleY + 30*scale, 7, '#cc3333');
      ctx.restore();
    }
    
    // Glass case + button
    const btnX = centerX - 30 * scale;
    const btnY = centerY + 20 * scale;
    const caseSize = 60 * scale;
    
    if (!roomState.glassBroken) {
      // Glass case
      ctx.save();
      ctx.fillStyle = 'rgba(200,220,255,0.3)';
      ctx.strokeStyle = 'rgba(150,180,220,0.7)';
      ctx.lineWidth = 2 * scale;
      ctx.fillRect(btnX - caseSize/2, btnY - caseSize/2, caseSize, caseSize);
      ctx.strokeRect(btnX - caseSize/2, btnY - caseSize/2, caseSize, caseSize);
      ctx.restore();
      
      // Cracks
      for (let i = 0; i < (roomState.glassTaps || 0); i++) {
        const cx = btnX + (Math.random() - 0.5) * caseSize * 0.8;
        const cy = btnY + (Math.random() - 0.5) * caseSize * 0.8;
        wobblyLine(cx - 8*scale, cy - 8*scale, cx + 8*scale, cy + 8*scale, 'rgba(150,180,220,0.5)', 1);
        wobblyLine(cx + 8*scale, cy - 8*scale, cx - 8*scale, cy + 8*scale, 'rgba(150,180,220,0.5)', 1);
      }
    }
    
    // Red button (always visible, under glass)
    ctx.save();
    ctx.fillStyle = '#cc0000';
    ctx.beginPath();
    ctx.arc(btnX, btnY, 18 * scale, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ff3333';
    ctx.beginPath();
    ctx.arc(btnX - 3*scale, btnY - 3*scale, 14 * scale, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#990000';
    ctx.lineWidth = 2*scale;
    ctx.beginPath();
    ctx.arc(btnX, btnY, 18 * scale, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
    
    // Stick figure
    drawStickFigure(stickFigure.x, stickFigure.y, 0.8, stickFigure.eyeState);
  }
};

// --- ROOM 10: Fake Crash ---
rooms[10] = {
  init() {
    roomState.phase = 'crash'; // crash -> recovery -> solved
    roomState.timer = 0;
    roomState.tapCount = 0;
    roomState.glitchLines = [];
    for (let i = 0; i < 20; i++) {
      roomState.glitchLines.push({
        y: Math.random() * H, w: Math.random() * W, h: 2 + Math.random() * 6,
        offset: (Math.random() - 0.5) * 40, speed: 1 + Math.random() * 3
      });
    }
    stickFigure.visible = false;
  },
  update() {
    roomState.timer += deltaTime;
    if (roomState.phase === 'crash') {
      // Wait for user to tap "anywhere"
      for (const ev of inputEvents) {
        if (showingDeath) continue;
        if (ev.type === 'tap') {
          roomState.tapCount++;
          if (roomState.tapCount <= 2) {
            // The tap makes it worse
            shake(8);
          } else if (roomState.tapCount === 3) {
            // Reveal the secret
            roomState.phase = 'recovery';
            roomState.timer = 0;
          }
        }
      }
      // If they wait long enough without tapping
      if (roomState.timer > 8 && roomState.tapCount === 0) {
        roomState.phase = 'recovery';
        roomState.timer = 0;
      }
    } else if (roomState.phase === 'recovery') {
      for (const ev of inputEvents) {
        if (showingDeath) continue;
        if (ev.type === 'tap') {
          // Tap the "OK" on the real dialog
          const okX = centerX;
          const okY = centerY + 60 * scale;
          if (hitTest(ev.x, ev.y, okX, okY, 80 * scale, 40 * scale)) {
            die('ðŸ’€ That OK was also a lie. Keep learning.');
            return;
          }
          // Tiny hidden "x" in top left corner of screen
          if (ev.x < 30 * scale && ev.y < 30 * scale) {
            sfxWin();
            spawnParticles(ev.x, ev.y, 15, '#44ff44');
            fadeToRoom(11);
            return;
          }
        }
      }
    }
  },
  draw() {
    if (roomState.phase === 'crash') {
      // Fake crash screen
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, W, H);
      // Glitch lines
      for (const gl of roomState.glitchLines) {
        gl.y += gl.speed * deltaTime * 60;
        if (gl.y > H) gl.y = -gl.h;
        ctx.save();
        ctx.fillStyle = `rgba(${100+Math.random()*155},${Math.random()*100},${Math.random()*255},${0.1 + Math.random() * 0.2})`;
        ctx.fillRect(gl.offset + Math.sin(gameTime * 3) * 10, gl.y, gl.w, gl.h);
        ctx.restore();
      }
      const crashMsgs = [
        'FATAL ERROR: Reality not found',
        'The game has stopped responding.',
        roomState.tapCount > 0 ? 'Tapping makes it worse.' : '',
        roomState.tapCount > 1 ? 'SERIOUSLY. STOP TAPPING.' : '',
      ];
      crashMsgs.forEach((msg, i) => {
        if (msg) drawCleanText(msg, centerX, centerY - 60 * scale + i * 30 * scale, 14, '#ff4444');
      });
      if (roomState.timer > 3) {
        const alpha = 0.1 + Math.sin(gameTime * 2) * 0.05;
        ctx.save();
        ctx.globalAlpha = alpha;
        drawCleanText('(wait... or try something unusual)', centerX, H - 40 * scale, 10, '#555');
        ctx.restore();
      }
    } else {
      drawSketchBackground();
      drawText('Room 11: Fake Crash', centerX, 25 * scale, 12, '#999');
      // "Recovery" dialog
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 15 * scale;
      ctx.fillStyle = '#f8f8f8';
      roundRect(centerX - 130 * scale, centerY - 70 * scale, 260 * scale, 160 * scale, 14 * scale);
      ctx.fill();
      ctx.restore();
      drawCleanText('Game recovered!', centerX, centerY - 40 * scale, 16, '#000', 'center', '600');
      drawCleanText('Press OK to continue.', centerX, centerY - 10 * scale, 12, '#666');
      drawCleanButton(centerX, centerY + 60 * scale, 80 * scale, 40 * scale, 'OK', '#007AFF');
      // Hidden x in top left
      if (hintLevel >= 3) {
        ctx.save();
        ctx.globalAlpha = 0.15 + Math.sin(gameTime * 4) * 0.1;
        ctx.fillStyle = '#44ff44';
        ctx.beginPath();
        ctx.arc(15 * scale, 15 * scale, 12 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.font = `${8 * scale}px sans-serif`;
      ctx.fillStyle = '#888';
      ctx.textAlign = 'left';
      ctx.fillText('x', 11 * scale, 18 * scale);
      ctx.restore();
    }
  }
};

// --- ROOM 11: The Moving Button ---
rooms[11] = {
  init() {
    roomState.btnX = centerX;
    roomState.btnY = centerY + 30 * scale;
    roomState.btnSpeed = 1;
    roomState.attempts = 0;
    roomState.frozen = false;
    roomState.freezeTimer = 0;
    stickFigure.x = centerX;
    stickFigure.y = centerY - 60 * scale;
    stickFigure.visible = true;
    stickFigure.eyeState = 'normal';
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    // Move the button away from last tap location
    if (!roomState.frozen) {
      roomState.btnX += Math.sin(gameTime * roomState.btnSpeed * 2) * 1.5 * scale;
      roomState.btnY += Math.cos(gameTime * roomState.btnSpeed * 1.7) * 1.0 * scale;
      // Keep in bounds
      roomState.btnX = Math.max(60 * scale, Math.min(W - 60 * scale, roomState.btnX));
      roomState.btnY = Math.max(80 * scale, Math.min(H - 80 * scale, roomState.btnY));
    } else {
      roomState.freezeTimer += deltaTime;
    }

    for (const ev of inputEvents) {
      if (showingDeath) continue;
      if (ev.type === 'tap') {
        const bw = 100 * scale, bh = 45 * scale;
        if (hitTest(ev.x, ev.y, roomState.btnX, roomState.btnY, bw, bh)) {
          if (roomState.frozen) {
            // Win!
            sfxWin();
            spawnParticles(ev.x, ev.y, 20, '#44ff44');
            fadeToRoom(12);
            return;
          }
          roomState.attempts++;
          roomState.btnSpeed += 0.5;
          sfxClick();
          // Button runs away
          roomState.btnX += (roomState.btnX < centerX ? 1 : -1) * 80 * scale;
          roomState.btnY += (Math.random() - 0.5) * 60 * scale;
          if (roomState.attempts >= 5) {
            // Button gets tired and freezes
            roomState.frozen = true;
            roomState.freezeTimer = 0;
          }
        } else {
          // Missed - might die
          if (roomState.attempts > 2 && Math.random() < 0.3) {
            die('ðŸ’€ You missed. The button is judging you.');
          }
        }
      }
    }
  },
  draw() {
    drawSketchBackground();
    drawText('Room 12: Catch Me', centerX, 25 * scale, 12, '#999');
    drawStickFigure(stickFigure.x, stickFigure.y, 0.7, stickFigure.eyeState);
    // The moving button
    const bw = 100 * scale, bh = 45 * scale;
    const bx = roomState.btnX - bw / 2;
    const by = roomState.btnY - bh / 2;
    if (roomState.frozen) {
      // Exhausted button
      const tremble = Math.sin(gameTime * 20) * scale;
      wobblyRect(bx + tremble, by + tremble, bw, bh, '#cc3333', '#ffcccc', 2);
      drawText('OK fine...', roomState.btnX, roomState.btnY, 12, '#cc3333');
      if (hintLevel >= 2) {
        ctx.save();
        ctx.globalAlpha = 0.4 + Math.sin(gameTime * 3) * 0.2;
        drawText('tap me', roomState.btnX, roomState.btnY + 22 * scale, 8, '#22aa22');
        ctx.restore();
      }
    } else {
      wobblyRect(bx, by, bw, bh, '#222', '#ffd700', 2.5);
      drawText(roomState.attempts > 3 ? 'HAHA!' : 'CONTINUE', roomState.btnX, roomState.btnY, 13, '#222');
      // Taunting text
      if (roomState.attempts > 0) {
        const taunts = ['Too slow!', 'Missed me!', 'Try again!', 'Getting tired?', 'Almost!'];
        const tauntIdx = Math.min(roomState.attempts - 1, taunts.length - 1);
        ctx.save();
        ctx.globalAlpha = 0.6;
        drawText(taunts[tauntIdx], roomState.btnX, roomState.btnY - 35 * scale, 10, '#cc3333');
        ctx.restore();
      }
    }
  }
};

// --- ROOM 12: The Liar Score ---
rooms[12] = {
  init() {
    roomState.fakeScore = 99999;
    roomState.realScore = 0;
    roomState.phase = 'lying'; // lying -> truth
    roomState.tapCount = 0;
    roomState.shownTruth = false;
    stickFigure.x = centerX;
    stickFigure.y = centerY + 90 * scale;
    stickFigure.visible = true;
    stickFigure.eyeState = 'happy';
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    if (roomState.phase === 'lying') {
      // The score keeps going up (fake)
      roomState.fakeScore += deltaTime * 100;
      roomState.realScore = totalDeaths;
    }
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      if (ev.type === 'tap') {
        if (roomState.phase === 'lying') {
          // Tap the score to "question" it
          const scoreY = centerY - 40 * scale;
          if (hitTest(ev.x, ev.y, centerX, scoreY, 200 * scale, 50 * scale)) {
            roomState.tapCount++;
            sfxClick();
            if (roomState.tapCount >= 3) {
              roomState.phase = 'truth';
              roomState.shownTruth = true;
              stickFigure.eyeState = 'confused';
              sfxSadTrombone();
              shake(10);
            }
          }
          // Claim prize button
          const prizeY = centerY + 30 * scale;
          if (hitTest(ev.x, ev.y, centerX, prizeY, 140 * scale, 40 * scale)) {
            die('ðŸ’€ There is no prize. There was never a prize.');
            return;
          }
        } else {
          // Truth phase - tap the tiny real exit
          if (ev.x > W - 50 * scale && ev.y > H - 50 * scale) {
            sfxWin();
            spawnParticles(ev.x, ev.y, 25, '#44ff44');
            unlock('truthseeker');
            showChapterComplete();
            return;
          }
          // Tap the fake big exit
          const fakeExitY = centerY + 50 * scale;
          if (hitTest(ev.x, ev.y, centerX, fakeExitY, 160 * scale, 50 * scale)) {
            die('ðŸ’€ That exit is just as fake as the score was.');
            return;
          }
        }
      }
    }
  },
  draw() {
    drawSketchBackground();
    drawText('Room 13: Your Score', centerX, 25 * scale, 12, '#999');
    drawStickFigure(stickFigure.x, stickFigure.y, 0.7, stickFigure.eyeState);
    if (roomState.phase === 'lying') {
      // Big fake score
      ctx.save();
      ctx.font = `bold ${48 * scale}px 'Comic Sans MS', cursive`;
      ctx.textAlign = 'center';
      ctx.fillStyle = '#ffd700';
      ctx.shadowColor = '#ffd700';
      ctx.shadowBlur = 20 * scale;
      ctx.fillText(Math.floor(roomState.fakeScore).toLocaleString(), centerX, centerY - 40 * scale);
      ctx.restore();
      drawText('YOUR AMAZING SCORE!', centerX, centerY - 80 * scale, 16, '#222');
      drawSketchButton(centerX, centerY + 30 * scale, 140 * scale, 40 * scale, 'CLAIM PRIZE!', '#fff', '#ff8800');
      if (roomState.tapCount > 0) {
        ctx.save();
        ctx.globalAlpha = 0.3 + roomState.tapCount * 0.2;
        drawText('Hmm... is this real?', centerX, centerY + 70 * scale, 11, '#cc3333');
        ctx.restore();
      }
    } else {
      // Truth revealed
      ctx.save();
      ctx.font = `bold ${28 * scale}px 'Comic Sans MS', cursive`;
      ctx.textAlign = 'center';
      ctx.fillStyle = '#cc3333';
      ctx.fillText('REAL SCORE:', centerX, centerY - 60 * scale);
      ctx.font = `bold ${40 * scale}px 'Comic Sans MS', cursive`;
      ctx.fillText(`${totalDeaths} deaths`, centerX, centerY - 20 * scale);
      ctx.restore();
      drawText("That's your real score.", centerX, centerY + 10 * scale, 14, '#666');
      // Fake big exit
      drawSketchButton(centerX, centerY + 50 * scale, 160 * scale, 50 * scale, 'CONTINUE', '#fff', '#ff8800');
      // Real tiny exit
      ctx.save();
      ctx.globalAlpha = 0.12 + (hintLevel >= 3 ? Math.sin(gameTime * 4) * 0.1 : 0);
      ctx.font = `${7 * scale}px sans-serif`;
      ctx.fillStyle = '#888';
      ctx.textAlign = 'right';
      ctx.fillText('exit', W - 12 * scale, H - 12 * scale);
      ctx.restore();
    }
  }
};

// ============================================================
// NEW GAME+ STATE
// ============================================================
let newGamePlus = false;
let ngPlusLevel = 0;
let secretEndingsFound = {};
try { const se = localStorage.getItem('trustnothing_secrets'); if (se) secretEndingsFound = JSON.parse(se); } catch(e) {}
function saveSecrets() { try { localStorage.setItem('trustnothing_secrets', JSON.stringify(secretEndingsFound)); } catch(e) {} }
try { const ng = localStorage.getItem('trustnothing_ngplus'); if (ng) { ngPlusLevel = parseInt(ng) || 0; if (ngPlusLevel > 0) newGamePlus = true; } } catch(e) {}
function saveNGPlus() { try { localStorage.setItem('trustnothing_ngplus', ngPlusLevel.toString()); } catch(e) {} }

let konami = [];
const KONAMI_CODE = [38,38,40,40,37,39,37,39,66,65];
let playerTrustScore = 0;

// ============================================================
// ACT 2: ROOMS 13-16 â€” THE SYSTEM FIGHTS BACK
// ============================================================

// --- ROOM 13: The Fake Update Screen ---
rooms[13] = {
  init() {
    roomState.phase = 'updating';
    roomState.progress = 0;
    roomState.fakeProgress = 0;
    roomState.cancelClicks = 0;
    roomState.bsodTimer = 0;
    roomState.draggedBar = false;
    stickFigure.visible = false;
    document.title = 'Updating... Do not turn off your device';
  },
  update() {
    if (roomState.phase === 'updating') {
      roomState.fakeProgress += deltaTime * (newGamePlus ? 0.3 : 0.5);
      roomState.progress = Math.min(99.9, roomState.fakeProgress + Math.sin(gameTime * 2) * 2);
      if (roomState.fakeProgress > 33 && roomState.fakeProgress < 34) {
        roomState.fakeProgress = 33.1;
      }
      for (const ev of inputEvents) {
        if (showingDeath) continue;
        if (ev.type === 'tap') {
          const cancelY = centerY + 110 * scale;
          if (hitTest(ev.x, ev.y, centerX, cancelY, 120 * scale, 40 * scale)) {
            roomState.cancelClicks++;
            sfxClick();
            if (roomState.cancelClicks < 3) {
              die(roomState.cancelClicks === 1 ? "You can't cancel destiny." : 'We said NO CANCELLING.');
            } else {
              roomState.phase = 'bluescreen';
              roomState.bsodTimer = 0;
              document.title = ':( Your game ran into a problem';
              sfxExplosion();
              shake(20);
            }
            return;
          }
          const barY = centerY + 65 * scale;
          if (hitTest(ev.x, ev.y, centerX, barY, W - 80 * scale, 40 * scale)) {
            roomState.draggedBar = true;
          }
        }
        if (ev.type === 'drag' && roomState.draggedBar) {
          if (ev.dx < -5) roomState.fakeProgress = Math.max(0, roomState.fakeProgress - 1);
          if (roomState.fakeProgress <= 1) {
            roomState.phase = 'bluescreen';
            roomState.bsodTimer = 0;
            sfxExplosion();
          }
        }
        if (ev.type === 'release') roomState.draggedBar = false;
      }
      if (roomState.fakeProgress >= 99 && roomState.progress >= 99.5) {
        roomState.phase = 'bluescreen';
        roomState.bsodTimer = 0;
        document.title = ':( Something went wrong';
        sfxExplosion();
        shake(15);
      }
    } else if (roomState.phase === 'bluescreen') {
      roomState.bsodTimer += deltaTime;
      for (const ev of inputEvents) {
        if (showingDeath) continue;
        if (ev.type === 'tap') {
          const restartY = centerY + 140 * scale;
          if (hitTest(ev.x, ev.y, centerX, restartY, 140 * scale, 40 * scale)) {
            die('Restarting just makes it angrier.');
            return;
          }
          const codeX = centerX + 90 * scale;
          const codeY = centerY + 90 * scale;
          if (hitTest(ev.x, ev.y, codeX, codeY, 50 * scale, 50 * scale)) {
            sfxWin();
            spawnParticles(ev.x, ev.y, 20, '#44ff44');
            document.title = 'Trust Nothing';
            fadeToRoom(14);
            return;
          }
          if (hitTest(ev.x, ev.y, centerX, centerY - 80 * scale, 80 * scale, 80 * scale)) {
            die('Even the sad face is betrayed by your touch.');
            return;
          }
        }
      }
    }
  },
  draw() {
    if (roomState.phase === 'updating') {
      ctx.fillStyle = '#0078d4';
      ctx.fillRect(0, 0, W, H);
      const dots = 8;
      const circleR = 25 * scale;
      for (let i = 0; i < dots; i++) {
        const angle = (gameTime * 2 + i * 0.3) % (Math.PI * 2);
        const dotX = centerX + Math.cos(angle) * circleR;
        const dotY = centerY - 60 * scale + Math.sin(angle) * circleR;
        ctx.save();
        ctx.globalAlpha = 0.2 + (i / dots) * 0.8;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(dotX, dotY, 3 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      drawCleanText('Updating...', centerX, centerY - 10 * scale, 20, '#fff', 'center', '300');
      drawCleanText(roomState.progress.toFixed(0) + '% complete', centerX, centerY + 20 * scale, 14, 'rgba(255,255,255,0.7)');
      drawCleanText("Don't turn off your device", centerX, centerY + 45 * scale, 11, 'rgba(255,255,255,0.5)');
      const barW = W - 100 * scale, barH = 6 * scale, barX = 50 * scale, barY = centerY + 65 * scale;
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(barX, barY, barW, barH);
      ctx.fillStyle = '#fff';
      ctx.fillRect(barX, barY, barW * (roomState.progress / 100), barH);
      ctx.save();
      ctx.globalAlpha = 0.15 + hintLevel * 0.08;
      drawCleanButton(centerX, centerY + 110 * scale, 120 * scale, 35 * scale, 'Cancel', 'rgba(255,255,255,0.3)', '#fff');
      ctx.restore();
    } else if (roomState.phase === 'bluescreen') {
      ctx.fillStyle = '#0078d4';
      ctx.fillRect(0, 0, W, H);
      drawCleanText(':(', centerX, centerY - 80 * scale, 72, '#fff', 'center', '100');
      drawCleanText('Your game ran into a problem', centerX, centerY - 20 * scale, 16, '#fff', 'center', '300');
      drawCleanText("and needs to restart. We're just", centerX, centerY + 5 * scale, 12, '#fff', 'center', '300');
      drawCleanText('collecting some error info, and then', centerX, centerY + 25 * scale, 12, '#fff', 'center', '300');
      drawCleanText("we'll restart for you.", centerX, centerY + 45 * scale, 12, '#fff', 'center', '300');
      const qrX = centerX + 90 * scale, qrY = centerY + 90 * scale, qrSize = 40 * scale;
      ctx.fillStyle = '#fff';
      ctx.fillRect(qrX - qrSize/2, qrY - qrSize/2, qrSize, qrSize);
      ctx.fillStyle = '#000';
      for (let i = 0; i < 8; i++) for (let j = 0; j < 8; j++) {
        if ((i + j * 3 + 7) % 3 === 0) ctx.fillRect(qrX - qrSize/2 + i * qrSize/8, qrY - qrSize/2 + j * qrSize/8, qrSize/8, qrSize/8);
      }
      drawCleanText('Stop code: TRUST_VIOLATION', centerX - 30 * scale, centerY + 130 * scale, 9, 'rgba(255,255,255,0.6)', 'center', '300');
      drawCleanButton(centerX, centerY + 160 * scale, 140 * scale, 35 * scale, 'Restart', 'rgba(255,255,255,0.2)', '#fff');
      if (roomState.bsodTimer > 10 && hintLevel >= 2) {
        ctx.save();
        ctx.globalAlpha = 0.3 + Math.sin(gameTime * 3) * 0.2;
        ctx.strokeStyle = '#44ff44';
        ctx.lineWidth = 2 * scale;
        ctx.strokeRect(qrX - qrSize/2 - 5*scale, qrY - qrSize/2 - 5*scale, qrSize + 10*scale, qrSize + 10*scale);
        ctx.restore();
      }
    }
  }
};

// --- ROOM 14: The Invisible Maze ---
rooms[14] = {
  init() {
    roomState.px = 0;
    roomState.py = 0;
    roomState.revealed = [];
    roomState.moveCount = 0;
    roomState.maze = newGamePlus ? [
      [0,1,0,0,2,0],
      [0,1,0,1,1,0],
      [0,0,0,1,2,0],
      [1,1,0,0,0,1],
      [2,0,0,1,0,0],
      [0,0,1,1,0,3],
    ] : [
      [0,0,1,0,0,0],
      [0,1,0,0,1,0],
      [0,0,0,1,0,0],
      [1,0,1,0,0,1],
      [0,0,0,0,1,0],
      [0,1,0,0,0,3],
    ];
    stickFigure.visible = true;
    stickFigure.eyeState = 'confused';
    document.title = 'Trust Nothing - Can you see?';
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      if (ev.type === 'tap') {
        const btnSize = 55 * scale;
        const btnCX = centerX, btnCY = H - 100 * scale;
        let dx = 0, dy = 0;
        if (hitTest(ev.x, ev.y, btnCX, btnCY - btnSize, btnSize, btnSize)) dy = -1;
        if (hitTest(ev.x, ev.y, btnCX, btnCY + btnSize, btnSize, btnSize)) dy = 1;
        if (hitTest(ev.x, ev.y, btnCX - btnSize, btnCY, btnSize, btnSize)) dx = -1;
        if (hitTest(ev.x, ev.y, btnCX + btnSize, btnCY, btnSize, btnSize)) dx = 1;
        if (newGamePlus) { dx = -dx; dy = -dy; }
        if (dx !== 0 || dy !== 0) {
          sfxClick();
          roomState.moveCount++;
          const nx = roomState.px + dx, ny = roomState.py + dy;
          if (nx < 0 || nx >= 6 || ny < 0 || ny >= 6) { shake(5); playTone(200, 0.1, 'square', 0.1); return; }
          const cell = roomState.maze[ny][nx];
          if (!roomState.revealed.find(r => r.x === nx && r.y === ny)) roomState.revealed.push({ x: nx, y: ny, type: cell });
          if (cell === 1) { shake(8); playTone(150, 0.15, 'square', 0.15); return; }
          if (cell === 2) { die('You found the trap. The trap also found you.'); return; }
          if (cell === 3) { sfxWin(); spawnParticles(stickFigure.x, stickFigure.y, 20, '#44ff44'); document.title = 'Trust Nothing'; fadeToRoom(15); return; }
          roomState.px = nx;
          roomState.py = ny;
        }
      }
    }
  },
  draw() {
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, W, H);
    drawCleanText(newGamePlus ? 'Room 15: Invisible Maze NG+' : 'Room 15: Invisible Maze', centerX, 25 * scale, 12, '#555');
    const cellSize = 40 * scale, mazeX = centerX - 3 * cellSize, mazeY = 60 * scale;
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;
    for (let y = 0; y <= 6; y++) { ctx.beginPath(); ctx.moveTo(mazeX, mazeY + y * cellSize); ctx.lineTo(mazeX + 6 * cellSize, mazeY + y * cellSize); ctx.stroke(); }
    for (let x = 0; x <= 6; x++) { ctx.beginPath(); ctx.moveTo(mazeX + x * cellSize, mazeY); ctx.lineTo(mazeX + x * cellSize, mazeY + 6 * cellSize); ctx.stroke(); }
    ctx.restore();
    for (const r of roomState.revealed) {
      const cx = mazeX + r.x * cellSize, cy = mazeY + r.y * cellSize;
      if (r.type === 1) { ctx.fillStyle = 'rgba(255,50,50,0.4)'; ctx.fillRect(cx, cy, cellSize, cellSize); drawCleanText('X', cx + cellSize/2, cy + cellSize/2, 12, '#ff4444'); }
      else if (r.type === 2) { ctx.fillStyle = 'rgba(255,100,0,0.3)'; ctx.fillRect(cx, cy, cellSize, cellSize); drawCleanText('!', cx + cellSize/2, cy + cellSize/2, 14, '#ff8800'); }
    }
    const exitCX = mazeX + 5 * cellSize, exitCY = mazeY + 5 * cellSize;
    ctx.save(); ctx.globalAlpha = 0.3 + Math.sin(gameTime * 2) * 0.15; ctx.fillStyle = '#44ff44'; ctx.fillRect(exitCX, exitCY, cellSize, cellSize); ctx.restore();
    drawCleanText('EXIT', exitCX + cellSize/2, exitCY + cellSize/2, 8, '#44ff44');
    const pCX = mazeX + roomState.px * cellSize + cellSize/2, pCY = mazeY + roomState.py * cellSize + cellSize/2;
    stickFigure.x = pCX; stickFigure.y = pCY;
    drawStickFigure(pCX, pCY, 0.35, stickFigure.eyeState);
    const btnSize = 55 * scale, btnCX = centerX, btnCY = H - 100 * scale;
    drawSketchButton(btnCX, btnCY - btnSize, btnSize, btnSize, newGamePlus ? '?' : '^', '#fff', '#333');
    drawSketchButton(btnCX, btnCY + btnSize, btnSize, btnSize, newGamePlus ? '?' : 'v', '#fff', '#333');
    drawSketchButton(btnCX - btnSize, btnCY, btnSize, btnSize, newGamePlus ? '?' : '<', '#fff', '#333');
    drawSketchButton(btnCX + btnSize, btnCY, btnSize, btnSize, newGamePlus ? '?' : '>', '#fff', '#333');
    drawCleanText('Moves: ' + roomState.moveCount, centerX, mazeY + 6.5 * cellSize, 10, '#555');
  }
};

// --- ROOM 15: The Browser Title Puzzle ---
rooms[15] = {
  init() {
    roomState.tapsOnTitle = 0;
    roomState.titleDragY = 0;
    roomState.draggingTitle = false;
    roomState.solved = false;
    roomState.shakeTimer = 0;
    stickFigure.visible = true;
    stickFigure.eyeState = 'confused';
    stickFigure.x = centerX;
    stickFigure.y = centerY + 80 * scale;
    document.title = 'DRAG ME DOWN -->';
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    roomState.shakeTimer += deltaTime;
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      if (ev.type === 'tap') {
        if (ev.y < 50 * scale) { roomState.tapsOnTitle++; roomState.draggingTitle = true; sfxClick(); if (roomState.tapsOnTitle >= 10) { die('The title bar has had enough of your poking.'); return; } }
        const door1X = centerX - 80 * scale;
        if (hitTest(ev.x, ev.y, door1X, centerY, 50 * scale, 70 * scale)) { die('That door leads to another death. Classic.'); return; }
        const door2X = centerX + 80 * scale;
        if (hitTest(ev.x, ev.y, door2X, centerY, 50 * scale, 70 * scale)) { die('This door was even worse than the first one.'); return; }
      }
      if (ev.type === 'drag' && roomState.draggingTitle) {
        roomState.titleDragY += ev.dy;
        if (roomState.titleDragY > H * 0.6) roomState.solved = true;
      }
      if (ev.type === 'release') {
        if (roomState.draggingTitle && roomState.solved) { sfxWin(); spawnParticles(centerX, 40 * scale, 20, '#44ff44'); document.title = 'Trust Nothing'; fadeToRoom(16); return; }
        roomState.draggingTitle = false;
      }
    }
  },
  draw() {
    drawSketchBackground();
    const titleOffset = Math.max(0, roomState.titleDragY || 0);
    if (titleOffset > 20) {
      ctx.save(); ctx.fillStyle = '#44ff44'; ctx.globalAlpha = Math.min(1, titleOffset / (H * 0.4));
      ctx.fillRect(0, 0, W, Math.min(titleOffset, 50 * scale));
      drawCleanText('EXIT', centerX, Math.min(titleOffset / 2, 25 * scale), 16, '#fff');
      ctx.restore();
    }
    wobblyRect(centerX - 105 * scale, centerY - 35 * scale, 50 * scale, 70 * scale, '#8B4513', '#a0522d');
    drawText('EXIT A', centerX - 80 * scale, centerY, 10, '#fff');
    wobblyRect(centerX + 55 * scale, centerY - 35 * scale, 50 * scale, 70 * scale, '#8B4513', '#a0522d');
    drawText('EXIT B', centerX + 80 * scale, centerY, 10, '#fff');
    drawStickFigure(stickFigure.x, stickFigure.y, 0.7, stickFigure.eyeState);
    ctx.save(); ctx.fillStyle = 'rgba(240,235,220,0.97)'; ctx.fillRect(0, titleOffset, W, 50 * scale);
    ctx.strokeStyle = '#bbb'; ctx.lineWidth = 1; ctx.strokeRect(0, titleOffset, W, 50 * scale); ctx.restore();
    const wobAmt = hintLevel >= 3 ? Math.sin(roomState.shakeTimer * 5) * 2 * scale : 0;
    drawText('Room 16: Which Door?', centerX, titleOffset + 25 * scale + wobAmt, 14, '#444');
    if (hintLevel >= 2 || roomState.tapsOnTitle >= 3) {
      ctx.save(); ctx.globalAlpha = 0.4 + Math.sin(gameTime * 3) * 0.2;
      drawText('v drag v', centerX, titleOffset + 42 * scale, 9, '#22aa22');
      ctx.restore();
    }
    if (hintLevel >= 4) { ctx.save(); ctx.globalAlpha = 0.3; drawCleanText('(check your browser tab...)', centerX, centerY + 120 * scale, 9, '#888'); ctx.restore(); }
  }
};

// --- ROOM 16: The Gravity Flip ---
rooms[16] = {
  init() {
    roomState.gravity = 1;
    roomState.playerY = centerY;
    roomState.playerVY = 0;
    roomState.platforms = [];
    roomState.spikes = [];
    roomState.exitY = 100 * scale;
    roomState.exitX = W - 60 * scale;
    roomState.flipCount = 0;
    const platW = 80 * scale, platH = 10 * scale;
    for (let i = 0; i < 5; i++) roomState.platforms.push({ x: 60 * scale + (i / 5) * (W - 120 * scale), y: 200 * scale + Math.sin(i * 1.5) * 100 * scale, w: platW, h: platH });
    roomState.spikes.push({ x: centerX - 40 * scale, y: H - 20 * scale, w: 80 * scale, h: 20 * scale });
    roomState.spikes.push({ x: centerX + 60 * scale, y: 0, w: 80 * scale, h: 20 * scale });
    stickFigure.visible = true;
    stickFigure.eyeState = 'panic';
    stickFigure.x = 60 * scale;
  },
  update() {
    stickFigure.breathPhase += deltaTime * 3;
    roomState.playerVY += roomState.gravity * 300 * scale * deltaTime;
    roomState.playerY += roomState.playerVY * deltaTime;
    if (roomState.playerY > H - 40 * scale) { roomState.playerY = H - 40 * scale; roomState.playerVY = 0; }
    if (roomState.playerY < 40 * scale) { roomState.playerY = 40 * scale; roomState.playerVY = 0; }
    for (const p of roomState.platforms) {
      if (stickFigure.x > p.x - 10 * scale && stickFigure.x < p.x + p.w + 10 * scale) {
        if (roomState.gravity > 0 && roomState.playerVY > 0 && roomState.playerY > p.y - 20 * scale && roomState.playerY < p.y + p.h) { roomState.playerY = p.y - 20 * scale; roomState.playerVY = 0; }
        if (roomState.gravity < 0 && roomState.playerVY < 0 && roomState.playerY < p.y + p.h + 20 * scale && roomState.playerY > p.y) { roomState.playerY = p.y + p.h + 20 * scale; roomState.playerVY = 0; }
      }
    }
    for (const s of roomState.spikes) {
      if (stickFigure.x > s.x && stickFigure.x < s.x + s.w && roomState.playerY > s.y && roomState.playerY < s.y + s.h + 20 * scale) {
        die('Gravity is not your friend. Neither are spikes.');
        return;
      }
    }
    if (stickFigure.x > roomState.exitX - 30 * scale && Math.abs(roomState.playerY - roomState.exitY) < 40 * scale) {
      sfxWin(); spawnParticles(stickFigure.x, roomState.playerY, 20, '#44ff44'); fadeToRoom(17); return;
    }
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      if (ev.type === 'tap') {
        if (ev.x < W / 2) stickFigure.x = Math.max(30 * scale, stickFigure.x - 40 * scale);
        else stickFigure.x = Math.min(W - 30 * scale, stickFigure.x + 40 * scale);
        sfxClick();
      }
      if (ev.type === 'release') {
        const swipeY = ev.y - (ev.startY || ev.y);
        if (Math.abs(swipeY) > 50 * scale) {
          roomState.gravity *= -1;
          roomState.flipCount++;
          shake(5);
          playTone(roomState.gravity > 0 ? 300 : 600, 0.1, 'sine', 0.1);
          if (newGamePlus && roomState.flipCount % 3 === 0) {
            roomState.spikes.push({ x: Math.random() * (W - 100 * scale) + 50 * scale, y: Math.random() * (H - 100 * scale) + 50 * scale, w: 40 * scale, h: 10 * scale });
          }
        }
      }
    }
  },
  draw() {
    ctx.fillStyle = roomState.gravity > 0 ? '#1a1a2e' : '#2e1a1a';
    ctx.fillRect(0, 0, W, H);
    drawCleanText('Room 17: Gravity Flip', centerX, 25 * scale, 12, '#555');
    drawCleanText('Tap sides to move. Swipe up/down to flip gravity.', centerX, 50 * scale, 9, '#444');
    for (const p of roomState.platforms) { ctx.fillStyle = '#555'; ctx.fillRect(p.x, p.y, p.w, p.h); }
    for (const s of roomState.spikes) {
      ctx.fillStyle = '#cc3333'; ctx.fillRect(s.x, s.y, s.w, s.h);
      const spikeCount = Math.floor(s.w / (15 * scale));
      for (let i = 0; i < spikeCount; i++) {
        ctx.beginPath();
        const sx = s.x + i * (s.w / spikeCount);
        if (s.y < H / 2) { ctx.moveTo(sx, s.y + s.h); ctx.lineTo(sx + s.w / spikeCount / 2, s.y + s.h + 10 * scale); ctx.lineTo(sx + s.w / spikeCount, s.y + s.h); }
        else { ctx.moveTo(sx, s.y); ctx.lineTo(sx + s.w / spikeCount / 2, s.y - 10 * scale); ctx.lineTo(sx + s.w / spikeCount, s.y); }
        ctx.fill();
      }
    }
    ctx.save(); ctx.globalAlpha = 0.5 + Math.sin(gameTime * 3) * 0.3; ctx.fillStyle = '#44ff44';
    ctx.fillRect(roomState.exitX - 20 * scale, roomState.exitY - 20 * scale, 40 * scale, 40 * scale);
    drawCleanText('EXIT', roomState.exitX, roomState.exitY, 10, '#fff'); ctx.restore();
    stickFigure.y = roomState.playerY;
    ctx.save();
    if (roomState.gravity < 0) { ctx.translate(0, roomState.playerY * 2); ctx.scale(1, -1); }
    drawStickFigure(stickFigure.x, roomState.playerY, 0.6, stickFigure.eyeState);
    ctx.restore();
    drawCleanText(roomState.gravity > 0 ? 'Gravity: DOWN' : 'Gravity: UP', 60 * scale, H - 30 * scale, 10, '#888');
  }
};

// ============================================================
// ACT 3: ROOMS 17-20 â€” NOTHING IS REAL
// ============================================================

// --- ROOM 17: Fake Console Error ---
rooms[17] = {
  init() {
    roomState.lines = [];
    roomState.lineTimer = 0;
    roomState.lineIndex = 0;
    roomState.phase = 'errors';
    roomState.tapSequence = [];
    stickFigure.visible = false;
    roomState.errorMessages = [
      '> Loading game assets...',
      '> ERROR: texture_player.png not found',
      '> ERROR: Cannot read property "life" of undefined',
      '> WARN: Memory usage at 98%',
      '> ERROR: Uncaught ReferenceError: hope is not defined',
      '> ERROR: Stack overflow in function: trust()',
      '> FATAL: Game state corrupted',
      '> Attempting recovery...',
      '> Recovery failed.',
      '> ...',
      '> Actually, try typing "help"',
    ];
    document.title = 'ERROR - Trust Nothing has crashed';
  },
  update() {
    roomState.lineTimer += deltaTime;
    if (roomState.phase === 'errors') {
      if (roomState.lineTimer > 0.8 && roomState.lineIndex < roomState.errorMessages.length) {
        roomState.lines.push(roomState.errorMessages[roomState.lineIndex]);
        roomState.lineIndex++;
        roomState.lineTimer = 0;
        playTone(100 + Math.random() * 50, 0.05, 'square', 0.05);
      }
      if (roomState.lineIndex >= roomState.errorMessages.length) {
        roomState.phase = 'prompt';
      }
    }
    if (roomState.phase === 'prompt') {
      for (const ev of inputEvents) {
        if (showingDeath) continue;
        if (ev.type === 'tap') {
          if (ev.y > H - 80 * scale) {
            sfxClick();
            if (roomState.tapSequence.length >= 4) {
              roomState.lines.push('> help');
              roomState.lines.push('> ...');
              roomState.lines.push('> Just kidding. Tap the third error.');
              roomState.phase = 'clickErrors';
              roomState.tapSequence = [];
            } else {
              roomState.lines.push('> (not enough input)');
              roomState.tapSequence = [];
            }
          } else {
            roomState.tapSequence.push(ev.x);
            playTone(200 + roomState.tapSequence.length * 100, 0.03, 'square', 0.05);
          }
        }
      }
    }
    if (roomState.phase === 'clickErrors') {
      for (const ev of inputEvents) {
        if (showingDeath) continue;
        if (ev.type === 'tap') {
          const lineH = 18 * scale, startY = 30 * scale;
          const thirdErrorY = startY + 2 * lineH;
          if (ev.y > thirdErrorY - lineH/2 && ev.y < thirdErrorY + lineH/2) {
            sfxWin(); spawnParticles(ev.x, ev.y, 20, '#44ff44'); document.title = 'Trust Nothing'; fadeToRoom(18); return;
          }
          for (let i = 0; i < roomState.lines.length; i++) {
            const ly = startY + i * lineH;
            if (ev.y > ly - lineH/2 && ev.y < ly + lineH/2 && i !== 2) { die('Wrong error line. The game is very specific about its bugs.'); return; }
          }
        }
      }
    }
  },
  draw() {
    ctx.fillStyle = '#0c0c0c';
    ctx.fillRect(0, 0, W, H);
    ctx.save(); ctx.globalAlpha = 0.03;
    for (let y = 0; y < H; y += 3) { ctx.fillStyle = '#000'; ctx.fillRect(0, y, W, 1); }
    ctx.restore();
    const lineH = 18 * scale, startY = 30 * scale;
    const maxVisible = Math.floor((H - 120 * scale) / lineH);
    const startIdx = Math.max(0, roomState.lines.length - maxVisible);
    for (let i = startIdx; i < roomState.lines.length; i++) {
      const line = roomState.lines[i], ly = startY + (i - startIdx) * lineH;
      let color = '#0f0';
      if (line.includes('ERROR')) color = '#ff4444';
      if (line.includes('FATAL')) color = '#ff0000';
      if (line.includes('WARN')) color = '#ffaa00';
      if (line.includes('...')) color = '#555';
      if (roomState.phase === 'clickErrors' && i === 2) {
        ctx.save(); ctx.globalAlpha = 0.2 + Math.sin(gameTime * 4) * 0.1; ctx.fillStyle = '#44ff44'; ctx.fillRect(0, ly - lineH/2, W, lineH); ctx.restore();
      }
      ctx.save(); ctx.font = (11 * scale) + 'px "Courier New", monospace'; ctx.fillStyle = color; ctx.textAlign = 'left'; ctx.fillText(line, 10 * scale, ly); ctx.restore();
    }
    if (roomState.phase === 'prompt' || roomState.phase === 'errors') {
      const cursorY = startY + (roomState.lines.length - startIdx) * lineH;
      if (Math.sin(gameTime * 4) > 0) { ctx.fillStyle = '#0f0'; ctx.fillRect(10 * scale, cursorY - 6 * scale, 8 * scale, 14 * scale); }
    }
    if (roomState.phase === 'prompt') {
      ctx.save(); ctx.fillStyle = 'rgba(0,255,0,0.1)'; ctx.fillRect(0, H - 80 * scale, W, 80 * scale);
      drawCleanText('[TAP HERE TO SUBMIT]', centerX, H - 40 * scale, 12, '#0a0');
      drawCleanText('Input: ' + '*'.repeat(roomState.tapSequence.length), centerX, H - 60 * scale, 10, '#0f0');
      ctx.restore();
    }
  }
};

// --- ROOM 18: The Lying Narrator ---
rooms[18] = {
  init() {
    roomState.narratorText = "Welcome! I'm your friendly narrator.";
    roomState.narratorTimer = 0;
    roomState.phase = 0;
    stickFigure.visible = true;
    stickFigure.eyeState = 'normal';
    stickFigure.x = centerX;
    stickFigure.y = centerY + 80 * scale;
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    roomState.narratorTimer += deltaTime;
    const dialogues = [
      { t: 0, text: "Welcome! I'm your friendly narrator.", eye: 'normal' },
      { t: 3, text: "See that door on the right? Go there!", eye: 'normal' },
      { t: 6, text: "It's perfectly safe, I promise.", eye: 'normal' },
      { t: 9, text: "Why are you hesitating?", eye: 'confused' },
      { t: 13, text: "...OK fine, the door is a trap.", eye: 'confused' },
      { t: 16, text: "The REAL exit is on the left.", eye: 'happy' },
      { t: 19, text: "Wait, did I say left? I meant right.", eye: 'normal' },
      { t: 22, text: "Actually, both are traps.", eye: 'panic' },
      { t: 25, text: "The exit is... behind me?", eye: 'confused' },
      { t: 30, text: "Just tap the narrator text. I give up.", eye: 'happy' },
    ];
    for (let di = 0; di < dialogues.length; di++) {
      if (roomState.narratorTimer > dialogues[di].t && roomState.phase < di + 1) {
        roomState.narratorText = dialogues[di].text;
        roomState.phase = di + 1;
        stickFigure.eyeState = dialogues[di].eye;
      }
    }
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      if (ev.type === 'tap') {
        if (hitTest(ev.x, ev.y, W - 60 * scale, centerY + 10 * scale, 60 * scale, 80 * scale)) { die('The narrator lied. Or did he? (He did.)'); return; }
        if (hitTest(ev.x, ev.y, 60 * scale, centerY + 10 * scale, 60 * scale, 80 * scale)) { die('The narrator lied about lying. Liar squared.'); return; }
        if (ev.y < 140 * scale && ev.y > 60 * scale) {
          if (roomState.phase >= 10) { sfxWin(); spawnParticles(ev.x, ev.y, 25, '#44ff44'); unlock('narrator'); fadeToRoom(19); return; }
          else if (roomState.phase >= 5) { die("Not yet... I haven't finished talking!"); return; }
        }
      }
    }
  },
  draw() {
    drawSketchBackground();
    const bubbleY = 100 * scale;
    ctx.save(); ctx.fillStyle = '#fff'; ctx.strokeStyle = '#222'; ctx.lineWidth = 2 * scale;
    roundRect(30 * scale, bubbleY - 35 * scale, W - 60 * scale, 70 * scale, 12 * scale); ctx.fill();
    roundRect(30 * scale, bubbleY - 35 * scale, W - 60 * scale, 70 * scale, 12 * scale); ctx.stroke(); ctx.restore();
    drawText(roomState.narratorText, centerX, bubbleY, 13, '#222');
    ctx.save(); ctx.globalAlpha = 0.5; drawText('~ The Narrator ~', centerX, bubbleY - 50 * scale, 9, '#999'); ctx.restore();
    wobblyRect(35 * scale, centerY - 30 * scale, 50 * scale, 80 * scale, '#8B4513', '#a0522d');
    drawText('LEFT', 60 * scale, centerY + 10 * scale, 10, '#fff');
    wobblyRect(W - 85 * scale, centerY - 30 * scale, 50 * scale, 80 * scale, '#8B4513', '#a0522d');
    drawText('RIGHT', W - 60 * scale, centerY + 10 * scale, 10, '#fff');
    drawStickFigure(stickFigure.x, stickFigure.y, 0.7, stickFigure.eyeState);
    if (roomState.phase >= 10) { ctx.save(); ctx.globalAlpha = 0.4 + Math.sin(gameTime * 4) * 0.2; drawText('^ tap me ^', centerX, bubbleY + 50 * scale, 10, '#22aa22'); ctx.restore(); }
    drawText('Room 18: The Lying Narrator', centerX, H - 30 * scale, 10, '#999');
  }
};

// --- ROOM 19: The Fake Game Over ---
rooms[19] = {
  init() {
    roomState.phase = 'gameover';
    roomState.scrollY = 0;
    roomState.creditTimer = 0;
    roomState.tapCount = 0;
    roomState.restarted = false;
    stickFigure.visible = false;
    document.title = 'GAME OVER';
  },
  update() {
    roomState.creditTimer += deltaTime;
    if (roomState.phase === 'gameover') {
      for (const ev of inputEvents) {
        if (showingDeath) continue;
        if (ev.type === 'tap') {
          roomState.tapCount++;
          const restartY = centerY + 60 * scale;
          if (hitTest(ev.x, ev.y, centerX, restartY, 140 * scale, 45 * scale)) {
            sfxClick();
            if (!roomState.restarted) { roomState.restarted = true; roomState.phase = 'credits'; roomState.creditTimer = 0; roomState.scrollY = H; }
            else die("You can't restart what was never real.");
            return;
          }
          // Secret: tap the period after "GAME OVER."
          if (ev.x > centerX + 80 * scale && ev.x < centerX + 130 * scale && ev.y > centerY - 70 * scale && ev.y < centerY - 30 * scale) {
            sfxChime(); roomState.phase = 'credits'; roomState.creditTimer = 0; roomState.scrollY = H; return;
          }
        }
      }
    }
    if (roomState.phase === 'credits') {
      roomState.scrollY -= deltaTime * 40 * scale;
      for (const ev of inputEvents) { if (ev.type === 'tap') roomState.scrollY -= 30 * scale; }
      if (roomState.scrollY < -600 * scale) roomState.phase = 'escape';
    }
    if (roomState.phase === 'escape') {
      for (const ev of inputEvents) {
        if (showingDeath) continue;
        if (ev.type === 'tap') { sfxWin(); spawnParticles(ev.x, ev.y, 25, '#44ff44'); document.title = 'Trust Nothing'; fadeToRoom(20); return; }
      }
    }
  },
  draw() {
    ctx.fillStyle = '#000'; ctx.fillRect(0, 0, W, H);
    if (roomState.phase === 'gameover') {
      ctx.save(); ctx.font = 'bold ' + (48 * scale) + "px 'Comic Sans MS', cursive"; ctx.textAlign = 'center'; ctx.fillStyle = '#cc3333';
      ctx.fillText('GAME OVER.', centerX, centerY - 50 * scale); ctx.restore();
      drawCleanText('You trusted too much.', centerX, centerY, 14, '#888');
      drawCleanText('Final Deaths: ' + totalDeaths, centerX, centerY + 25 * scale, 12, '#666');
      drawCleanButton(centerX, centerY + 60 * scale, 140 * scale, 45 * scale, 'Restart?', '#cc3333');
      if (hintLevel >= 4) { ctx.save(); ctx.globalAlpha = 0.2 + Math.sin(gameTime * 5) * 0.1; ctx.beginPath(); ctx.arc(centerX + 105 * scale, centerY - 55 * scale, 10 * scale, 0, Math.PI * 2); ctx.strokeStyle = '#44ff44'; ctx.lineWidth = 1; ctx.stroke(); ctx.restore(); }
    }
    if (roomState.phase === 'credits') {
      const creditLines = ['TRUST NOTHING','','A Game That Lied To You','','Lead Designer: Nobody','Lead Programmer: Also Nobody','QA Testing: The Player (sorry)','Sound Design: Beeps & Boops','Moral Support: None','','Special Thanks:','Your patience','Your gullibility','Your continued tapping','','','Wait...','','Is this really the end?','','','No.','','Tap to continue.'];
      const lineH = 30 * scale;
      for (let i = 0; i < creditLines.length; i++) {
        const ly = roomState.scrollY + i * lineH;
        if (ly > -30 * scale && ly < H + 30 * scale) {
          drawCleanText(creditLines[i], centerX, ly, i === 0 ? 28 : 14, i === 0 ? '#ffd700' : '#ccc', 'center', i === 0 ? '700' : '300');
        }
      }
    }
    if (roomState.phase === 'escape') {
      drawCleanText('Oh, you made it past the credits.', centerX, centerY - 30 * scale, 16, '#fff');
      drawCleanText('Tap anywhere. For real this time.', centerX, centerY + 10 * scale, 12, '#44ff44');
    }
  }
};

// --- ROOM 20: The Trust Test ---
rooms[20] = {
  init() {
    roomState.questions = [
      { q: 'Is this door safe?', options: ['Yes', 'No'], correct: 1, explanation: 'Nothing is safe.' },
      { q: 'Should you press the red button?', options: ['Yes', 'No'], correct: 0, explanation: 'Reverse psychology works here.' },
      { q: 'Do you trust this game?', options: ['Yes', 'No'], correct: -1, explanation: 'Both answers are wrong.' },
      { q: 'Which door is the exit?', options: ['Left', 'Right', 'Neither'], correct: 2, explanation: 'Learning!' },
    ];
    roomState.currentQ = 0;
    roomState.answered = false;
    roomState.waitTimer = 0;
    roomState.showExplanation = false;
    playerTrustScore = 0;
    stickFigure.visible = true;
    stickFigure.eyeState = 'confused';
    stickFigure.x = centerX;
    stickFigure.y = centerY + 120 * scale;
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    if (roomState.showExplanation) {
      roomState.waitTimer += deltaTime;
      if (roomState.waitTimer > 2) {
        roomState.showExplanation = false;
        roomState.answered = false;
        roomState.currentQ++;
        roomState.waitTimer = 0;
        if (roomState.currentQ >= roomState.questions.length) { sfxWin(); spawnParticles(centerX, centerY, 30, '#44ff44'); fadeToRoom(21); return; }
      }
      return;
    }
    for (const ev of inputEvents) {
      if (showingDeath || roomState.answered) continue;
      if (ev.type === 'tap') {
        const q = roomState.questions[roomState.currentQ];
        const optCount = q.options.length;
        for (let i = 0; i < optCount; i++) {
          const optX = centerX + (i - (optCount-1)/2) * 100 * scale, optY = centerY + 30 * scale;
          if (hitTest(ev.x, ev.y, optX, optY, 85 * scale, 40 * scale)) {
            sfxClick();
            if (q.correct === -1) { die('I told you: TRUST NOTHING. Not even the questions.'); return; }
            if (i === q.correct) { roomState.answered = true; roomState.showExplanation = true; roomState.waitTimer = 0; stickFigure.eyeState = 'happy'; sfxChime(); playerTrustScore++; }
            else { die(q.explanation); return; }
          }
        }
      }
    }
  },
  draw() {
    drawSketchBackground();
    drawText('Room 21: Trust Test', centerX, 25 * scale, 12, '#999');
    const q = roomState.questions[Math.min(roomState.currentQ, roomState.questions.length - 1)];
    drawText((roomState.currentQ + 1) + '/' + roomState.questions.length, W - 40 * scale, 50 * scale, 10, '#888');
    drawText(q.q, centerX, centerY - 60 * scale, 20, '#222');
    const optCount = q.options.length;
    for (let i = 0; i < optCount; i++) {
      const optX = centerX + (i - (optCount-1)/2) * 100 * scale, optY = centerY + 30 * scale;
      const isCorrect = roomState.answered && i === q.correct;
      drawSketchButton(optX, optY, 85 * scale, 40 * scale, q.options[i], isCorrect ? '#22aa22' : '#222', isCorrect ? '#ccffcc' : '#f5f0e6');
    }
    if (roomState.showExplanation) { ctx.save(); ctx.globalAlpha = Math.min(1, roomState.waitTimer * 2); drawText(q.explanation, centerX, centerY + 80 * scale, 12, '#22aa22'); ctx.restore(); }
    drawText('Trust Score: ' + playerTrustScore, centerX, centerY + 120 * scale, 10, '#ffd700');
    drawStickFigure(stickFigure.x, stickFigure.y, 0.6, stickFigure.eyeState);
  }
};

// ============================================================
// ACT 4: ROOMS 21-24 â€” THE META GAME
// ============================================================

// --- ROOM 21: The Fake Save Corruption ---
rooms[21] = {
  init() {
    roomState.phase = 'corrupted';
    roomState.glitchTimer = 0;
    roomState.shakeIntensity = 0;
    roomState.corruptedSlots = [
      { name: 'Save 1 - Room 7', corrupted: true },
      { name: 'Save 2 - Room 12', corrupted: true },
      { name: 'Save 3 - ???', corrupted: false },
    ];
    stickFigure.visible = false;
    document.title = 'WARNING: Save data corrupted';
  },
  update() {
    roomState.glitchTimer += deltaTime;
    roomState.shakeIntensity = Math.max(0, roomState.shakeIntensity - deltaTime * 5);
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      if (ev.type === 'tap') {
        for (let i = 0; i < 3; i++) {
          const slotY = centerY - 40 * scale + i * 70 * scale;
          if (hitTest(ev.x, ev.y, centerX, slotY, 250 * scale, 55 * scale)) {
            sfxClick();
            if (roomState.corruptedSlots[i].corrupted) { die('That save was corrupted. The corruption corrupted you too.'); roomState.shakeIntensity = 15; return; }
            else { sfxWin(); spawnParticles(ev.x, ev.y, 20, '#44ff44'); document.title = 'Trust Nothing'; unlock('act4complete'); fadeToRoom(22); return; }
          }
        }
        const delY = centerY + 170 * scale;
        if (hitTest(ev.x, ev.y, centerX, delY, 180 * scale, 40 * scale)) { die('You deleted everything. Including yourself.'); return; }
      }
    }
  },
  draw() {
    ctx.fillStyle = '#1a1a2e'; ctx.fillRect(0, 0, W, H);
    if (roomState.shakeIntensity > 0) { ctx.save(); ctx.translate((Math.random()-0.5) * roomState.shakeIntensity, (Math.random()-0.5) * roomState.shakeIntensity); }
    ctx.save(); ctx.globalAlpha = 0.05 + Math.sin(gameTime * 10) * 0.03;
    for (let i = 0; i < 30; i++) { ctx.fillStyle = Math.random() > 0.5 ? '#fff' : '#000'; ctx.fillRect(Math.random() * W, Math.random() * 60 * scale, Math.random() * 50 * scale, 2); }
    ctx.restore();
    drawCleanText('SAVE DATA MANAGER', centerX, 40 * scale, 18, '#ff4444', 'center', '700');
    drawCleanText('WARNING: Corruption detected', centerX, 65 * scale, 11, '#ff8800');
    for (let i = 0; i < 3; i++) {
      const slotY = centerY - 40 * scale + i * 70 * scale;
      const slot = roomState.corruptedSlots[i];
      ctx.save(); ctx.fillStyle = slot.corrupted ? 'rgba(255,50,50,0.15)' : 'rgba(50,255,50,0.15)';
      roundRect(centerX - 125 * scale, slotY - 27 * scale, 250 * scale, 55 * scale, 8 * scale); ctx.fill();
      ctx.strokeStyle = slot.corrupted ? '#cc3333' : '#33cc33'; ctx.lineWidth = 1.5 * scale;
      roundRect(centerX - 125 * scale, slotY - 27 * scale, 250 * scale, 55 * scale, 8 * scale); ctx.stroke(); ctx.restore();
      drawCleanText(slot.name, centerX, slotY - 5 * scale, 14, slot.corrupted ? '#ff6666' : '#66ff66');
      drawCleanText(slot.corrupted ? '[CORRUPTED]' : '[OK]', centerX, slotY + 15 * scale, 10, slot.corrupted ? '#cc3333' : '#33cc33');
      if (slot.corrupted && Math.random() < 0.1) { ctx.save(); ctx.globalAlpha = 0.3; ctx.fillStyle = '#ff0000'; ctx.fillRect(centerX - 120 * scale + Math.random() * 200 * scale, slotY - 20 * scale + Math.random() * 40 * scale, Math.random() * 60 * scale, 3); ctx.restore(); }
    }
    drawCleanButton(centerX, centerY + 170 * scale, 180 * scale, 40 * scale, 'Delete All Saves', '#cc3333');
    if (hintLevel >= 3) { ctx.save(); ctx.globalAlpha = 0.3 + Math.sin(gameTime * 3) * 0.2; drawCleanText('(not all saves are corrupted...)', centerX, centerY + 210 * scale, 9, '#555'); ctx.restore(); }
    if (roomState.shakeIntensity > 0) ctx.restore();
  }
};

// --- ROOM 22: The Mirror Self ---
rooms[22] = {
  init() {
    roomState.playerX = centerX / 2;
    roomState.mirrorX = centerX + centerX / 2;
    roomState.desyncTimer = 0;
    roomState.syncCounter = 0;
    stickFigure.visible = true;
    stickFigure.eyeState = 'normal';
    stickFigure.x = centerX / 2;
    stickFigure.y = centerY + 40 * scale;
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    roomState.desyncTimer += deltaTime;
    const desync = Math.min(1, roomState.desyncTimer / 30);
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      if (ev.type === 'tap') {
        if (ev.x < W / 2) {
          roomState.playerX = ev.x;
          stickFigure.x = ev.x;
          sfxClick();
          roomState.mirrorX = W - ev.x + (Math.sin(gameTime) * desync * 60 * scale);
          roomState.syncCounter++;
        } else {
          if (roomState.desyncTimer > 15) {
            if (ev.y > centerY + 20 * scale && ev.y < centerY + 100 * scale) {
              sfxWin(); spawnParticles(ev.x, ev.y, 20, '#44ff44'); fadeToRoom(23); return;
            }
          }
          die('Stay on your side! The mirror is not for touching.');
          return;
        }
      }
    }
    if (roomState.desyncTimer > 20) roomState.mirrorX = W / 2 + W / 4 + Math.sin(gameTime * 1.5) * 80 * scale;
  },
  draw() {
    drawSketchBackground();
    ctx.save(); ctx.strokeStyle = '#aaa'; ctx.lineWidth = 3 * scale; ctx.setLineDash([10 * scale, 5 * scale]);
    ctx.beginPath(); ctx.moveTo(centerX, 60 * scale); ctx.lineTo(centerX, H - 30 * scale); ctx.stroke(); ctx.setLineDash([]); ctx.restore();
    drawText('Room 23: Mirror Self', centerX, 25 * scale, 12, '#999');
    drawText('YOUR SIDE', centerX / 2, 55 * scale, 9, '#666');
    drawText('MIRROR', centerX + centerX / 2, 55 * scale, 9, '#666');
    drawStickFigure(stickFigure.x, stickFigure.y, 0.7, stickFigure.eyeState);
    const mirrorEye = roomState.desyncTimer > 20 ? 'panic' : roomState.desyncTimer > 10 ? 'confused' : 'normal';
    ctx.save(); ctx.translate(roomState.mirrorX * 2, 0); ctx.scale(-1, 1);
    drawStickFigure(roomState.mirrorX, stickFigure.y, 0.7, mirrorEye); ctx.restore();
    if (roomState.desyncTimer > 10) { ctx.save(); ctx.globalAlpha = Math.min(0.8, (roomState.desyncTimer - 10) / 10); drawCleanText('Mirror is desyncing...', centerX, H - 60 * scale, 11, '#cc3333'); ctx.restore(); }
    if (roomState.desyncTimer > 15) { ctx.save(); ctx.globalAlpha = 0.3 + Math.sin(gameTime * 3) * 0.2; drawCleanText('Tap the mirror side now?', centerX, H - 40 * scale, 10, '#22aa22'); ctx.restore(); }
  }
};

// --- ROOM 23: The Recursive Room ---
rooms[23] = {
  init() {
    roomState.depth = 0;
    roomState.maxDepth = newGamePlus ? 5 : 3;
    stickFigure.visible = true;
    stickFigure.eyeState = 'confused';
    stickFigure.x = centerX;
    stickFigure.y = centerY + 50 * scale;
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    for (const ev of inputEvents) {
      if (showingDeath) continue;
      if (ev.type === 'tap') {
        const sz = 280 * scale * Math.pow(0.55, roomState.depth);
        const rx = centerX, ry = centerY + 20 * scale;
        if (hitTest(ev.x, ev.y, rx, ry, sz * 0.3, sz * 0.3) && roomState.depth >= roomState.maxDepth) {
          sfxWin(); spawnParticles(ev.x, ev.y, 25, '#44ff44'); fadeToRoom(24); return;
        }
        if (hitTest(ev.x, ev.y, rx, ry, sz, sz)) {
          sfxClick();
          if (roomState.depth < roomState.maxDepth) { roomState.depth++; shake(3); }
        } else {
          if (roomState.depth > 0) roomState.depth--;
          else die('There is no escape from the room. Only deeper rooms.');
        }
      }
    }
  },
  draw() {
    drawSketchBackground();
    drawText('Room 24: Recursion', centerX, 25 * scale, 12, '#999');
    const drawNestedRoom = (x, y, size, depth) => {
      if (depth > roomState.maxDepth + 1) return;
      const isCurrentDepth = depth === roomState.depth;
      ctx.save(); ctx.globalAlpha = isCurrentDepth ? 1 : 0.3 + depth * 0.1;
      wobblyRect(x - size/2, y - size/2, size, size, isCurrentDepth ? '#222' : '#888', isCurrentDepth ? 'rgba(245,240,230,0.9)' : 'rgba(200,195,185,0.5)', isCurrentDepth ? 2.5 : 1);
      if (size > 40 * scale) drawText('Room ' + (24 + depth), x, y - size/2 + 15 * scale, Math.max(6, 10 - depth * 2), '#888');
      if (depth === roomState.maxDepth) { ctx.fillStyle = '#44ff44'; ctx.globalAlpha = 0.5 + Math.sin(gameTime * 3) * 0.3; ctx.fillRect(x - size * 0.15, y - size * 0.15, size * 0.3, size * 0.3); if (size > 20 * scale) drawCleanText('EXIT', x, y, Math.max(5, 8 - depth), '#fff'); }
      ctx.restore();
      if (depth < roomState.maxDepth + 1) drawNestedRoom(x, y, size * 0.55, depth + 1);
    };
    drawNestedRoom(centerX, centerY + 20 * scale, 280 * scale, 0);
    const currentSize = 280 * scale * Math.pow(0.55, roomState.depth);
    stickFigure.x = centerX;
    stickFigure.y = centerY + 20 * scale + currentSize * 0.2;
    drawStickFigure(stickFigure.x, stickFigure.y, Math.max(0.2, 0.7 * Math.pow(0.7, roomState.depth)), stickFigure.eyeState);
    drawText('Depth: ' + roomState.depth + '/' + roomState.maxDepth, centerX, H - 40 * scale, 11, '#666');
    drawText('Tap inside to go deeper. Tap outside to go back.', centerX, H - 20 * scale, 8, '#999');
  }
};

// ============================================================
// ACT 5: ROOM 24 â€” THE FINAL DECEPTION
// ============================================================

// --- ROOM 24: The Final Room ---
rooms[24] = {
  init() {
    roomState.phase = 'fake_ending';
    roomState.timer = 0;
    roomState.revealTimer = 0;
    roomState.wallTaps = { top: 0, right: 0, bottom: 0, left: 0 };
    stickFigure.visible = true;
    stickFigure.eyeState = 'happy';
    stickFigure.x = centerX;
    stickFigure.y = centerY + 40 * scale;
    document.title = 'Congratulations! You Won!';
  },
  update() {
    stickFigure.breathPhase += deltaTime * 2;
    roomState.timer += deltaTime;
    if (roomState.phase === 'fake_ending') {
      if (roomState.timer > 5) {
        roomState.phase = 'reveal'; roomState.revealTimer = 0; stickFigure.eyeState = 'panic';
        document.title = 'Wait... something is wrong'; shake(15); sfxExplosion();
      }
      for (const ev of inputEvents) { if (ev.type === 'tap') spawnParticles(ev.x, ev.y, 3, '#ffd700'); }
    }
    if (roomState.phase === 'reveal') {
      roomState.revealTimer += deltaTime;
      if (roomState.revealTimer > 3) { roomState.phase = 'real_exit'; stickFigure.eyeState = 'confused'; document.title = 'Trust Nothing - Find the real exit'; }
    }
    if (roomState.phase === 'real_exit') {
      for (const ev of inputEvents) {
        if (showingDeath) continue;
        if (ev.type === 'tap') {
          const margin = 40 * scale;
          if (ev.y < margin) roomState.wallTaps.top++;
          else if (ev.x > W - margin) roomState.wallTaps.right++;
          else if (ev.y > H - margin) roomState.wallTaps.bottom++;
          else if (ev.x < margin) roomState.wallTaps.left++;
          else {
            if (hitTest(ev.x, ev.y, centerX, centerY + 20 * scale, 180 * scale, 50 * scale)) {
              die('Did you learn NOTHING? The big button is ALWAYS a trap!'); return;
            }
          }
          if (roomState.wallTaps.top >= 1 && roomState.wallTaps.right >= 1 && roomState.wallTaps.bottom >= 1 && roomState.wallTaps.left >= 1) {
            sfxWin(); spawnParticles(centerX, centerY, 40, '#44ff44'); document.title = 'Trust Nothing';
            unlock('allwalls'); unlock('act5complete');
            showChapterComplete();
            return;
          }
        }
      }
    }
  },
  draw() {
    if (roomState.phase === 'fake_ending') {
      drawSketchBackground();
      ctx.save(); ctx.font = 'bold ' + (40 * scale) + "px 'Comic Sans MS', cursive"; ctx.textAlign = 'center'; ctx.fillStyle = '#ffd700'; ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 20 * scale;
      ctx.fillText('YOU WON!', centerX, centerY - 80 * scale); ctx.restore();
      drawText('Congratulations!', centerX, centerY - 30 * scale, 20, '#22aa22');
      drawText('Only ' + totalDeaths + ' deaths!', centerX, centerY, 16, '#666');
      drawStickFigure(stickFigure.x, stickFigure.y, 1, 'happy');
      if (Math.random() < 0.4) { const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#ffd700']; spawnParticles(Math.random() * W, -10, 1, colors[Math.floor(Math.random() * colors.length)], 2); }
    } else if (roomState.phase === 'reveal') {
      const glitchAmt = roomState.revealTimer * 5;
      ctx.fillStyle = '#f5f0e6'; ctx.fillRect(0, 0, W, H);
      for (let i = 0; i < glitchAmt; i++) { ctx.save(); ctx.fillStyle = 'rgba(' + Math.floor(Math.random()*255) + ',' + Math.floor(Math.random()*50) + ',' + Math.floor(Math.random()*50) + ',0.3)'; ctx.fillRect(0, Math.random() * H, W, 2 + Math.random() * 5); ctx.restore(); }
      drawText('WAIT...', centerX, centerY - 50 * scale, 36, '#cc3333');
      drawText('That ending was FAKE.', centerX, centerY, 18, '#222');
      drawText('You should know better by now.', centerX, centerY + 30 * scale, 14, '#888');
      drawStickFigure(stickFigure.x, stickFigure.y, 0.8, 'panic');
    } else {
      drawSketchBackground();
      drawText('Room 25: The REAL Final Room', centerX, 25 * scale, 14, '#cc3333');
      drawSketchButton(centerX, centerY + 20 * scale, 180 * scale, 50 * scale, 'FINISH GAME', '#fff', '#ff8800', true);
      drawStickFigure(stickFigure.x, stickFigure.y, 0.7, stickFigure.eyeState);
      const wallAlpha = 0.15 + hintLevel * 0.05;
      ctx.save(); ctx.globalAlpha = wallAlpha;
      ctx.fillStyle = roomState.wallTaps.top > 0 ? '#44ff44' : '#ff4444'; ctx.fillRect(0, 0, W, roomState.wallTaps.top > 0 ? 40 * scale : 5 * scale);
      ctx.fillStyle = roomState.wallTaps.right > 0 ? '#44ff44' : '#ff4444'; ctx.fillRect(W - (roomState.wallTaps.right > 0 ? 40 : 5) * scale, 0, (roomState.wallTaps.right > 0 ? 40 : 5) * scale, H);
      ctx.fillStyle = roomState.wallTaps.bottom > 0 ? '#44ff44' : '#ff4444'; ctx.fillRect(0, H - (roomState.wallTaps.bottom > 0 ? 40 : 5) * scale, W, (roomState.wallTaps.bottom > 0 ? 40 : 5) * scale);
      ctx.fillStyle = roomState.wallTaps.left > 0 ? '#44ff44' : '#ff4444'; ctx.fillRect(0, 0, (roomState.wallTaps.left > 0 ? 40 : 5) * scale, H);
      ctx.restore();
      if (hintLevel >= 3) drawText('Tap all four walls...', centerX, H - 60 * scale, 10, '#888');
      const tapped = (roomState.wallTaps.top > 0 ? 1 : 0) + (roomState.wallTaps.right > 0 ? 1 : 0) + (roomState.wallTaps.bottom > 0 ? 1 : 0) + (roomState.wallTaps.left > 0 ? 1 : 0);
      if (tapped > 0 && tapped < 4) drawText(tapped + '/4', centerX, centerY + 80 * scale, 12, '#22aa22');
    }
  }
};

// ============================================================
// SECRET ENDINGS
// ============================================================

// Secret Ending 1: "The Pacifist" - complete with 0 deaths (checked at chapter complete)
// Secret Ending 2: "The Konami Code" - enter Konami Code anytime
document.addEventListener('keydown', (e) => {
  konami.push(e.keyCode);
  if (konami.length > KONAMI_CODE.length) konami.shift();
  if (konami.length === KONAMI_CODE.length && konami.every((v, i) => v === KONAMI_CODE[i])) {
    triggerSecretEnding('konami');
  }
});

function triggerSecretEnding(endingId) {
  if (secretEndingsFound[endingId]) return;
  secretEndingsFound[endingId] = { time: Date.now() };
  saveSecrets();
  chapterComplete = true;
  stopAllAmbient();
  roomState.secretEnding = endingId;
  unlock('secret_' + endingId);
}

// ============================================================
// ACHIEVEMENTS (expanded)
// ============================================================
let achievements = {};
try { const a = localStorage.getItem('trustnothing_ach'); if (a) achievements = JSON.parse(a); } catch(e) {}
function saveAchievements() { try { localStorage.setItem('trustnothing_ach', JSON.stringify(achievements)); } catch(e) {} }

let achievementPopup = null;
let achievementPopupTimer = 0;

const ACHIEVEMENTS = {
  firstdeath: { name: 'Welcome to Pain', desc: 'Die for the first time' },
  speedster: { name: 'Speed Demon', desc: 'Complete all rooms in under 5 minutes' },
  persistent: { name: 'Never Give Up', desc: 'Die 50 times total' },
  truthseeker: { name: 'Truth Seeker', desc: 'Question the fake score' },
  nodeath5: { name: 'Untouchable', desc: 'Clear a room with 0 deaths' },
  masochist: { name: 'Masochist', desc: 'Die 100 times total' },
  act2complete: { name: 'System Breaker', desc: 'Complete Act 2' },
  act3complete: { name: 'Nothing Is Real', desc: 'Complete Act 3' },
  act4complete: { name: 'Meta Gamer', desc: 'Complete Act 4' },
  act5complete: { name: 'Trust Destroyer', desc: 'Complete Act 5' },
  secret_konami: { name: 'Old School', desc: 'Enter the Konami Code' },
  secret_pacifist: { name: 'The Pacifist', desc: 'Complete the game with 0 deaths' },
  secret_speedrun: { name: 'Lightspeed', desc: 'Complete in under 2 minutes' },
  ngplus: { name: 'New Game+', desc: 'Start New Game+ mode' },
  ngplus_complete: { name: 'Trust Nothing Twice', desc: 'Complete New Game+' },
  allwalls: { name: 'Wall Tapper', desc: 'Tap all walls in the final room' },
  death200: { name: 'Glutton for Punishment', desc: 'Die 200 times' },
  narrator: { name: 'Shut Up Narrator', desc: 'Tap the narrator to escape' },
};

function unlock(id) {
  if (achievements[id]) return;
  achievements[id] = { time: Date.now() };
  saveAchievements();
  achievementPopup = ACHIEVEMENTS[id];
  achievementPopupTimer = 3;
}

function drawAchievementPopup() {
  if (!achievementPopup || achievementPopupTimer <= 0) return;
  achievementPopupTimer -= deltaTime;
  const alpha = Math.min(1, achievementPopupTimer, (3 - (3 - achievementPopupTimer)) > 2.5 ? (3 - achievementPopupTimer) * 2 : 1);
  ctx.save();
  ctx.globalAlpha = alpha;
  const popW = 240 * scale;
  const popH = 50 * scale;
  const popX = centerX - popW / 2;
  const popY = 50 * scale;
  ctx.fillStyle = 'rgba(0,0,0,0.85)';
  roundRect(popX, popY, popW, popH, 8 * scale);
  ctx.fill();
  ctx.strokeStyle = '#ffd700';
  ctx.lineWidth = 2 * scale;
  roundRect(popX, popY, popW, popH, 8 * scale);
  ctx.stroke();
  drawCleanText('ðŸ† ' + achievementPopup.name, centerX, popY + 18 * scale, 13, '#ffd700', 'center', '700');
  drawCleanText(achievementPopup.desc, centerX, popY + 38 * scale, 10, '#aaa');
  ctx.restore();
  if (achievementPopupTimer <= 0) achievementPopup = null;
}

// ============================================================
// SPEEDRUN TIMER
// ============================================================
let speedrunMode = false;
let speedrunStartTime = 0;
let speedrunBestTime = Infinity;
try { const st = localStorage.getItem('trustnothing_speedrun'); if (st) speedrunBestTime = parseFloat(st) || Infinity; } catch(e) {}
function saveSpeedrunBest() { try { localStorage.setItem('trustnothing_speedrun', speedrunBestTime.toString()); } catch(e) {} }

function drawSpeedrunTimer() {
  if (!speedrunMode) return;
  const elapsed = gameTime - speedrunStartTime;
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  roundRect(W - 120 * scale, 40 * scale, 110 * scale, 28 * scale, 4 * scale);
  ctx.fill();
  ctx.font = `bold ${12 * scale}px monospace`;
  ctx.textAlign = 'right';
  ctx.fillStyle = '#00ff88';
  ctx.fillText(`â± ${elapsed.toFixed(1)}s`, W - 16 * scale, 59 * scale);
  if (speedrunBestTime < Infinity) {
    ctx.fillStyle = '#888';
    ctx.font = `${9 * scale}px monospace`;
    ctx.fillText(`Best: ${speedrunBestTime.toFixed(1)}s`, W - 16 * scale, 72 * scale);
  }
  ctx.restore();
}

// ============================================================
// CHAPTER COMPLETE SCREEN
// ============================================================
let chapterComplete = false;

function showChapterComplete() {
  chapterComplete = true;
  stopAllAmbient();
  // Speedrun check
  if (speedrunMode) {
    const elapsed = gameTime - speedrunStartTime;
    if (elapsed < speedrunBestTime) {
      speedrunBestTime = elapsed;
      saveSpeedrunBest();
    }
    if (elapsed < 180) unlock('speedster');
  }
  // Achievement checks
  if (roomDeaths === 0) unlock('nodeath5');
  if (totalDeaths >= 50) unlock('persistent');
  if (totalDeaths >= 100) unlock('masochist');
}

function drawChapterComplete() {
  if (!chapterComplete) return;
  
  drawSketchBackground();
  
  const t = gameTime;
  
  drawText('Chapter 1', centerX, centerY - 120 * scale, 28, '#222');
  drawText('COMPLETE!', centerX, centerY - 80 * scale, 32, '#22aa22');
  
  drawText(`You died ${totalDeaths} times.`, centerX, centerY - 20 * scale, 18, '#666');
  
  if (totalDeaths > 30) {
    drawText("That's... impressive, actually.", centerX, centerY + 15 * scale, 14, '#999');
  } else if (totalDeaths > 15) {
    drawText("Not bad. Not great. But not bad.", centerX, centerY + 15 * scale, 14, '#999');
  } else {
    drawText("Are you a wizard?", centerX, centerY + 15 * scale, 14, '#999');
  }
  
  // Stick figure celebrating
  drawStickFigure(centerX, centerY + 80 * scale, 1.2, 'happy');
  
  // Confetti particles
  if (Math.random() < 0.2) {
    const colors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff'];
    spawnParticles(Math.random() * W, -10, 1, colors[Math.floor(Math.random() * colors.length)], 2);
  }
  
  // Speedrun result
  if (speedrunMode) {
    const elapsed = gameTime - speedrunStartTime;
    drawText(`Speedrun: ${elapsed.toFixed(1)}s`, centerX, centerY + 120 * scale, 14, '#00ff88');
    if (speedrunBestTime < Infinity) {
      drawText(`Best: ${speedrunBestTime.toFixed(1)}s`, centerX, centerY + 145 * scale, 11, '#888');
    }
  }

  // Achievements earned
  const achCount = Object.keys(achievements).length;
  const achTotal = Object.keys(ACHIEVEMENTS).length;
  drawText(`Achievements: ${achCount}/${achTotal}`, centerX, H - 100 * scale, 12, '#ffd700');

  drawText('Thanks for playing!', centerX, H - 70 * scale, 14, '#aaa');
  drawText('Chapter 2 coming soon...', centerX, H - 48 * scale, 11, '#ccc');
}

// ============================================================
// ROOM MANAGEMENT
// ============================================================
function initRoom(index) {
  inputEvents = [];
  particles = [];
  stopAllAmbient();
  if (rooms[index] && rooms[index].init) rooms[index].init();
}

function updateRoom() {
  if (chapterComplete) {
    stickFigure.breathPhase += deltaTime * 2;
    inputEvents = [];
    return;
  }
  if (rooms[currentRoom] && rooms[currentRoom].update) {
    rooms[currentRoom].update();
  }
  inputEvents = [];
}

function drawRoom() {
  if (chapterComplete) {
    drawChapterComplete();
    return;
  }
  if (rooms[currentRoom] && rooms[currentRoom].draw) {
    rooms[currentRoom].draw();
  }
}

// ============================================================
// MAIN LOOP
// ============================================================
function gameLoop(timestamp) {
  const now = timestamp / 1000;
  deltaTime = Math.min(0.05, now - (lastTime || now));
  lastTime = now;
  gameTime += deltaTime;
  
  // Clear
  ctx.clearRect(0, 0, W, H);
  
  // Apply shake
  ctx.save();
  applyShake();
  
  // Draw room
  drawRoom();
  
  // Particles
  updateParticles();
  drawParticles();
  
  ctx.restore();
  
  // Death overlay (not shaken)
  drawDeathOverlay();
  
  // Death counter (always visible)
  drawDeathCounter();

  // Speedrun timer
  drawSpeedrunTimer();

  // Achievement popup
  drawAchievementPopup();

  // Mute button (always visible)
  drawMuteButton();

  // Transition overlay
  updateTransition();
  drawTransition();
  
  // Update room logic
  updateRoom();
  
  requestAnimationFrame(gameLoop);
}

// ============================================================
// START
// ============================================================
initRoom(0);
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
