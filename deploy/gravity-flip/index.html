<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#1a0033">
<title>Gravity Flip</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a001a;touch-action:none;user-select:none;-webkit-user-select:none;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',system-ui,sans-serif}
canvas{display:block;width:100%;height:100%}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
'use strict';

// ============================================================
// GRAVITY FLIP ‚Äî Polished Mobile Platformer v2
// Tap anywhere to flip gravity. Collect orbs. Reach the portal.
// ============================================================

const C = document.getElementById('game');
const X = C.getContext('2d');

// --- GLOBALS ---
let W, H, S;
let gt = 0, dt = 0, lt = 0;
let screen = 'menu';
let lvl = 0;
let gs = {};
let particles = [];
let floatingTexts = [];
let screenShake = 0;
let screenFlash = 0;
let screenFlashColor = '#fff';
let combo = 0, comboTimer = 0;
let deathTimer = 0;
let transAlpha = 0, transTarget = 0, transCallback = null;
let starField = [];
let audioCtx = null, masterGain = null;
let musicOscs = [];
let bestTotalStars = 0;
let nearMissTimer = 0;
let bestRun = null; // ghost data
let menuPulse = 0;
let tapPromptAlpha = 1;
let victoryAnimTime = 0;
let slowMo = 0; // slow motion effect on death/win
let speedLines = [];
let cameraZoom = 1;
let cameraZoomTarget = 1;
let levelColors = [
  { accent: '#00ffff', bg1: '#0a001a', bg2: '#1a0033' },
  { accent: '#00ff88', bg1: '#001a0a', bg2: '#003320' },
  { accent: '#ff6644', bg1: '#1a0800', bg2: '#331500' },
  { accent: '#ff44aa', bg1: '#1a000a', bg2: '#330020' },
  { accent: '#ffaa00', bg1: '#1a0f00', bg2: '#332200' },
  { accent: '#b464ff', bg1: '#0f001a', bg2: '#200033' },
  { accent: '#44ddff', bg1: '#001018', bg2: '#002030' },
  { accent: '#ff4444', bg1: '#1a0000', bg2: '#330000' },
  { accent: '#66ff66', bg1: '#001a00', bg2: '#003300' },
  { accent: '#ffd700', bg1: '#1a1000', bg2: '#332800' },
  { accent: '#00ffff', bg1: '#0a001a', bg2: '#1a0033' },
  { accent: '#ff66ff', bg1: '#1a001a', bg2: '#330033' },
  { accent: '#44ff88', bg1: '#001a0a', bg2: '#003320' },
  { accent: '#ffaa44', bg1: '#1a0f00', bg2: '#332200' },
  { accent: '#ff2266', bg1: '#1a000a', bg2: '#330015' },
];
let currentAccent = '#00ffff';
let totalScore = 0;
try { const ts = localStorage.getItem('gflip3_score'); if (ts) totalScore = parseInt(ts) || 0; } catch(e) {}
function saveTotalScore() { try { localStorage.setItem('gflip3_score', totalScore.toString()); } catch(e) {} }

// Progress
let progress = {};
try { const s = localStorage.getItem('gflip3'); if (s) progress = JSON.parse(s); } catch(e) {}
function saveProgress() { try { localStorage.setItem('gflip3', JSON.stringify(progress)); } catch(e) {} }

function calcTotalStars() {
  bestTotalStars = 0;
  for (const k in progress) if (progress[k].stars) bestTotalStars += progress[k].stars;
}
calcTotalStars();

// --- RESIZE ---
function resize() {
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = window.innerWidth; H = window.innerHeight;
  C.width = W * dpr; C.height = H * dpr;
  C.style.width = W + 'px'; C.style.height = H + 'px';
  X.setTransform(dpr, 0, 0, dpr, 0, 0);
  S = Math.min(W / 400, H / 700);
  initStarField();
}
window.addEventListener('resize', resize);
resize();

function initStarField() {
  starField = [];
  for (let i = 0; i < 100; i++) {
    starField.push({
      x: Math.random() * W, y: Math.random() * H,
      size: (0.5 + Math.random() * 2) * S,
      speed: (0.1 + Math.random() * 0.3) * S,
      brightness: 0.3 + Math.random() * 0.7,
      twinkleSpeed: 1 + Math.random() * 3,
      layer: Math.random() < 0.3 ? 2 : 1 // parallax layers
    });
  }
}

// ============================================================
// AUDIO ‚Äî richer sound design
// ============================================================
function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.3;
    masterGain.connect(audioCtx.destination);
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function tone(freq, dur, type = 'sine', vol = 0.15, delay = 0) {
  if (!audioCtx) return;
  const t = audioCtx.currentTime + delay;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.setValueAtTime(vol, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur);
  o.connect(g); g.connect(masterGain);
  o.start(t); o.stop(t + dur);
}

function noise(dur, vol = 0.1) {
  if (!audioCtx) return;
  const bufferSize = audioCtx.sampleRate * dur;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
  const src = audioCtx.createBufferSource();
  src.buffer = buffer;
  const g = audioCtx.createGain();
  const f = audioCtx.createBiquadFilter();
  f.type = 'bandpass'; f.frequency.value = 2000; f.Q.value = 1;
  g.gain.setValueAtTime(vol, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  src.connect(f); f.connect(g); g.connect(masterGain);
  src.start(); src.stop(audioCtx.currentTime + dur);
}

function sfxFlip() {
  tone(280, 0.06, 'square', 0.1);
  tone(420, 0.08, 'sine', 0.12, 0.02);
  tone(560, 0.04, 'sine', 0.06, 0.04);
}

function sfxCollect() {
  const base = 700 + combo * 100;
  tone(base, 0.12, 'sine', 0.2);
  tone(base * 1.25, 0.1, 'sine', 0.15, 0.04);
  tone(base * 1.5, 0.08, 'triangle', 0.1, 0.08);
  if (combo > 2) tone(base * 2, 0.06, 'sine', 0.08, 0.1);
}

function sfxDeath() {
  tone(200, 0.3, 'sawtooth', 0.2);
  tone(100, 0.4, 'sawtooth', 0.15, 0.1);
  tone(50, 0.5, 'square', 0.1, 0.2);
  noise(0.3, 0.08);
}

function sfxWin() {
  const notes = [523, 659, 784, 1047, 1319];
  notes.forEach((f, i) => {
    tone(f, 0.25, 'sine', 0.18, i * 0.08);
    tone(f * 0.5, 0.2, 'triangle', 0.06, i * 0.08);
  });
}

function sfxBounce() {
  tone(300 + Math.random() * 200, 0.08, 'triangle', 0.1);
  tone(600 + Math.random() * 200, 0.04, 'sine', 0.06, 0.02);
}

function sfxClick() { tone(900, 0.04, 'sine', 0.1); tone(1200, 0.03, 'sine', 0.05, 0.02); }

function sfxCombo() {
  const f = 1400 + combo * 120;
  tone(f, 0.15, 'sine', 0.12);
  tone(f * 1.5, 0.1, 'sine', 0.08, 0.05);
}

function sfxNearMiss() {
  tone(1600, 0.05, 'sine', 0.06);
  tone(2000, 0.03, 'sine', 0.04, 0.02);
}

function sfxCrumble() {
  noise(0.2, 0.06);
  tone(120, 0.15, 'square', 0.05);
}

// Adaptive music
let musicPlaying = false;
let musicGainNode = null;
let musicBeat = 0;
let musicBPM = 90;

function startMusic() {
  if (musicPlaying || !audioCtx) return;
  musicPlaying = true;
  
  musicGainNode = audioCtx.createGain();
  musicGainNode.gain.value = 0.02;
  musicGainNode.connect(masterGain);
  
  // Ambient pad
  const notes = [55, 82.5, 110, 165];
  notes.forEach(f => {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = f;
    g.gain.value = 0.4;
    o.connect(g); g.connect(musicGainNode);
    o.start();
    musicOscs.push(o);
  });
}

// ============================================================
// PARTICLES ‚Äî enhanced system
// ============================================================
function emit(x, y, count, color = '#00ffff', spread = 3, grav = 0.15, opts = {}) {
  for (let i = 0; i < count; i++) {
    const angle = opts.dir !== undefined ? opts.dir + (Math.random() - 0.5) * (opts.spread || 1) : Math.random() * Math.PI * 2;
    const speed = (opts.speed || spread) * (0.5 + Math.random() * 0.5) * S;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      decay: 0.01 + Math.random() * 0.02,
      size: (opts.size || (2 + Math.random() * 5)) * S,
      color, grav: grav * S,
      shape: opts.shape || 'rect',
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.3
    });
  }
}

function emitTrail(x, y, color = '#00ffff') {
  if (Math.random() > 0.5) return;
  particles.push({
    x: x + (Math.random() - 0.5) * 6 * S,
    y: y + (Math.random() - 0.5) * 6 * S,
    vx: (Math.random() - 0.5) * 0.3 * S,
    vy: (Math.random() - 0.5) * 0.3 * S,
    life: 0.7, decay: 0.025,
    size: (1 + Math.random() * 3) * S,
    color, grav: 0, shape: 'circle'
  });
}

function emitSpark(x, y, color, count = 5) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const s = (2 + Math.random() * 4) * S;
    particles.push({
      x, y,
      vx: Math.cos(a) * s, vy: Math.sin(a) * s,
      life: 1, decay: 0.03 + Math.random() * 0.03,
      size: (1 + Math.random() * 2) * S,
      color, grav: 0.05 * S, shape: 'circle'
    });
  }
}

function addFloatingText(x, y, text, color = '#ffd700', size = 20) {
  floatingTexts.push({
    x, y, text, color, size,
    vy: -1.5 * S, life: 1, decay: 0.015
  });
}

function updateParticles() {
  const d60 = dt * 60;
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * d60; p.y += p.vy * d60;
    p.vy += (p.grav || 0) * d60;
    p.vx *= Math.pow(0.99, d60); p.vy *= Math.pow(0.99, d60);
    if (p.rotation !== undefined) p.rotation += (p.rotSpeed || 0) * d60;
    p.life -= p.decay * d60;
    if (p.life <= 0) particles.splice(i, 1);
  }
  if (particles.length > 300) particles.splice(0, particles.length - 300);

  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const f = floatingTexts[i];
    f.y += f.vy * d60;
    f.life -= f.decay * d60;
    if (f.life <= 0) floatingTexts.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    X.save();
    X.globalAlpha = Math.min(1, p.life * 0.9);
    X.fillStyle = p.color;
    X.shadowColor = p.color;
    X.shadowBlur = 4 * S;
    if (p.shape === 'circle') {
      X.beginPath();
      X.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
      X.fill();
    } else {
      X.translate(p.x, p.y);
      if (p.rotation) X.rotate(p.rotation);
      X.fillRect(-p.size/2, -p.size/2, p.size, p.size);
    }
    X.restore();
  }
  
  for (const f of floatingTexts) {
    X.save();
    X.globalAlpha = f.life;
    X.fillStyle = f.color;
    X.font = `bold ${f.size * S}px sans-serif`;
    X.textAlign = 'center';
    X.shadowColor = f.color;
    X.shadowBlur = 8 * S;
    X.fillText(f.text, f.x, f.y);
    X.restore();
  }
}

// ============================================================
// DRAWING HELPERS
// ============================================================
function drawBg() {
  const lc = levelColors[lvl] || levelColors[0];
  const bg1 = (screen === 'game' || screen === 'victory') ? lc.bg1 : '#0a001a';
  const bg2 = (screen === 'game' || screen === 'victory') ? lc.bg2 : '#1a0033';
  const g = X.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, bg1);
  g.addColorStop(0.5, bg2);
  g.addColorStop(1, bg1);
  X.fillStyle = g;
  X.fillRect(0, 0, W, H);
  
  for (const s of starField) {
    s.y += s.speed * s.layer * 0.5 * dt * 60;
    if (s.y > H) { s.y = -2; s.x = Math.random() * W; }
    const b = s.brightness * (0.5 + Math.sin(gt * s.twinkleSpeed) * 0.5);
    X.fillStyle = `rgba(200,200,255,${b})`;
    if (s.layer === 2) {
      X.beginPath();
      X.arc(s.x, s.y, s.size * 0.6, 0, Math.PI * 2);
      X.fill();
    } else {
      X.fillRect(s.x, s.y, s.size, s.size);
    }
  }
}

function drawNeonText(text, x, y, size, color = '#00ffff', align = 'center') {
  X.save();
  X.fillStyle = color;
  X.font = `bold ${size * S}px sans-serif`;
  X.textAlign = align;
  X.shadowColor = color;
  X.shadowBlur = 20 * S;
  X.fillText(text, x, y);
  X.shadowBlur = 8 * S;
  X.fillText(text, x, y);
  X.shadowBlur = 0;
  X.fillStyle = '#fff';
  X.globalAlpha = 0.3;
  X.fillText(text, x, y);
  X.restore();
}

function drawBtn(x, y, w, h, text, primary = true) {
  X.save();
  const hovered = false;
  const r = 6 * S;
  
  X.beginPath();
  X.roundRect(x, y, w, h, r);
  
  if (primary) {
    const grad = X.createLinearGradient(x, y, x, y + h);
    grad.addColorStop(0, '#00ffff');
    grad.addColorStop(1, '#0088aa');
    X.fillStyle = grad;
    X.shadowColor = '#00ffff';
    X.shadowBlur = 15 * S;
    X.fill();
    X.fillStyle = '#000';
  } else {
    X.fillStyle = 'rgba(0,255,255,0.08)';
    X.fill();
    X.strokeStyle = '#00ffff';
    X.lineWidth = 2 * S;
    X.shadowColor = '#00ffff';
    X.shadowBlur = 8 * S;
    X.stroke();
    X.fillStyle = '#00ffff';
  }
  X.font = `bold ${18 * S}px sans-serif`;
  X.textAlign = 'center';
  X.shadowBlur = 0;
  X.fillText(text, x + w/2, y + h/2 + 6 * S);
  X.restore();
  return { x, y, w, h };
}

function hit(px, py, box) {
  return box && px >= box.x && px <= box.x + box.w && py >= box.y && py <= box.y + box.h;
}

// Ease functions
function easeOutBack(t) { const c = 1.70158; return 1 + (c + 1) * Math.pow(t - 1, 3) + c * Math.pow(t - 1, 2); }
function easeOutElastic(t) { return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * (2 * Math.PI / 3)) + 1; }
function easeInOutCubic(t) { return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2; }

// ============================================================
// PLAYER
// ============================================================
class Player {
  constructor(x, y) {
    this.x = x; this.y = y;
    this.vx = 0; this.vy = 0;
    this.radius = 11 * S;
    this.gravDir = 1;
    this.gravity = 0.5 * S;
    this.moveSpeed = 2.8 * S;
    this.grounded = false;
    this.trail = [];
    this.flipAnim = 0;
    this.alive = true;
    this.squash = 1;
    this.flipCount = 0;
    this.lastGroundY = y;
    this.airTime = 0;
    this.glowPulse = 0;
    this.invuln = 0; // brief invulnerability after respawn
  }

  flip() {
    if (!this.alive) return;
    this.gravDir *= -1;
    this.vy = this.gravDir * -3.5 * S;
    this.flipAnim = 1;
    this.squash = 0.55;
    this.flipCount++;
    this.airTime = 0;
    sfxFlip();
    
    // Directional burst particles
    const dir = this.gravDir === 1 ? -Math.PI/2 : Math.PI/2;
    emit(this.x, this.y, 8, '#00ffff', 2.5, 0, { dir, spread: 1.2, shape: 'circle' });
    emit(this.x, this.y, 4, '#ffffff', 1.5, 0, { dir, spread: 0.8, size: 1.5, shape: 'circle' });
    screenShake = Math.max(screenShake, 4);
  }

  update() {
    if (!this.alive) return;
    
    const d60 = dt * 60;
    this.vx = this.moveSpeed;
    this.vy += this.gravity * this.gravDir * d60;

    if (Math.abs(this.vy) > 9 * S) this.vy = 9 * S * Math.sign(this.vy);

    this.x += this.vx * d60;
    this.y += this.vy * d60;

    const squashLerp = 1 - Math.pow(0.82, d60);
    this.squash += (1 - this.squash) * squashLerp;
    this.flipAnim *= Math.pow(0.88, d60);
    this.glowPulse += dt * 5;
    this.airTime += dt;
    if (this.invuln > 0) this.invuln -= dt;
    
    // Trail
    this.trail.push({ x: this.x, y: this.y, life: 1 });
    if (this.trail.length > 25) this.trail.shift();
    for (const t of this.trail) t.life -= 0.035;
    
    // Speed trail particles
    emitTrail(this.x - 8 * S, this.y);
    
    this.grounded = false;
  }

  draw() {
    if (!this.alive) return;
    
    // Trail with gradient
    X.save();
    for (let i = 1; i < this.trail.length; i++) {
      const t = this.trail[i];
      const prev = this.trail[i-1];
      if (t.life <= 0 || prev.life <= 0) continue;
      X.globalAlpha = t.life * 0.25;
      X.strokeStyle = '#00ffff';
      X.lineWidth = t.life * this.radius * 1.5;
      X.lineCap = 'round';
      X.beginPath();
      X.moveTo(prev.x, prev.y);
      X.lineTo(t.x, t.y);
      X.stroke();
    }
    X.restore();
    
    // Outer glow (pulsing)
    X.save();
    const glowSize = this.radius * (2.5 + Math.sin(this.glowPulse) * 0.3);
    const grad = X.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
    grad.addColorStop(0, 'rgba(0,255,255,0.25)');
    grad.addColorStop(0.5, 'rgba(0,255,255,0.08)');
    grad.addColorStop(1, 'rgba(0,255,255,0)');
    X.fillStyle = grad;
    X.beginPath();
    X.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
    X.fill();
    X.restore();
    
    // Invulnerability flash
    if (this.invuln > 0 && Math.sin(gt * 30) > 0) return;
    
    // Body
    X.save();
    X.translate(this.x, this.y);
    const sy = this.squash;
    const sx = 1 + (1 - sy) * 0.6;
    X.scale(sx, sy);
    
    if (this.flipAnim > 0.01) {
      X.rotate(this.flipAnim * Math.PI * 2 * -this.gravDir);
    }
    
    // Shadow/depth
    X.fillStyle = '#008899';
    X.beginPath();
    X.arc(1 * S, 1 * S, this.radius, 0, Math.PI * 2);
    X.fill();
    
    // Main body
    const bodyGrad = X.createRadialGradient(-3*S, -3*S, 0, 0, 0, this.radius);
    bodyGrad.addColorStop(0, '#66ffff');
    bodyGrad.addColorStop(0.6, '#00ffff');
    bodyGrad.addColorStop(1, '#00bbcc');
    X.fillStyle = bodyGrad;
    X.shadowColor = '#00ffff';
    X.shadowBlur = 18 * S;
    X.beginPath();
    X.arc(0, 0, this.radius, 0, Math.PI * 2);
    X.fill();
    
    // Highlight
    X.fillStyle = 'rgba(255,255,255,0.4)';
    X.shadowBlur = 0;
    X.beginPath();
    X.arc(-3 * S, -3 * S, this.radius * 0.4, 0, Math.PI * 2);
    X.fill();
    
    // Eyes
    X.fillStyle = '#000';
    const eyeY = this.gravDir * -2.5 * S;
    const eyeSpread = 3.5 * S;
    // Eye whites
    X.fillStyle = '#fff';
    X.beginPath();
    X.arc(-eyeSpread, eyeY, 3 * S, 0, Math.PI * 2);
    X.arc(eyeSpread, eyeY, 3 * S, 0, Math.PI * 2);
    X.fill();
    // Pupils (look in movement direction)
    X.fillStyle = '#111';
    X.beginPath();
    X.arc(-eyeSpread + 0.8 * S, eyeY, 1.8 * S, 0, Math.PI * 2);
    X.arc(eyeSpread + 0.8 * S, eyeY, 1.8 * S, 0, Math.PI * 2);
    X.fill();
    // Eye shine
    X.fillStyle = '#fff';
    X.beginPath();
    X.arc(-eyeSpread - 0.5 * S, eyeY - 1 * S, 0.8 * S, 0, Math.PI * 2);
    X.arc(eyeSpread - 0.5 * S, eyeY - 1 * S, 0.8 * S, 0, Math.PI * 2);
    X.fill();
    
    X.restore();
    
    // Small gravity arrow
    X.save();
    X.globalAlpha = 0.35 + Math.sin(gt * 4) * 0.1;
    X.fillStyle = '#00ffff';
    const arrowY = this.y + this.gravDir * (this.radius + 10 * S);
    X.beginPath();
    X.moveTo(this.x, arrowY + this.gravDir * 5 * S);
    X.lineTo(this.x - 4 * S, arrowY);
    X.lineTo(this.x + 4 * S, arrowY);
    X.closePath();
    X.fill();
    X.restore();
  }

  collideRect(rx, ry, rw, rh) {
    const cx = Math.max(rx, Math.min(this.x, rx + rw));
    const cy = Math.max(ry, Math.min(this.y, ry + rh));
    const dx = this.x - cx, dy = this.y - cy;
    return (dx * dx + dy * dy) < (this.radius * this.radius);
  }

  collideCircle(cx, cy, r) {
    const dx = this.x - cx, dy = this.y - cy;
    return Math.sqrt(dx * dx + dy * dy) < (this.radius + r);
  }
  
  // Near miss detection ‚Äî how close to a rect
  nearMissRect(rx, ry, rw, rh, threshold) {
    const cx = Math.max(rx, Math.min(this.x, rx + rw));
    const cy = Math.max(ry, Math.min(this.y, ry + rh));
    const dx = this.x - cx, dy = this.y - cy;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return dist < this.radius + threshold && dist >= this.radius;
  }
}

// ============================================================
// LEVEL OBJECTS
// ============================================================
class Platform {
  constructor(x, y, w, h, type = 'solid') {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.type = type;
    this.ox = x; this.oy = y;
    this.moveTimer = Math.random() * Math.PI * 2;
    this.moveRangeX = 0; this.moveRangeY = 0;
    this.moveSpeed = 1;
    this.crumbleTimer = 0;
    this.crumbling = false;
    this.gone = false;
    this.hitAnim = 0;
  }

  update() {
    if (this.gone) return;
    if (this.type === 'moving') {
      this.moveTimer += dt * this.moveSpeed;
      this.x = this.ox + Math.sin(this.moveTimer) * this.moveRangeX;
      this.y = this.oy + Math.sin(this.moveTimer * 0.7) * this.moveRangeY;
    }
    if (this.crumbling) {
      this.crumbleTimer -= dt;
      if (this.crumbleTimer <= 0) {
        this.gone = true;
        emit(this.x + this.w/2, this.y + this.h/2, 15, '#c8a050', 3, 0.15);
        sfxCrumble();
      }
    }
    if (this.hitAnim > 0) this.hitAnim -= dt * 4;
  }

  draw() {
    if (this.gone) return;
    X.save();
    
    // Hit animation offset
    const hitOffset = this.hitAnim > 0 ? Math.sin(this.hitAnim * 20) * 2 * S : 0;
    
    const alpha = this.crumbling ? 0.3 + Math.sin(gt * 25) * 0.3 : 0.8;
    
    if (this.type === 'bouncy') {
      const grad = X.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
      grad.addColorStop(0, `rgba(0,255,128,${alpha * 0.7})`);
      grad.addColorStop(1, `rgba(0,200,80,${alpha * 0.5})`);
      X.fillStyle = grad;
      X.strokeStyle = '#00ff80';
      // Bouncy spring lines
      X.fillRect(this.x, this.y + hitOffset, this.w, this.h);
      X.lineWidth = 2 * S;
      X.shadowColor = '#00ff80';
      X.shadowBlur = 10 * S;
      X.strokeRect(this.x, this.y + hitOffset, this.w, this.h);
      // Spring zigzag decoration
      X.shadowBlur = 0;
      X.strokeStyle = 'rgba(0,255,128,0.3)';
      X.lineWidth = 1.5 * S;
      X.beginPath();
      const segs = Math.floor(this.w / (6 * S));
      for (let i = 0; i <= segs; i++) {
        const px = this.x + (i / segs) * this.w;
        const py = this.y + hitOffset + (i % 2 === 0 ? 0 : this.h);
        if (i === 0) X.moveTo(px, py); else X.lineTo(px, py);
      }
      X.stroke();
    } else if (this.type === 'crumble') {
      // Cracked appearance
      X.fillStyle = `rgba(160,130,80,${alpha * 0.6})`;
      X.strokeStyle = '#c8a050';
      X.fillRect(this.x, this.y + hitOffset, this.w, this.h);
      X.lineWidth = 2 * S;
      X.shadowColor = '#c8a050';
      X.shadowBlur = 6 * S;
      X.strokeRect(this.x, this.y + hitOffset, this.w, this.h);
      // Crack lines
      if (this.crumbling) {
        X.strokeStyle = 'rgba(200,160,80,0.6)';
        X.lineWidth = 1 * S;
        X.shadowBlur = 0;
        for (let i = 0; i < 3; i++) {
          const cx = this.x + this.w * (0.2 + i * 0.3);
          X.beginPath();
          X.moveTo(cx, this.y + hitOffset);
          X.lineTo(cx + (Math.random()-0.5) * 8 * S, this.y + this.h + hitOffset);
          X.stroke();
        }
      }
    } else {
      const grad = X.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
      grad.addColorStop(0, `rgba(60,60,100,${alpha * 0.7})`);
      grad.addColorStop(1, `rgba(40,40,70,${alpha * 0.5})`);
      X.fillStyle = grad;
      X.strokeStyle = '#00ccff';
      X.fillRect(this.x, this.y + hitOffset, this.w, this.h);
      X.lineWidth = 1.5 * S;
      X.shadowColor = '#00ccff';
      X.shadowBlur = 6 * S;
      X.strokeRect(this.x, this.y + hitOffset, this.w, this.h);
      // Edge highlight
      X.strokeStyle = 'rgba(0,255,255,0.2)';
      X.shadowBlur = 0;
      X.beginPath();
      X.moveTo(this.x, this.y + hitOffset);
      X.lineTo(this.x + this.w, this.y + hitOffset);
      X.stroke();
    }
    X.restore();
  }

  handleCollision(player) {
    if (this.gone || !player.collideRect(this.x, this.y, this.w, this.h)) return false;
    
    const overlapLeft = (player.x + player.radius) - this.x;
    const overlapRight = (this.x + this.w) - (player.x - player.radius);
    const overlapTop = (player.y + player.radius) - this.y;
    const overlapBottom = (this.y + this.h) - (player.y - player.radius);
    
    const minOverlapX = Math.min(overlapLeft, overlapRight);
    const minOverlapY = Math.min(overlapTop, overlapBottom);
    
    if (minOverlapX < minOverlapY) {
      if (overlapLeft < overlapRight) {
        player.x = this.x - player.radius;
      } else {
        player.x = this.x + this.w + player.radius;
      }
      player.vx = 0;
    } else {
      if (overlapTop < overlapBottom) {
        player.y = this.y - player.radius;
        if (player.gravDir === 1) { player.grounded = true; player.lastGroundY = player.y; }
      } else {
        player.y = this.y + this.h + player.radius;
        if (player.gravDir === -1) { player.grounded = true; player.lastGroundY = player.y; }
      }
      
      if (this.type === 'bouncy') {
        player.vy = -player.vy * 1.35;
        sfxBounce();
        screenShake = Math.max(screenShake, 5);
        this.hitAnim = 1;
        emit(player.x, player.y, 10, '#00ff80', 3.5, 0, { shape: 'circle' });
        player.squash = 0.45;
      } else {
        // Landing particles
        if (Math.abs(player.vy) > 2 * S) {
          const count = Math.min(8, Math.floor(Math.abs(player.vy) / S));
          emit(player.x, player.y + player.radius * player.gravDir, count, '#00ffff', 2, 0, { dir: player.gravDir > 0 ? 0 : Math.PI, spread: 2 });
          screenShake = Math.max(screenShake, Math.min(3, Math.abs(player.vy) / S * 0.5));
        }
        player.vy = 0;
        player.squash = 0.7 + Math.min(0.2, Math.abs(player.vy) * 0.02);
      }
      
      if (this.type === 'crumble' && !this.crumbling) {
        this.crumbling = true;
        this.crumbleTimer = 0.45;
        this.hitAnim = 0.5;
        emitSpark(player.x, this.y + this.h/2, '#c8a050', 3);
      }
    }
    return true;
  }
}

class Spike {
  constructor(x, y, w, h) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.pulse = Math.random() * Math.PI * 2;
  }
  update() { this.pulse += dt * 3; }
  draw() {
    const b = 0.5 + Math.sin(this.pulse) * 0.3;
    X.save();
    
    // Danger glow
    const grad = X.createRadialGradient(
      this.x + this.w/2, this.y + this.h/2, 0,
      this.x + this.w/2, this.y + this.h/2, Math.max(this.w, this.h)
    );
    grad.addColorStop(0, `rgba(255,0,100,${b * 0.15})`);
    grad.addColorStop(1, 'rgba(255,0,100,0)');
    X.fillStyle = grad;
    X.fillRect(this.x - this.w*0.5, this.y - this.h*0.5, this.w*2, this.h*2);
    
    X.fillStyle = `rgba(255,0,100,${b * 0.4})`;
    X.fillRect(this.x, this.y, this.w, this.h);
    X.strokeStyle = '#ff0064';
    X.lineWidth = 2 * S;
    X.shadowColor = '#ff0064';
    X.shadowBlur = 12 * S;
    X.strokeRect(this.x, this.y, this.w, this.h);
    
    // Danger triangles on top and bottom
    const numSpikes = Math.max(2, Math.floor(this.w / (8 * S)));
    X.fillStyle = `rgba(255,0,100,${b * 0.9})`;
    X.shadowBlur = 6 * S;
    for (let i = 0; i < numSpikes; i++) {
      const sx = this.x + (i + 0.5) * (this.w / numSpikes);
      X.beginPath();
      X.moveTo(sx - 3 * S, this.y);
      X.lineTo(sx + 3 * S, this.y);
      X.lineTo(sx, this.y - 7 * S);
      X.closePath();
      X.fill();
      X.beginPath();
      X.moveTo(sx - 3 * S, this.y + this.h);
      X.lineTo(sx + 3 * S, this.y + this.h);
      X.lineTo(sx, this.y + this.h + 7 * S);
      X.closePath();
      X.fill();
    }
    X.restore();
  }
  check(player) { return player.invuln <= 0 && player.collideRect(this.x, this.y, this.w, this.h); }
  nearMiss(player) { return player.nearMissRect(this.x, this.y, this.w, this.h, 8 * S); }
}

class Orb {
  constructor(x, y, color = '#4488ff') {
    this.x = x; this.y = y;
    this.radius = 9 * S;
    this.collected = false;
    this.pulse = Math.random() * Math.PI * 2;
    this.color = color;
    this.collectAnim = 0;
    this.bobOffset = Math.random() * Math.PI * 2;
  }
  update() { 
    this.pulse += dt * 4;
    if (this.collectAnim > 0) this.collectAnim -= dt * 3;
  }
  draw() {
    if (this.collected) return;
    const bob = Math.sin(this.pulse * 0.8 + this.bobOffset) * 3 * S;
    const s = this.radius * (1 + Math.sin(this.pulse) * 0.15);
    const dy = this.y + bob;
    
    X.save();
    // Outer glow
    const grad = X.createRadialGradient(this.x, dy, 0, this.x, dy, s * 2.5);
    grad.addColorStop(0, this.color + '44');
    grad.addColorStop(1, this.color + '00');
    X.fillStyle = grad;
    X.beginPath(); X.arc(this.x, dy, s * 2.5, 0, Math.PI * 2); X.fill();
    
    // Ring
    X.strokeStyle = this.color + '66';
    X.lineWidth = 1.5 * S;
    X.beginPath();
    X.arc(this.x, dy, s * 1.5 + Math.sin(this.pulse * 1.5) * 2 * S, 0, Math.PI * 2);
    X.stroke();
    
    // Core
    const coreGrad = X.createRadialGradient(this.x - s*0.3, dy - s*0.3, 0, this.x, dy, s);
    coreGrad.addColorStop(0, '#ffffff');
    coreGrad.addColorStop(0.3, this.color);
    coreGrad.addColorStop(1, this.color + 'aa');
    X.fillStyle = coreGrad;
    X.shadowColor = this.color;
    X.shadowBlur = 15 * S;
    X.beginPath(); X.arc(this.x, dy, s, 0, Math.PI * 2); X.fill();
    
    // Sparkle
    X.fillStyle = '#fff';
    X.shadowBlur = 0;
    X.globalAlpha = 0.7 + Math.sin(this.pulse * 2) * 0.3;
    X.beginPath(); X.arc(this.x - s * 0.3, dy - s * 0.3, s * 0.25, 0, Math.PI * 2); X.fill();
    X.restore();
  }
  check(player) {
    if (this.collected) return false;
    const bob = Math.sin(this.pulse * 0.8 + this.bobOffset) * 3 * S;
    if (player.collideCircle(this.x, this.y + bob, this.radius * 1.3)) {
      this.collected = true;
      // Big collection burst
      emit(this.x, this.y, 15, this.color, 3, 0, { shape: 'circle' });
      emit(this.x, this.y, 8, '#ffffff', 2, 0, { size: 2, shape: 'circle' });
      screenFlash = 0.15;
      screenFlashColor = this.color;
      return true;
    }
    return false;
  }
}

class Portal {
  constructor(x, y) {
    this.x = x; this.y = y;
    this.radius = 24 * S;
    this.pulse = 0;
    this.active = false;
    this.activateAnim = 0;
  }
  update() { 
    this.pulse += dt * 2.5;
    if (this.active && this.activateAnim < 1) {
      this.activateAnim = Math.min(1, this.activateAnim + dt * 2);
    }
  }
  draw() {
    const s = this.radius * (1 + Math.sin(this.pulse) * 0.08);
    const a = this.activateAnim;
    
    X.save();
    
    // Background swirl
    if (this.active) {
      for (let i = 0; i < 4; i++) {
        const angle = this.pulse * 1.5 + i * Math.PI / 2;
        const dist = s * 0.6;
        const px = this.x + Math.cos(angle) * dist;
        const py = this.y + Math.sin(angle) * dist;
        const grad = X.createRadialGradient(px, py, 0, px, py, 8 * S);
        grad.addColorStop(0, `rgba(255,215,0,${0.4 * a})`);
        grad.addColorStop(1, 'rgba(255,215,0,0)');
        X.fillStyle = grad;
        X.beginPath(); X.arc(px, py, 8 * S, 0, Math.PI * 2); X.fill();
      }
    }
    
    // Rings
    for (let i = 3; i > 0; i--) {
      const ringA = this.active ? 0.4 * a / i : 0.15 / i;
      X.strokeStyle = this.active ? `rgba(255,215,0,${ringA})` : `rgba(100,100,100,${ringA})`;
      X.lineWidth = (this.active ? 3 : 2) * S;
      if (this.active) { X.shadowColor = '#ffd700'; X.shadowBlur = 12 * S; }
      X.beginPath();
      X.arc(this.x, this.y, s * (1 + i * 0.22) + Math.sin(this.pulse + i) * 3 * S, 0, Math.PI * 2);
      X.stroke();
    }
    
    // Core
    const grad = X.createRadialGradient(this.x, this.y, 0, this.x, this.y, s);
    if (this.active) {
      grad.addColorStop(0, `rgba(255,230,100,${0.9 * a})`);
      grad.addColorStop(0.5, `rgba(255,215,0,${0.4 * a})`);
      grad.addColorStop(1, 'rgba(255,215,0,0)');
    } else {
      grad.addColorStop(0, 'rgba(100,100,100,0.3)');
      grad.addColorStop(1, 'rgba(100,100,100,0)');
    }
    X.fillStyle = grad;
    X.beginPath(); X.arc(this.x, this.y, s, 0, Math.PI * 2); X.fill();
    
    // Spinning particles
    if (this.active) {
      X.shadowColor = '#ffd700'; X.shadowBlur = 8 * S;
      for (let i = 0; i < 8; i++) {
        const angle = this.pulse * 2.5 + i * Math.PI / 4;
        const r = s * (0.5 + Math.sin(this.pulse + i) * 0.2);
        const px = this.x + Math.cos(angle) * r;
        const py = this.y + Math.sin(angle) * r;
        X.fillStyle = '#ffd700';
        X.globalAlpha = 0.8 * a;
        X.beginPath(); X.arc(px, py, 2.5 * S, 0, Math.PI * 2); X.fill();
      }
      
      // "ENTER" hint
      if (a >= 1) {
        X.globalAlpha = 0.5 + Math.sin(gt * 3) * 0.3;
        X.fillStyle = '#ffd700';
        X.font = `bold ${10 * S}px sans-serif`;
        X.textAlign = 'center';
        X.shadowBlur = 4 * S;
        X.fillText('‚óè', this.x, this.y + this.radius + 18 * S);
      }
    } else {
      // Lock icon hint
      X.globalAlpha = 0.4;
      X.fillStyle = '#666';
      X.font = `${12 * S}px sans-serif`;
      X.textAlign = 'center';
      X.fillText('üîí', this.x, this.y + 4 * S);
    }
    
    X.restore();
  }
  check(player) { return this.active && player.collideCircle(this.x, this.y, this.radius); }
}

class GravityWell {
  constructor(x, y, strength, radius) {
    this.x = x; this.y = y;
    this.strength = strength * S;
    this.radius = radius * S;
    this.pulse = 0;
  }
  update() { this.pulse += dt * 2; }
  draw() {
    X.save();
    const grad = X.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
    grad.addColorStop(0, 'rgba(138,43,226,0.3)');
    grad.addColorStop(0.5, 'rgba(138,43,226,0.1)');
    grad.addColorStop(1, 'rgba(138,43,226,0)');
    X.fillStyle = grad;
    X.beginPath(); X.arc(this.x, this.y, this.radius, 0, Math.PI * 2); X.fill();
    
    // Animated spiral
    X.strokeStyle = `rgba(180,100,255,${0.25 + Math.sin(this.pulse) * 0.15})`;
    X.lineWidth = 1.5 * S;
    for (let i = 0; i < 3; i++) {
      X.beginPath();
      for (let a = 0; a < Math.PI * 4; a += 0.1) {
        const r = (a / (Math.PI * 4)) * this.radius * 0.8;
        const px = this.x + Math.cos(a + this.pulse + i * 2.1) * r;
        const py = this.y + Math.sin(a + this.pulse + i * 2.1) * r;
        if (a === 0) X.moveTo(px, py); else X.lineTo(px, py);
      }
      X.stroke();
    }
    
    // Center pulse
    X.fillStyle = `rgba(180,100,255,${0.3 + Math.sin(this.pulse * 2) * 0.2})`;
    X.shadowColor = '#b464ff';
    X.shadowBlur = 10 * S;
    X.beginPath();
    X.arc(this.x, this.y, 4 * S, 0, Math.PI * 2);
    X.fill();
    
    X.restore();
  }
  applyForce(player) {
    const dx = this.x - player.x, dy = this.y - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < this.radius && dist > 0) {
      const force = this.strength * (1 - dist / this.radius);
      player.vx += (dx / dist) * force;
      player.vy += (dy / dist) * force;
      // Visual pull particles
      if (Math.random() > 0.85) {
        emitTrail(
          player.x + (Math.random()-0.5) * 10 * S,
          player.y + (Math.random()-0.5) * 10 * S,
          '#b464ff'
        );
      }
    }
  }
}

class WindZone {
  constructor(x, y, w, h, dirX, dirY, strength) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.dirX = dirX; this.dirY = dirY;
    this.strength = strength * S;
    this.pulse = Math.random() * Math.PI * 2;
    this.particles = [];
  }
  update() {
    this.pulse += dt * 2;
    // spawn wind particles
    if (Math.random() > 0.7) {
      this.particles.push({
        x: this.dirX >= 0 ? this.x : this.x + this.w,
        y: this.y + Math.random() * this.h,
        life: 1
      });
    }
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      const ld60 = dt * 60;
      p.x += this.dirX * 3 * S * ld60;
      p.y += this.dirY * 3 * S * ld60;
      p.life -= 0.025 * ld60;
      if (p.life <= 0 || p.x < this.x - 10 || p.x > this.x + this.w + 10 ||
          p.y < this.y - 10 || p.y > this.y + this.h + 10) {
        this.particles.splice(i, 1);
      }
    }
    if (this.particles.length > 40) this.particles.splice(0, this.particles.length - 40);
  }
  draw() {
    X.save();
    // Zone background
    const alpha = 0.04 + Math.sin(this.pulse) * 0.02;
    X.fillStyle = `rgba(100,200,255,${alpha})`;
    X.fillRect(this.x, this.y, this.w, this.h);
    // Border lines (dashed)
    X.strokeStyle = 'rgba(100,200,255,0.15)';
    X.lineWidth = 1 * S;
    X.setLineDash([4 * S, 4 * S]);
    X.strokeRect(this.x, this.y, this.w, this.h);
    X.setLineDash([]);
    // Wind streaks
    for (const p of this.particles) {
      X.globalAlpha = p.life * 0.3;
      X.strokeStyle = '#88ccff';
      X.lineWidth = 1 * S;
      X.beginPath();
      X.moveTo(p.x, p.y);
      X.lineTo(p.x - this.dirX * 12 * S, p.y - this.dirY * 12 * S);
      X.stroke();
    }
    // Arrow indicator
    X.globalAlpha = 0.2 + Math.sin(this.pulse * 1.5) * 0.1;
    X.fillStyle = '#88ccff';
    const cx = this.x + this.w / 2;
    const cy = this.y + this.h / 2;
    const arrowLen = 10 * S;
    const ax = cx + this.dirX * arrowLen;
    const ay = cy + this.dirY * arrowLen;
    X.beginPath();
    X.moveTo(ax, ay);
    X.lineTo(ax - this.dirX * 8 * S - this.dirY * 4 * S, ay - this.dirY * 8 * S + this.dirX * 4 * S);
    X.lineTo(ax - this.dirX * 8 * S + this.dirY * 4 * S, ay - this.dirY * 8 * S - this.dirX * 4 * S);
    X.closePath();
    X.fill();
    X.restore();
  }
  applyForce(player) {
    if (player.x > this.x && player.x < this.x + this.w &&
        player.y > this.y && player.y < this.y + this.h) {
      player.vx += this.dirX * this.strength * 0.15;
      player.vy += this.dirY * this.strength * 0.15;
    }
  }
}

// ============================================================
// LASER BEAM ‚Äî toggles on/off on a timer
// ============================================================
class LaserBeam {
  constructor(x, y, w, h, onTime, offTime, startDelay) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.onTime = onTime || 1.5;
    this.offTime = offTime || 1.0;
    this.startDelay = startDelay || 0;
    this.timer = -this.startDelay;
    this.active = false;
    this.warmup = 0; // 0-1 warmup before activating
    this.pulse = Math.random() * Math.PI * 2;
    this.particles = [];
  }
  update() {
    this.pulse += dt * 6;
    this.timer += dt;
    const cycle = this.onTime + this.offTime;
    const phase = ((this.timer % cycle) + cycle) % cycle;
    const wasActive = this.active;
    if (phase < this.onTime) {
      this.active = true;
      this.warmup = Math.min(1, this.warmup + dt * 5);
    } else {
      this.active = false;
      this.warmup = Math.max(0, this.warmup - dt * 8);
    }
    // Warning flash before activation
    if (!wasActive && this.active) {
      screenShake = Math.max(screenShake, 2);
    }
    // Spawn beam particles
    if (this.active && Math.random() > 0.5) {
      this.particles.push({
        x: this.x + Math.random() * this.w,
        y: this.y + Math.random() * this.h,
        vx: (Math.random() - 0.5) * 2 * S,
        vy: (Math.random() - 0.5) * 2 * S,
        life: 0.5 + Math.random() * 0.3
      });
    }
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      const d60 = dt * 60; p.x += p.vx * d60; p.y += p.vy * d60;
      p.life -= dt * 2;
      if (p.life <= 0) this.particles.splice(i, 1);
    }
    if (this.particles.length > 20) this.particles.splice(0, this.particles.length - 20);
  }
  draw() {
    X.save();
    const alpha = this.warmup;
    if (alpha <= 0.01) {
      // Draw inactive indicator line
      X.strokeStyle = 'rgba(255,0,0,0.1)';
      X.lineWidth = 1 * S;
      X.setLineDash([3 * S, 3 * S]);
      X.beginPath();
      if (this.w > this.h) {
        X.moveTo(this.x, this.y + this.h / 2);
        X.lineTo(this.x + this.w, this.y + this.h / 2);
      } else {
        X.moveTo(this.x + this.w / 2, this.y);
        X.lineTo(this.x + this.w / 2, this.y + this.h);
      }
      X.stroke();
      X.setLineDash([]);
      // Warning dots at emitter positions
      const warnAlpha = 0.3 + Math.sin(this.pulse * 2) * 0.2;
      X.fillStyle = `rgba(255,80,80,${warnAlpha})`;
      X.beginPath();
      X.arc(this.x, this.y + this.h / 2, 3 * S, 0, Math.PI * 2);
      X.fill();
      X.beginPath();
      X.arc(this.x + this.w, this.y + this.h / 2, 3 * S, 0, Math.PI * 2);
      X.fill();
      X.restore();
      return;
    }
    // Warning flash (warmup < 1)
    if (alpha < 1) {
      const flash = Math.sin(this.pulse * 8) > 0 ? alpha : alpha * 0.3;
      X.fillStyle = `rgba(255,50,50,${flash * 0.3})`;
      X.fillRect(this.x, this.y, this.w, this.h);
      X.strokeStyle = `rgba(255,50,50,${flash * 0.6})`;
      X.lineWidth = 1 * S;
      X.strokeRect(this.x, this.y, this.w, this.h);
    }
    // Main beam
    const beamGrad = X.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
    beamGrad.addColorStop(0, `rgba(255,20,20,${alpha * 0.1})`);
    beamGrad.addColorStop(0.3, `rgba(255,60,60,${alpha * 0.6})`);
    beamGrad.addColorStop(0.5, `rgba(255,200,200,${alpha * 0.9})`);
    beamGrad.addColorStop(0.7, `rgba(255,60,60,${alpha * 0.6})`);
    beamGrad.addColorStop(1, `rgba(255,20,20,${alpha * 0.1})`);
    X.fillStyle = beamGrad;
    X.shadowColor = '#ff0000';
    X.shadowBlur = 15 * S * alpha;
    X.fillRect(this.x, this.y, this.w, this.h);
    // Core bright line
    X.fillStyle = `rgba(255,255,255,${alpha * 0.7})`;
    X.shadowBlur = 8 * S * alpha;
    const coreH = Math.max(1, this.h * 0.15);
    X.fillRect(this.x, this.y + this.h / 2 - coreH / 2, this.w, coreH);
    // Emitter glow at endpoints
    for (const ex of [this.x, this.x + this.w]) {
      const eg = X.createRadialGradient(ex, this.y + this.h / 2, 0, ex, this.y + this.h / 2, 10 * S);
      eg.addColorStop(0, `rgba(255,100,100,${alpha * 0.8})`);
      eg.addColorStop(1, `rgba(255,0,0,0)`);
      X.fillStyle = eg;
      X.shadowBlur = 0;
      X.beginPath();
      X.arc(ex, this.y + this.h / 2, 10 * S, 0, Math.PI * 2);
      X.fill();
    }
    // Beam particles
    for (const p of this.particles) {
      X.globalAlpha = p.life * alpha;
      X.fillStyle = '#ff8888';
      X.beginPath();
      X.arc(p.x, p.y, 1.5 * S, 0, Math.PI * 2);
      X.fill();
    }
    X.restore();
  }
  check(player) {
    return this.active && this.warmup > 0.8 && player.invuln <= 0 &&
           player.collideRect(this.x, this.y, this.w, this.h);
  }
  nearMiss(player) {
    return this.active && this.warmup > 0.5 &&
           player.nearMissRect(this.x, this.y, this.w, this.h, 12 * S);
  }
}

// ============================================================
// TELEPORT PORTAL PAIR ‚Äî teleports player between two points
// ============================================================
class TeleportPortal {
  constructor(x1, y1, x2, y2, color1, color2) {
    this.x1 = x1; this.y1 = y1;
    this.x2 = x2; this.y2 = y2;
    this.radius = 16 * S;
    this.color1 = color1 || '#ff66ff';
    this.color2 = color2 || '#66ffff';
    this.pulse = 0;
    this.cooldown = 0;
    this.teleportAnim = 0;
    this.lastTeleportSide = 0; // 1 = entered portal 1, 2 = entered portal 2
    this.particles1 = [];
    this.particles2 = [];
  }
  update() {
    this.pulse += dt * 3;
    if (this.cooldown > 0) this.cooldown -= dt;
    if (this.teleportAnim > 0) this.teleportAnim -= dt * 3;
    // Ambient particles around each portal
    if (Math.random() > 0.7) {
      const a = Math.random() * Math.PI * 2;
      const r = this.radius * (0.8 + Math.random() * 0.5);
      this.particles1.push({
        x: this.x1 + Math.cos(a) * r, y: this.y1 + Math.sin(a) * r,
        tx: this.x1, ty: this.y1, life: 1
      });
      this.particles2.push({
        x: this.x2 + Math.cos(a + Math.PI) * r, y: this.y2 + Math.sin(a + Math.PI) * r,
        tx: this.x2, ty: this.y2, life: 1
      });
    }
    const updateP = (arr) => {
      for (let i = arr.length - 1; i >= 0; i--) {
        const p = arr[i];
        const oLerp = 1 - Math.pow(0.95, dt * 60);
        p.x += (p.tx - p.x) * oLerp;
        p.y += (p.ty - p.y) * oLerp;
        p.life -= dt * 1.5;
        if (p.life <= 0) arr.splice(i, 1);
      }
      if (arr.length > 15) arr.splice(0, arr.length - 15);
    };
    updateP(this.particles1);
    updateP(this.particles2);
  }
  drawPortal(x, y, color, particleArr) {
    const s = this.radius * (1 + Math.sin(this.pulse) * 0.1);
    // Outer ring
    X.save();
    X.strokeStyle = color;
    X.lineWidth = 2.5 * S;
    X.shadowColor = color;
    X.shadowBlur = 12 * S;
    X.beginPath();
    X.arc(x, y, s, 0, Math.PI * 2);
    X.stroke();
    // Spinning inner spiral
    X.lineWidth = 1.5 * S;
    X.globalAlpha = 0.6;
    for (let i = 0; i < 3; i++) {
      const ang = this.pulse * 2 + i * (Math.PI * 2 / 3);
      const r = s * 0.6;
      X.beginPath();
      X.arc(x + Math.cos(ang) * r * 0.3, y + Math.sin(ang) * r * 0.3,
            r * 0.4, ang, ang + Math.PI);
      X.stroke();
    }
    // Inner glow
    const grad = X.createRadialGradient(x, y, 0, x, y, s * 0.8);
    grad.addColorStop(0, color + '44');
    grad.addColorStop(0.6, color + '11');
    grad.addColorStop(1, color + '00');
    X.fillStyle = grad;
    X.globalAlpha = 0.8;
    X.shadowBlur = 0;
    X.beginPath();
    X.arc(x, y, s * 0.8, 0, Math.PI * 2);
    X.fill();
    // Center dot
    X.fillStyle = '#fff';
    X.globalAlpha = 0.6 + Math.sin(this.pulse * 2) * 0.3;
    X.beginPath();
    X.arc(x, y, 3 * S, 0, Math.PI * 2);
    X.fill();
    // Particles
    for (const p of particleArr) {
      X.globalAlpha = p.life * 0.5;
      X.fillStyle = color;
      X.beginPath();
      X.arc(p.x, p.y, 2 * S, 0, Math.PI * 2);
      X.fill();
    }
    // Connection line hint
    X.restore();
  }
  draw() {
    // Connection line between portals (subtle)
    X.save();
    X.strokeStyle = 'rgba(200,100,255,0.06)';
    X.lineWidth = 1 * S;
    X.setLineDash([4 * S, 8 * S]);
    X.beginPath();
    X.moveTo(this.x1, this.y1);
    X.lineTo(this.x2, this.y2);
    X.stroke();
    X.setLineDash([]);
    X.restore();
    // Draw both portals
    this.drawPortal(this.x1, this.y1, this.color1, this.particles1);
    this.drawPortal(this.x2, this.y2, this.color2, this.particles2);
    // Teleport flash effect
    if (this.teleportAnim > 0) {
      const fa = this.teleportAnim;
      X.save();
      X.globalAlpha = fa * 0.3;
      X.fillStyle = '#fff';
      X.beginPath();
      const tx = this.lastTeleportSide === 1 ? this.x2 : this.x1;
      const ty = this.lastTeleportSide === 1 ? this.y2 : this.y1;
      X.arc(tx, ty, this.radius * 2 * (1 - fa), 0, Math.PI * 2);
      X.fill();
      X.restore();
    }
  }
  check(player) {
    if (this.cooldown > 0) return;
    const d1 = Math.sqrt((player.x - this.x1) ** 2 + (player.y - this.y1) ** 2);
    const d2 = Math.sqrt((player.x - this.x2) ** 2 + (player.y - this.y2) ** 2);
    if (d1 < this.radius * 0.9) {
      // Teleport to portal 2
      player.x = this.x2;
      player.y = this.y2;
      this.cooldown = 0.8;
      this.teleportAnim = 1;
      this.lastTeleportSide = 1;
      this._doTeleportFX(this.x1, this.y1, this.color1, this.x2, this.y2, this.color2);
    } else if (d2 < this.radius * 0.9) {
      // Teleport to portal 1
      player.x = this.x1;
      player.y = this.y1;
      this.cooldown = 0.8;
      this.teleportAnim = 1;
      this.lastTeleportSide = 2;
      this._doTeleportFX(this.x2, this.y2, this.color2, this.x1, this.y1, this.color1);
    }
  }
  _doTeleportFX(fromX, fromY, fromColor, toX, toY, toColor) {
    // Entry burst
    emit(fromX, fromY, 12, fromColor, 3, 0, { shape: 'circle', size: 2 });
    // Exit burst
    emit(toX, toY, 15, toColor, 4, 0, { shape: 'circle', size: 3 });
    emit(toX, toY, 8, '#ffffff', 2, 0, { shape: 'circle', size: 1.5 });
    screenShake = Math.max(screenShake, 6);
    screenFlash = 0.15;
    screenFlashColor = toColor;
    // Sound
    tone(600, 0.08, 'sine', 0.12);
    tone(900, 0.06, 'sine', 0.1, 0.03);
    tone(1200, 0.1, 'sine', 0.08, 0.06);
  }
}

// ============================================================
// MOVING PLATFORM (enhanced) ‚Äî smooth horizontal/vertical paths
// ============================================================
class MovingPlatformHV {
  constructor(x, y, w, h, dir, range, speed) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.ox = x; this.oy = y;
    this.dir = dir; // 'h' or 'v'
    this.range = range;
    this.speed = speed || 1;
    this.timer = 0;
    this.prevX = x; this.prevY = y;
  }
  update() {
    this.prevX = this.x;
    this.prevY = this.y;
    this.timer += dt * this.speed;
    if (this.dir === 'h') {
      this.x = this.ox + Math.sin(this.timer) * this.range;
    } else {
      this.y = this.oy + Math.sin(this.timer) * this.range;
    }
  }
  draw() {
    X.save();
    // Track line
    X.strokeStyle = 'rgba(100,200,255,0.1)';
    X.lineWidth = 1 * S;
    X.setLineDash([3 * S, 5 * S]);
    X.beginPath();
    if (this.dir === 'h') {
      X.moveTo(this.ox - this.range, this.y + this.h / 2);
      X.lineTo(this.ox + this.range + this.w, this.y + this.h / 2);
    } else {
      X.moveTo(this.x + this.w / 2, this.oy - this.range);
      X.lineTo(this.x + this.w / 2, this.oy + this.range + this.h);
    }
    X.stroke();
    X.setLineDash([]);
    // Platform body
    const grad = X.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
    grad.addColorStop(0, 'rgba(80,160,255,0.5)');
    grad.addColorStop(1, 'rgba(40,100,200,0.3)');
    X.fillStyle = grad;
    X.fillRect(this.x, this.y, this.w, this.h);
    X.strokeStyle = '#44aaff';
    X.lineWidth = 1.5 * S;
    X.shadowColor = '#44aaff';
    X.shadowBlur = 6 * S;
    X.strokeRect(this.x, this.y, this.w, this.h);
    // Movement arrows
    X.shadowBlur = 0;
    X.fillStyle = 'rgba(100,180,255,0.3)';
    const cx = this.x + this.w / 2;
    const cy = this.y + this.h / 2;
    if (this.dir === 'h') {
      // Left/right arrows
      for (const sign of [-1, 1]) {
        const ax = cx + sign * (this.w / 2 + 6 * S);
        X.beginPath();
        X.moveTo(ax + sign * 4 * S, cy);
        X.lineTo(ax, cy - 3 * S);
        X.lineTo(ax, cy + 3 * S);
        X.closePath();
        X.fill();
      }
    } else {
      for (const sign of [-1, 1]) {
        const ay = cy + sign * (this.h / 2 + 6 * S);
        X.beginPath();
        X.moveTo(cx, ay + sign * 4 * S);
        X.lineTo(cx - 3 * S, ay);
        X.lineTo(cx + 3 * S, ay);
        X.closePath();
        X.fill();
      }
    }
    X.restore();
  }
  handleCollision(player) {
    if (!player.collideRect(this.x, this.y, this.w, this.h)) return false;
    const overlapLeft = (player.x + player.radius) - this.x;
    const overlapRight = (this.x + this.w) - (player.x - player.radius);
    const overlapTop = (player.y + player.radius) - this.y;
    const overlapBottom = (this.y + this.h) - (player.y - player.radius);
    const minOverlapX = Math.min(overlapLeft, overlapRight);
    const minOverlapY = Math.min(overlapTop, overlapBottom);
    if (minOverlapX < minOverlapY) {
      if (overlapLeft < overlapRight) player.x = this.x - player.radius;
      else player.x = this.x + this.w + player.radius;
      player.vx = 0;
    } else {
      if (overlapTop < overlapBottom) {
        player.y = this.y - player.radius;
        if (player.gravDir === 1) { player.grounded = true; player.lastGroundY = player.y; }
      } else {
        player.y = this.y + this.h + player.radius;
        if (player.gravDir === -1) { player.grounded = true; player.lastGroundY = player.y; }
      }
      player.vy = 0;
      // Carry player with platform
      player.x += (this.x - this.prevX);
      player.y += (this.y - this.prevY);
      player.squash = 0.85;
      if (Math.abs(this.x - this.prevX) + Math.abs(this.y - this.prevY) > 0.1) {
        if (Math.random() > 0.85) emitTrail(player.x, player.y + player.radius * player.gravDir, '#44aaff');
      }
    }
    return true;
  }
}

// ============================================================
// LEVEL EDITOR MODE
// ============================================================
let editorMode = false;
let editorGrid = { cols: 20, rows: 14 };
let editorCellW = 0, editorCellH = 0;
let editorTool = 'platform'; // platform, spike, orb, laser, portal_a, portal_b, spawn, goal, erase, moving_h, moving_v
let editorLevel = { platforms: [], spikes: [], orbs: [], lasers: [], teleports: [], movingPlatforms: [], spawn: null, goal: null };
let editorSavedLevels = [];
let editorPortalA = null; // temporary first portal point
let editorSelectedSave = -1;
let editorMessage = '';
let editorMessageTimer = 0;
let editorTestMode = false;
let editorMenuOpen = false;
let editorToolbar = [];
let editorScrollY = 0;

try { const el = localStorage.getItem('gflip3_editor'); if (el) editorSavedLevels = JSON.parse(el); } catch(e) {}
function saveEditorLevels() { try { localStorage.setItem('gflip3_editor', JSON.stringify(editorSavedLevels)); } catch(e) {} }

function editorShowMsg(msg) { editorMessage = msg; editorMessageTimer = 2.5; }

function editorInit() {
  editorMode = true;
  screen = 'editor';
  editorCellW = W / editorGrid.cols;
  editorCellH = (H - 80 * S) / editorGrid.rows; // leave room for toolbar
  editorLevel = { platforms: [], spikes: [], orbs: [], lasers: [], teleports: [], movingPlatforms: [], spawn: null, goal: null };
  editorTool = 'platform';
  editorPortalA = null;
  editorSelectedSave = -1;
  editorTestMode = false;
  editorMenuOpen = false;
  gs.btns = {};
}

function editorGridToWorld(col, row) {
  return { x: col * editorCellW, y: 80 * S + row * editorCellH };
}

function editorWorldToGrid(wx, wy) {
  const col = Math.floor(wx / editorCellW);
  const row = Math.floor((wy - 80 * S) / editorCellH);
  return { col: Math.max(0, Math.min(editorGrid.cols - 1, col)), row: Math.max(0, Math.min(editorGrid.rows - 1, row)) };
}

function editorPlaceTile(col, row) {
  const key = `${col},${row}`;
  // Remove existing item at this position first for non-additive tools
  if (editorTool === 'erase') {
    editorLevel.platforms = editorLevel.platforms.filter(p => p.key !== key);
    editorLevel.spikes = editorLevel.spikes.filter(p => p.key !== key);
    editorLevel.orbs = editorLevel.orbs.filter(p => p.key !== key);
    editorLevel.lasers = editorLevel.lasers.filter(p => p.col === col && p.row === row ? false : true);
    editorLevel.movingPlatforms = editorLevel.movingPlatforms.filter(p => p.key !== key);
    if (editorLevel.spawn && editorLevel.spawn.key === key) editorLevel.spawn = null;
    if (editorLevel.goal && editorLevel.goal.key === key) editorLevel.goal = null;
    // Remove teleports at this position
    editorLevel.teleports = editorLevel.teleports.filter(t => {
      return !(t.col1 === col && t.row1 === row) && !(t.col2 === col && t.row2 === row);
    });
    return;
  }
  if (editorTool === 'platform') {
    if (!editorLevel.platforms.find(p => p.key === key)) {
      editorLevel.platforms.push({ col, row, key });
    }
  } else if (editorTool === 'spike') {
    if (!editorLevel.spikes.find(p => p.key === key)) {
      editorLevel.spikes.push({ col, row, key });
    }
  } else if (editorTool === 'orb') {
    if (!editorLevel.orbs.find(p => p.key === key)) {
      editorLevel.orbs.push({ col, row, key });
    }
  } else if (editorTool === 'laser') {
    // Place a horizontal laser spanning the row
    if (!editorLevel.lasers.find(p => p.col === col && p.row === row)) {
      editorLevel.lasers.push({ col, row, w: 3, onTime: 1.5, offTime: 1.0 });
    }
  } else if (editorTool === 'moving_h' || editorTool === 'moving_v') {
    if (!editorLevel.movingPlatforms.find(p => p.key === key)) {
      editorLevel.movingPlatforms.push({ col, row, key, dir: editorTool === 'moving_h' ? 'h' : 'v' });
    }
  } else if (editorTool === 'portal_a') {
    editorPortalA = { col, row };
    editorTool = 'portal_b';
    editorShowMsg('Now tap to place Portal B');
  } else if (editorTool === 'portal_b') {
    if (editorPortalA) {
      editorLevel.teleports.push({
        col1: editorPortalA.col, row1: editorPortalA.row,
        col2: col, row2: row
      });
      editorPortalA = null;
      editorTool = 'portal_a';
      editorShowMsg('Portal pair placed!');
    }
  } else if (editorTool === 'spawn') {
    editorLevel.spawn = { col, row, key };
  } else if (editorTool === 'goal') {
    editorLevel.goal = { col, row, key };
  }
}

function editorBuildLevel() {
  // Convert editor grid data to a level data object
  const cellWFrac = 1 / editorGrid.cols;
  const cellHFrac = 1 / editorGrid.rows;
  const topOffset = 80 * S / H;
  const platforms = [];
  const spikes = [];
  const orbs = [];
  const lasers = [];
  const teleports = [];
  const movingPlatforms = [];

  // Add boundary walls (floor/ceiling)
  platforms.push([0, 0.0, 1.0, 0.015]);
  platforms.push([0, 0.985, 1.0, 0.015]);

  for (const p of editorLevel.platforms) {
    platforms.push([p.col * cellWFrac, topOffset + p.row * cellHFrac * (1 - topOffset * 2), cellWFrac * 1.0, cellHFrac * (1 - topOffset * 2) * 0.8]);
  }
  for (const s of editorLevel.spikes) {
    spikes.push([s.col * cellWFrac, topOffset + s.row * cellHFrac * (1 - topOffset * 2), cellWFrac, cellHFrac * (1 - topOffset * 2) * 0.6]);
  }
  for (const o of editorLevel.orbs) {
    orbs.push([o.col * cellWFrac + cellWFrac / 2, topOffset + o.row * cellHFrac * (1 - topOffset * 2) + cellHFrac * (1 - topOffset * 2) / 2]);
  }

  const spawn = editorLevel.spawn
    ? [editorLevel.spawn.col * cellWFrac + cellWFrac / 2, topOffset + editorLevel.spawn.row * cellHFrac * (1 - topOffset * 2)]
    : [0.05, 0.3];
  const goal = editorLevel.goal
    ? [editorLevel.goal.col * cellWFrac + cellWFrac / 2, topOffset + editorLevel.goal.row * cellHFrac * (1 - topOffset * 2)]
    : [0.9, 0.7];

  const levelData = {
    name: 'Custom Level', stars: [30, 20, 12],
    spawn, goal, width: 1.0,
    platforms, spikes, orbs,
    wells: [], winds: [],
    customLasers: editorLevel.lasers.map(l => ({
      col: l.col, row: l.row, w: l.w || 3,
      onTime: l.onTime || 1.5, offTime: l.offTime || 1.0
    })),
    customTeleports: editorLevel.teleports.map(t => ({
      col1: t.col1, row1: t.row1, col2: t.col2, row2: t.row2
    })),
    customMoving: editorLevel.movingPlatforms.map(m => ({
      col: m.col, row: m.row, dir: m.dir
    }))
  };
  return levelData;
}

function editorSave() {
  if (!editorLevel.spawn || !editorLevel.goal) {
    editorShowMsg('Place spawn & goal first!');
    return;
  }
  if (editorLevel.orbs.length === 0) {
    editorShowMsg('Place at least 1 orb!');
    return;
  }
  const data = {
    grid: JSON.parse(JSON.stringify(editorLevel)),
    date: Date.now(),
    name: 'Custom ' + (editorSavedLevels.length + 1)
  };
  editorSavedLevels.push(data);
  saveEditorLevels();
  editorShowMsg('Level saved! (' + editorSavedLevels.length + ')');
}

function editorLoad(index) {
  if (index < 0 || index >= editorSavedLevels.length) return;
  const data = editorSavedLevels[index];
  editorLevel = JSON.parse(JSON.stringify(data.grid));
  editorSelectedSave = index;
  editorShowMsg('Level loaded!');
  editorMenuOpen = false;
}

function editorDelete(index) {
  if (index < 0 || index >= editorSavedLevels.length) return;
  editorSavedLevels.splice(index, 1);
  saveEditorLevels();
  editorShowMsg('Level deleted');
}

function editorPlay() {
  if (!editorLevel.spawn || !editorLevel.goal) {
    editorShowMsg('Place spawn & goal first!');
    return;
  }
  if (editorLevel.orbs.length === 0) {
    editorShowMsg('Place at least 1 orb!');
    return;
  }
  editorTestMode = true;
  const levelData = editorBuildLevel();
  startEditorLevel(levelData);
}

function startEditorLevel(levelData) {
  lvl = 0;
  const L = levelData;
  const p = new Player(W * L.spawn[0], H * L.spawn[1]);
  p.invuln = 0.5;
  const platforms = L.platforms.map(d => {
    const pl = new Platform(W * d[0], H * d[1], W * d[2], H * d[3], d[4] || 'solid');
    if (d[4] === 'moving') {
      pl.type = 'moving';
      pl.moveRangeX = (d[5] || 0) * W;
      pl.moveRangeY = (d[6] || 0) * H;
      pl.moveSpeed = d[7] || 1;
    }
    return pl;
  });
  const spikes = L.spikes.map(d => new Spike(W * d[0], H * d[1], W * d[2], H * d[3]));
  const orbs = L.orbs.map(d => new Orb(W * d[0], H * d[1]));
  const wells = [];
  const winds = [];
  const portal = new Portal(W * L.goal[0], H * L.goal[1]);

  // Custom lasers
  const customLasers = [];
  if (L.customLasers) {
    const cellWFrac = 1 / editorGrid.cols;
    const cellHFrac = 1 / editorGrid.rows;
    const topOffset = 80 * S / H;
    for (const cl of L.customLasers) {
      const lx = W * cl.col * cellWFrac;
      const ly = H * (topOffset + cl.row * cellHFrac * (1 - topOffset * 2));
      const lw = W * cl.w * cellWFrac;
      const lh = H * cellHFrac * (1 - topOffset * 2) * 0.3;
      customLasers.push(new LaserBeam(lx, ly, lw, lh, cl.onTime, cl.offTime, Math.random() * cl.onTime));
    }
  }

  // Custom teleports
  const customTeleports = [];
  if (L.customTeleports) {
    const cellWFrac = 1 / editorGrid.cols;
    const cellHFrac = 1 / editorGrid.rows;
    const topOffset = 80 * S / H;
    for (const ct of L.customTeleports) {
      const x1 = W * (ct.col1 * cellWFrac + cellWFrac / 2);
      const y1 = H * (topOffset + ct.row1 * cellHFrac * (1 - topOffset * 2));
      const x2 = W * (ct.col2 * cellWFrac + cellWFrac / 2);
      const y2 = H * (topOffset + ct.row2 * cellHFrac * (1 - topOffset * 2));
      customTeleports.push(new TeleportPortal(x1, y1, x2, y2));
    }
  }

  // Custom moving platforms
  const customMovingPlatforms = [];
  if (L.customMoving) {
    const cellWFrac = 1 / editorGrid.cols;
    const cellHFrac = 1 / editorGrid.rows;
    const topOffset = 80 * S / H;
    for (const cm of L.customMoving) {
      const mx = W * cm.col * cellWFrac;
      const my = H * (topOffset + cm.row * cellHFrac * (1 - topOffset * 2));
      const mw = W * cellWFrac;
      const mh = H * cellHFrac * (1 - topOffset * 2) * 0.6;
      const range = (cm.dir === 'h' ? W : H) * 0.08;
      customMovingPlatforms.push(new MovingPlatformHV(mx, my, mw, mh, cm.dir, range, 1.5));
    }
  }

  sessionNearMisses = 0;
  gs = {
    player: p, platforms, spikes, orbs, portal, wells, winds,
    customLasers, customTeleports, customMovingPlatforms,
    time: 0, orbsCollected: 0, totalOrbs: orbs.length,
    dead: false, won: false, deathCount: 0, btns: {},
    levelStartTime: performance.now(),
    isDaily: false, isEditor: true
  };
  combo = 0; comboTimer = 0;
  particles = []; floatingTexts = []; speedLines = [];
  screen = 'game';
  screenShake = 0; screenFlash = 0;
  deathTimer = 0; nearMissTimer = 0; slowMo = 0;
  cameraZoom = 1; cameraZoomTarget = 1;
  currentAccent = '#00ffff';
  ensureAudio(); startMusic();
}

function drawEditor() {
  // Grid background
  X.save();
  X.fillStyle = 'rgba(0,0,0,0.3)';
  X.fillRect(0, 80 * S, W, H - 80 * S);

  // Grid lines
  X.strokeStyle = 'rgba(0,255,255,0.08)';
  X.lineWidth = 0.5 * S;
  for (let c = 0; c <= editorGrid.cols; c++) {
    X.beginPath();
    X.moveTo(c * editorCellW, 80 * S);
    X.lineTo(c * editorCellW, H);
    X.stroke();
  }
  for (let r = 0; r <= editorGrid.rows; r++) {
    X.beginPath();
    X.moveTo(0, 80 * S + r * editorCellH);
    X.lineTo(W, 80 * S + r * editorCellH);
    X.stroke();
  }

  // Draw placed items
  for (const p of editorLevel.platforms) {
    const wx = p.col * editorCellW;
    const wy = 80 * S + p.row * editorCellH;
    X.fillStyle = 'rgba(60,60,100,0.6)';
    X.fillRect(wx + 1, wy + 1, editorCellW - 2, editorCellH - 2);
    X.strokeStyle = '#00ccff';
    X.lineWidth = 1 * S;
    X.strokeRect(wx + 1, wy + 1, editorCellW - 2, editorCellH - 2);
  }
  for (const s of editorLevel.spikes) {
    const wx = s.col * editorCellW;
    const wy = 80 * S + s.row * editorCellH;
    X.fillStyle = 'rgba(255,0,80,0.4)';
    X.fillRect(wx + 1, wy + 1, editorCellW - 2, editorCellH - 2);
    X.strokeStyle = '#ff0064';
    X.lineWidth = 1 * S;
    X.strokeRect(wx + 1, wy + 1, editorCellW - 2, editorCellH - 2);
    // Spike triangles
    X.fillStyle = '#ff0064';
    const cx = wx + editorCellW / 2;
    X.beginPath();
    X.moveTo(cx - 4 * S, wy + editorCellH - 2);
    X.lineTo(cx + 4 * S, wy + editorCellH - 2);
    X.lineTo(cx, wy + 2);
    X.closePath();
    X.fill();
  }
  for (const o of editorLevel.orbs) {
    const wx = o.col * editorCellW + editorCellW / 2;
    const wy = 80 * S + o.row * editorCellH + editorCellH / 2;
    X.fillStyle = '#4488ff';
    X.shadowColor = '#4488ff';
    X.shadowBlur = 8 * S;
    X.beginPath();
    X.arc(wx, wy, Math.min(editorCellW, editorCellH) * 0.3, 0, Math.PI * 2);
    X.fill();
    X.shadowBlur = 0;
  }
  for (const l of editorLevel.lasers) {
    const wx = l.col * editorCellW;
    const wy = 80 * S + l.row * editorCellH;
    const lw = (l.w || 3) * editorCellW;
    X.fillStyle = 'rgba(255,50,50,0.3)';
    X.fillRect(wx, wy + editorCellH * 0.3, lw, editorCellH * 0.4);
    X.strokeStyle = '#ff3333';
    X.lineWidth = 1 * S;
    X.strokeRect(wx, wy + editorCellH * 0.3, lw, editorCellH * 0.4);
    // Emitter dots
    X.fillStyle = '#ff6666';
    X.beginPath();
    X.arc(wx, wy + editorCellH / 2, 3 * S, 0, Math.PI * 2);
    X.fill();
    X.beginPath();
    X.arc(wx + lw, wy + editorCellH / 2, 3 * S, 0, Math.PI * 2);
    X.fill();
  }
  for (const t of editorLevel.teleports) {
    const wx1 = t.col1 * editorCellW + editorCellW / 2;
    const wy1 = 80 * S + t.row1 * editorCellH + editorCellH / 2;
    const wx2 = t.col2 * editorCellW + editorCellW / 2;
    const wy2 = 80 * S + t.row2 * editorCellH + editorCellH / 2;
    // Connection line
    X.strokeStyle = 'rgba(255,100,255,0.3)';
    X.lineWidth = 1 * S;
    X.setLineDash([3 * S, 3 * S]);
    X.beginPath();
    X.moveTo(wx1, wy1); X.lineTo(wx2, wy2);
    X.stroke();
    X.setLineDash([]);
    // Portal A
    X.strokeStyle = '#ff66ff';
    X.lineWidth = 2 * S;
    X.beginPath();
    X.arc(wx1, wy1, Math.min(editorCellW, editorCellH) * 0.35, 0, Math.PI * 2);
    X.stroke();
    X.fillStyle = '#ff66ff';
    X.font = `${8 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('A', wx1, wy1 + 3 * S);
    // Portal B
    X.strokeStyle = '#66ffff';
    X.lineWidth = 2 * S;
    X.beginPath();
    X.arc(wx2, wy2, Math.min(editorCellW, editorCellH) * 0.35, 0, Math.PI * 2);
    X.stroke();
    X.fillStyle = '#66ffff';
    X.font = `${8 * S}px sans-serif`;
    X.fillText('B', wx2, wy2 + 3 * S);
  }
  for (const m of editorLevel.movingPlatforms) {
    const wx = m.col * editorCellW;
    const wy = 80 * S + m.row * editorCellH;
    X.fillStyle = 'rgba(68,170,255,0.4)';
    X.fillRect(wx + 1, wy + 1, editorCellW - 2, editorCellH - 2);
    X.strokeStyle = '#44aaff';
    X.lineWidth = 1.5 * S;
    X.strokeRect(wx + 1, wy + 1, editorCellW - 2, editorCellH - 2);
    // Direction indicator
    X.fillStyle = '#44aaff';
    X.font = `bold ${10 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText(m.dir === 'h' ? '‚Üî' : '‚Üï', wx + editorCellW / 2, wy + editorCellH / 2 + 4 * S);
  }

  // Spawn point
  if (editorLevel.spawn) {
    const wx = editorLevel.spawn.col * editorCellW + editorCellW / 2;
    const wy = 80 * S + editorLevel.spawn.row * editorCellH + editorCellH / 2;
    X.fillStyle = '#00ffff';
    X.shadowColor = '#00ffff';
    X.shadowBlur = 10 * S;
    X.beginPath();
    X.arc(wx, wy, Math.min(editorCellW, editorCellH) * 0.3, 0, Math.PI * 2);
    X.fill();
    X.shadowBlur = 0;
    X.fillStyle = '#000';
    X.font = `bold ${8 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('S', wx, wy + 3 * S);
  }

  // Goal point
  if (editorLevel.goal) {
    const wx = editorLevel.goal.col * editorCellW + editorCellW / 2;
    const wy = 80 * S + editorLevel.goal.row * editorCellH + editorCellH / 2;
    X.fillStyle = '#ffd700';
    X.shadowColor = '#ffd700';
    X.shadowBlur = 10 * S;
    X.beginPath();
    X.arc(wx, wy, Math.min(editorCellW, editorCellH) * 0.3, 0, Math.PI * 2);
    X.fill();
    X.shadowBlur = 0;
    X.fillStyle = '#000';
    X.font = `bold ${8 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('G', wx, wy + 3 * S);
  }

  // Portal A placement indicator
  if (editorPortalA) {
    const wx = editorPortalA.col * editorCellW + editorCellW / 2;
    const wy = 80 * S + editorPortalA.row * editorCellH + editorCellH / 2;
    X.strokeStyle = '#ff66ff';
    X.lineWidth = 2 * S;
    X.setLineDash([4 * S, 4 * S]);
    X.beginPath();
    X.arc(wx, wy, Math.min(editorCellW, editorCellH) * 0.4, 0, Math.PI * 2);
    X.stroke();
    X.setLineDash([]);
  }

  X.restore();

  // Toolbar at top
  drawEditorToolbar();

  // Message
  if (editorMessageTimer > 0) {
    editorMessageTimer -= dt;
    X.save();
    X.globalAlpha = Math.min(1, editorMessageTimer);
    X.fillStyle = 'rgba(0,0,0,0.7)';
    X.beginPath();
    X.roundRect(W / 2 - 120 * S, H / 2 - 20 * S, 240 * S, 40 * S, 8 * S);
    X.fill();
    X.fillStyle = '#fff';
    X.font = `bold ${14 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText(editorMessage, W / 2, H / 2 + 5 * S);
    X.restore();
  }

  // Load/Save menu overlay
  if (editorMenuOpen) {
    drawEditorMenu();
  }
}

function drawEditorToolbar() {
  // Background
  X.save();
  X.fillStyle = 'rgba(10,0,26,0.95)';
  X.fillRect(0, 0, W, 78 * S);
  X.strokeStyle = 'rgba(0,255,255,0.2)';
  X.lineWidth = 1 * S;
  X.beginPath();
  X.moveTo(0, 78 * S); X.lineTo(W, 78 * S);
  X.stroke();

  // Title
  X.fillStyle = '#00ffff';
  X.font = `bold ${12 * S}px sans-serif`;
  X.textAlign = 'left';
  X.fillText('LEVEL EDITOR', 8 * S, 14 * S);

  // Tool buttons (2 rows)
  const tools = [
    { id: 'platform', label: '‚ñ†', color: '#00ccff', tip: 'Wall' },
    { id: 'spike', label: '‚ñ≤', color: '#ff0064', tip: 'Spike' },
    { id: 'orb', label: '‚óè', color: '#4488ff', tip: 'Orb' },
    { id: 'laser', label: '‚ïê', color: '#ff3333', tip: 'Laser' },
    { id: 'portal_a', label: '‚óé', color: '#ff66ff', tip: 'Portal' },
    { id: 'moving_h', label: '‚Üî', color: '#44aaff', tip: 'MovH' },
    { id: 'moving_v', label: '‚Üï', color: '#44aaff', tip: 'MovV' },
    { id: 'spawn', label: 'S', color: '#00ffff', tip: 'Start' },
    { id: 'goal', label: 'G', color: '#ffd700', tip: 'Goal' },
    { id: 'erase', label: '‚úï', color: '#ff4444', tip: 'Erase' },
  ];
  const btnSize = 28 * S;
  const btnGap = 4 * S;
  const toolStartX = 8 * S;
  const row1Y = 22 * S;
  const row2Y = row1Y + btnSize + btnGap;
  const toolsPerRow = 5;

  editorToolbar = [];
  tools.forEach((tool, i) => {
    const row = Math.floor(i / toolsPerRow);
    const col = i % toolsPerRow;
    const bx = toolStartX + col * (btnSize + btnGap);
    const by = (row === 0 ? row1Y : row2Y);
    const selected = editorTool === tool.id || (editorTool === 'portal_b' && tool.id === 'portal_a');

    X.fillStyle = selected ? 'rgba(0,255,255,0.25)' : 'rgba(255,255,255,0.05)';
    X.beginPath();
    X.roundRect(bx, by, btnSize, btnSize, 4 * S);
    X.fill();
    if (selected) {
      X.strokeStyle = '#00ffff';
      X.lineWidth = 2 * S;
      X.stroke();
    }
    X.fillStyle = tool.color;
    X.font = `bold ${14 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText(tool.label, bx + btnSize / 2, by + btnSize / 2 + 5 * S);

    // Tiny label below
    X.fillStyle = 'rgba(255,255,255,0.4)';
    X.font = `${6 * S}px sans-serif`;
    X.fillText(tool.tip, bx + btnSize / 2, by + btnSize + 7 * S);

    editorToolbar.push({ x: bx, y: by, w: btnSize, h: btnSize, id: tool.id });
  });

  // Action buttons on the right
  const actionBtns = [
    { id: 'play', label: '‚ñ∂', color: '#00ff88' },
    { id: 'save', label: 'üíæ', color: '#ffd700' },
    { id: 'load', label: 'üìÇ', color: '#ff9944' },
    { id: 'clear', label: 'üóë', color: '#ff4444' },
    { id: 'back', label: '‚Üê', color: '#ffffff' },
  ];
  const aBtnW = 32 * S;
  const aBtnH = 26 * S;
  const aStartX = W - (aBtnW + 4 * S) * actionBtns.length - 4 * S;

  actionBtns.forEach((btn, i) => {
    const bx = aStartX + i * (aBtnW + 4 * S);
    const by = row1Y;

    X.fillStyle = 'rgba(255,255,255,0.05)';
    X.beginPath();
    X.roundRect(bx, by, aBtnW, aBtnH, 4 * S);
    X.fill();
    X.strokeStyle = btn.color + '44';
    X.lineWidth = 1 * S;
    X.stroke();

    X.fillStyle = btn.color;
    X.font = `${12 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText(btn.label, bx + aBtnW / 2, by + aBtnH / 2 + 4 * S);

    editorToolbar.push({ x: bx, y: by, w: aBtnW, h: aBtnH, id: 'action_' + btn.id });
  });

  // Item count display
  X.fillStyle = 'rgba(255,255,255,0.35)';
  X.font = `${9 * S}px sans-serif`;
  X.textAlign = 'right';
  const counts = `P:${editorLevel.platforms.length} S:${editorLevel.spikes.length} O:${editorLevel.orbs.length} L:${editorLevel.lasers.length} T:${editorLevel.teleports.length}`;
  X.fillText(counts, W - 8 * S, row2Y + aBtnH + 2 * S);

  X.restore();
}

function drawEditorMenu() {
  X.save();
  X.fillStyle = 'rgba(0,0,0,0.9)';
  X.fillRect(0, 0, W, H);

  drawNeonText('SAVED LEVELS', W / 2, 50 * S, 22, '#ffd700');

  if (editorSavedLevels.length === 0) {
    X.fillStyle = 'rgba(255,255,255,0.4)';
    X.font = `${14 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('No saved levels yet.', W / 2, H * 0.4);
  } else {
    const startY = 90 * S;
    gs.btns.editorLoadBtns = [];
    gs.btns.editorDeleteBtns = [];
    for (let i = 0; i < editorSavedLevels.length && i < 8; i++) {
      const entry = editorSavedLevels[i];
      const y = startY + i * 50 * S;
      // Background
      X.fillStyle = i === editorSelectedSave ? 'rgba(0,255,255,0.1)' : 'rgba(255,255,255,0.03)';
      X.beginPath();
      X.roundRect(W * 0.08, y, W * 0.84, 42 * S, 6 * S);
      X.fill();
      X.strokeStyle = 'rgba(0,255,255,0.15)';
      X.lineWidth = 1 * S;
      X.stroke();
      // Name
      X.fillStyle = '#fff';
      X.font = `bold ${13 * S}px sans-serif`;
      X.textAlign = 'left';
      X.fillText(entry.name || 'Custom', W * 0.12, y + 18 * S);
      // Date
      X.fillStyle = 'rgba(255,255,255,0.3)';
      X.font = `${10 * S}px sans-serif`;
      const d = new Date(entry.date);
      X.fillText(`${d.getMonth()+1}/${d.getDate()}`, W * 0.12, y + 34 * S);
      // Info
      const info = entry.grid;
      X.fillStyle = 'rgba(0,255,255,0.5)';
      X.fillText(`${info.platforms.length}P ${info.spikes.length}S ${info.orbs.length}O`, W * 0.4, y + 34 * S);
      // Load button
      const loadBx = W * 0.65;
      const loadBw = W * 0.12;
      X.fillStyle = 'rgba(0,255,100,0.15)';
      X.beginPath();
      X.roundRect(loadBx, y + 6 * S, loadBw, 30 * S, 4 * S);
      X.fill();
      X.strokeStyle = '#00ff88';
      X.lineWidth = 1 * S;
      X.stroke();
      X.fillStyle = '#00ff88';
      X.font = `bold ${11 * S}px sans-serif`;
      X.textAlign = 'center';
      X.fillText('LOAD', loadBx + loadBw / 2, y + 26 * S);
      gs.btns.editorLoadBtns.push({ x: loadBx, y: y + 6 * S, w: loadBw, h: 30 * S, index: i });
      // Delete button
      const delBx = W * 0.8;
      const delBw = W * 0.1;
      X.fillStyle = 'rgba(255,0,0,0.1)';
      X.beginPath();
      X.roundRect(delBx, y + 6 * S, delBw, 30 * S, 4 * S);
      X.fill();
      X.strokeStyle = '#ff4444';
      X.lineWidth = 1 * S;
      X.stroke();
      X.fillStyle = '#ff4444';
      X.font = `bold ${11 * S}px sans-serif`;
      X.textAlign = 'center';
      X.fillText('DEL', delBx + delBw / 2, y + 26 * S);
      gs.btns.editorDeleteBtns.push({ x: delBx, y: y + 6 * S, w: delBw, h: 30 * S, index: i });
    }
  }

  gs.btns.editorMenuClose = drawBtn(W / 2 - 60 * S, H - 60 * S, 120 * S, 42 * S, '‚Üê BACK', false);
  X.restore();
}

function handleEditorTap(x, y) {
  // If menu is open, handle menu taps
  if (editorMenuOpen) {
    if (gs.btns.editorLoadBtns) {
      for (const btn of gs.btns.editorLoadBtns) {
        if (hit(x, y, btn)) { sfxClick(); editorLoad(btn.index); return; }
      }
    }
    if (gs.btns.editorDeleteBtns) {
      for (const btn of gs.btns.editorDeleteBtns) {
        if (hit(x, y, btn)) { sfxClick(); editorDelete(btn.index); return; }
      }
    }
    if (hit(x, y, gs.btns.editorMenuClose)) { sfxClick(); editorMenuOpen = false; return; }
    return;
  }

  // Check toolbar buttons
  for (const btn of editorToolbar) {
    if (hit(x, y, btn)) {
      sfxClick();
      if (btn.id.startsWith('action_')) {
        const action = btn.id.replace('action_', '');
        if (action === 'play') editorPlay();
        else if (action === 'save') editorSave();
        else if (action === 'load') { editorMenuOpen = true; gs.btns = {}; }
        else if (action === 'clear') {
          editorLevel = { platforms: [], spikes: [], orbs: [], lasers: [], teleports: [], movingPlatforms: [], spawn: null, goal: null };
          editorPortalA = null;
          editorShowMsg('Cleared!');
        }
        else if (action === 'back') { screen = 'menu'; gs.btns = {}; editorMode = false; }
      } else {
        editorTool = btn.id;
        if (btn.id !== 'portal_a' && btn.id !== 'portal_b') editorPortalA = null;
      }
      return;
    }
  }

  // Grid placement
  if (y > 80 * S) {
    const grid = editorWorldToGrid(x, y);
    editorPlaceTile(grid.col, grid.row);
    sfxClick();
  }
}

// ============================================================
// ENHANCED DAILY CHALLENGE ‚Äî more variety with seeded generation
// ============================================================
function generateDailyChallenge_v2() {
  dailyChallengeSeed = getDailySeed();
  const rng = seededRandom(dailyChallengeSeed);
  // Check completion
  try {
    const dc = localStorage.getItem('gflip3_daily');
    if (dc) {
      const data = JSON.parse(dc);
      if (data.seed === dailyChallengeSeed) dailyChallengeCompleted = true;
      else dailyChallengeCompleted = false;
    }
  } catch(e) {}

  // More sophisticated procedural generation
  const difficulty = (dailyChallengeSeed % 7) / 6; // 0-1, varies by day of week
  const numPlats = 3 + Math.floor(rng() * 4 + difficulty * 3);
  const numSpikes = 2 + Math.floor(rng() * 3 + difficulty * 2);
  const numOrbs = 2 + Math.floor(rng() * 2);
  const platforms = [];
  const spikes = [];
  const orbs = [];
  const lasers = [];
  const teleports = [];
  const movingPlatforms = [];

  // Floor and ceiling
  platforms.push([0, 0.0, 1.0, 0.02]);
  platforms.push([0, 0.98, 1.0, 0.02]);

  // Generate platforms with spacing
  const usedSlots = new Set();
  for (let i = 0; i < numPlats; i++) {
    let px, py, pw;
    let attempts = 0;
    do {
      px = 0.05 + rng() * 0.75;
      py = 0.12 + rng() * 0.72;
      pw = 0.06 + rng() * 0.14;
      attempts++;
    } while (attempts < 20 && [...usedSlots].some(s => Math.abs(s.x - px) < 0.12 && Math.abs(s.y - py) < 0.12));
    usedSlots.add({ x: px, y: py });
    const types = ['solid', 'solid', 'bouncy', 'crumble'];
    if (difficulty > 0.5 && rng() > 0.7) types.push('crumble');
    const ptype = types[Math.floor(rng() * types.length)];
    platforms.push([px, py, pw, 0.025, ptype]);
  }

  // Spikes
  for (let i = 0; i < numSpikes; i++) {
    const sx = 0.1 + rng() * 0.75;
    const onCeiling = rng() < 0.5;
    spikes.push([sx, onCeiling ? 0.02 : 0.88 + rng() * 0.06, 0.03 + rng() * 0.06, 0.04 + rng() * 0.04]);
  }

  // Orbs
  for (let i = 0; i < numOrbs; i++) {
    orbs.push([0.1 + rng() * 0.75, 0.12 + rng() * 0.7]);
  }

  // Maybe add lasers for hard days
  if (difficulty > 0.4) {
    const numLasers = Math.floor(rng() * 2 + difficulty);
    for (let i = 0; i < numLasers; i++) {
      lasers.push({
        x: 0.1 + rng() * 0.5,
        y: 0.15 + rng() * 0.65,
        w: 0.1 + rng() * 0.2,
        h: 0.025,
        onTime: 1.0 + rng() * 1.5,
        offTime: 0.8 + rng() * 1.0,
        delay: rng() * 2
      });
    }
  }

  // Maybe add teleport pair
  if (difficulty > 0.3 && rng() > 0.5) {
    teleports.push({
      x1: 0.15 + rng() * 0.3, y1: 0.2 + rng() * 0.5,
      x2: 0.55 + rng() * 0.3, y2: 0.2 + rng() * 0.5
    });
  }

  // Maybe add moving platforms
  if (rng() > 0.4) {
    const numMoving = 1 + Math.floor(rng() * 2);
    for (let i = 0; i < numMoving; i++) {
      movingPlatforms.push({
        x: 0.15 + rng() * 0.6,
        y: 0.2 + rng() * 0.6,
        w: 0.08 + rng() * 0.08,
        h: 0.025,
        dir: rng() > 0.5 ? 'h' : 'v',
        range: 0.05 + rng() * 0.1,
        speed: 0.8 + rng() * 1.2
      });
    }
  }

  // Difficulty-based star thresholds
  const baseTime = 12 + difficulty * 15;

  return {
    name: 'Daily Challenge', stars: [Math.floor(baseTime), Math.floor(baseTime * 1.3), Math.floor(baseTime * 1.8)],
    spawn: [0.05, 0.2 + rng() * 0.4], goal: [0.9, 0.2 + rng() * 0.4],
    width: 1.0, platforms, spikes, orbs, wells: [],
    winds: rng() > 0.5 ? [[0.3, 0.2, 0.3, 0.5, rng() > 0.5 ? 1 : -1, 0, 0.3 + rng() * 0.3]] : [],
    dailyLasers: lasers,
    dailyTeleports: teleports,
    dailyMoving: movingPlatforms
  };
}

// ============================================================
// PERSISTENT HIGH SCORES with dates ‚Äî top 10 per level + global
// ============================================================
let highScores = {};
try { const hs = localStorage.getItem('gflip3_hiscores'); if (hs) highScores = JSON.parse(hs); } catch(e) {}
function saveHighScores() { try { localStorage.setItem('gflip3_hiscores', JSON.stringify(highScores)); } catch(e) {} }

function addHighScore(levelIndex, score, time, stars, deaths) {
  const key = levelIndex === -1 ? 'daily' : `lvl_${levelIndex}`;
  if (!highScores[key]) highScores[key] = [];
  const now = new Date();
  const dateStr = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
  const timeStr = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
  highScores[key].push({ score, time: parseFloat(time.toFixed(1)), stars, deaths, date: dateStr, clock: timeStr });
  highScores[key].sort((a, b) => b.score - a.score);
  if (highScores[key].length > 10) highScores[key].length = 10;
  // Also update global top 10
  if (!highScores.global) highScores.global = [];
  highScores.global.push({ score, level: levelIndex, date: dateStr, clock: timeStr, stars });
  highScores.global.sort((a, b) => b.score - a.score);
  if (highScores.global.length > 10) highScores.global.length = 10;
  saveHighScores();
}

function getGlobalTop10() {
  return (highScores.global || []).slice(0, 10);
}

function getLevelTop10(levelIndex) {
  const key = levelIndex === -1 ? 'daily' : `lvl_${levelIndex}`;
  return (highScores[key] || []).slice(0, 10);
}

// High scores screen state
let highScoreScreen = 'global'; // 'global' or 'level'
let highScoreLevel = 0;

function drawHighScoresScreen() {
  const isGlobal = highScoreScreen === 'global';
  drawNeonText(isGlobal ? 'GLOBAL TOP 10' : `LEVEL ${highScoreLevel + 1} TOP 10`, W / 2, 50 * S, 22, '#ffd700');

  const scores = isGlobal ? getGlobalTop10() : getLevelTop10(highScoreLevel);

  if (scores.length === 0) {
    X.save();
    X.fillStyle = 'rgba(255,255,255,0.4)';
    X.font = `${14 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('No scores yet!', W / 2, H * 0.35);
    X.restore();
  } else {
    const startY = 80 * S;
    // Header
    X.save();
    X.fillStyle = 'rgba(255,255,255,0.3)';
    X.font = `${10 * S}px sans-serif`;
    X.textAlign = 'left';
    X.fillText('#', W * 0.06, startY);
    X.fillText('SCORE', W * 0.15, startY);
    X.fillText('TIME', W * 0.4, startY);
    X.fillText('STARS', W * 0.58, startY);
    X.fillText('DATE', W * 0.75, startY);
    X.restore();

    scores.forEach((entry, i) => {
      const y = startY + 15 * S + i * 32 * S;
      const isTop3 = i < 3;
      X.save();
      // Highlight row
      if (isTop3) {
        X.fillStyle = ['rgba(255,215,0,0.06)', 'rgba(192,192,192,0.04)', 'rgba(205,127,50,0.03)'][i];
        X.fillRect(W * 0.04, y - 6 * S, W * 0.92, 28 * S);
      }
      // Rank
      X.fillStyle = isTop3 ? ['#ffd700', '#c0c0c0', '#cd7f32'][i] : 'rgba(255,255,255,0.5)';
      X.font = `bold ${13 * S}px sans-serif`;
      X.textAlign = 'left';
      X.fillText(`${i + 1}`, W * 0.06, y + 10 * S);
      // Score
      X.fillStyle = '#00ffff';
      X.font = `bold ${14 * S}px sans-serif`;
      X.fillText(`${entry.score}`, W * 0.15, y + 10 * S);
      // Time
      X.fillStyle = 'rgba(255,255,255,0.6)';
      X.font = `${12 * S}px monospace`;
      X.fillText(`${entry.time}s`, W * 0.4, y + 10 * S);
      // Stars
      X.font = `${11 * S}px sans-serif`;
      const starStr = '‚òÖ'.repeat(entry.stars || 0) + '‚òÜ'.repeat(3 - (entry.stars || 0));
      X.fillStyle = '#ffd700';
      X.fillText(starStr, W * 0.58, y + 10 * S);
      // Date
      X.fillStyle = 'rgba(255,255,255,0.3)';
      X.font = `${10 * S}px sans-serif`;
      X.fillText(entry.date || '', W * 0.75, y + 6 * S);
      X.fillText(entry.clock || '', W * 0.75, y + 18 * S);
      // Level indicator (global view)
      if (isGlobal && entry.level !== undefined) {
        X.fillStyle = 'rgba(0,255,255,0.3)';
        X.font = `${9 * S}px sans-serif`;
        X.textAlign = 'right';
        X.fillText(entry.level === -1 ? 'Daily' : `Lv.${entry.level + 1}`, W * 0.96, y + 10 * S);
      }
      X.restore();
    });
  }

  // Navigation buttons
  gs.btns = gs.btns || {};
  const navY = H - 110 * S;
  if (isGlobal) {
    gs.btns.hsLevel = drawBtn(W / 2 - 75 * S, navY, 150 * S, 36 * S, 'BY LEVEL', false);
  } else {
    gs.btns.hsGlobal = drawBtn(W / 2 - 75 * S, navY, 150 * S, 36 * S, 'GLOBAL', false);
    // Level nav arrows
    if (highScoreLevel > 0) {
      gs.btns.hsPrev = drawBtn(W * 0.05, navY, 40 * S, 36 * S, '‚óÄ', false);
    }
    if (highScoreLevel < LEVELS.length - 1) {
      gs.btns.hsNext = drawBtn(W * 0.95 - 40 * S, navY, 40 * S, 36 * S, '‚ñ∂', false);
    }
  }
  gs.btns.back = drawBtn(W / 2 - 50 * S, H - 60 * S, 100 * S, 42 * S, '‚Üê BACK', false);
}

// ============================================================
// SCREEN SHAKE & JUICE SYSTEM ‚Äî enhanced
// ============================================================
let screenShakeX = 0, screenShakeY = 0;
let chromaAberration = 0; // chromatic aberration intensity on big impacts
let vignetteIntensity = 0; // darkened edges on near-death

function updateJuice() {
  // Screen shake with directional component
  if (screenShake > 0.5) {
    const intensity = screenShake * S;
    screenShakeX = (Math.random() - 0.5) * intensity * 2;
    screenShakeY = (Math.random() - 0.5) * intensity * 2;
  } else {
    screenShakeX = 0;
    screenShakeY = 0;
  }
  // Chromatic aberration decay
  if (chromaAberration > 0) chromaAberration *= 0.9;
  if (chromaAberration < 0.01) chromaAberration = 0;
  // Vignette decay
  if (vignetteIntensity > 0) vignetteIntensity *= 0.95;
  if (vignetteIntensity < 0.01) vignetteIntensity = 0;
}

function drawVignette() {
  if (vignetteIntensity < 0.01) return;
  X.save();
  const grad = X.createRadialGradient(W / 2, H / 2, W * 0.2, W / 2, H / 2, W * 0.8);
  grad.addColorStop(0, 'rgba(0,0,0,0)');
  grad.addColorStop(0.7, `rgba(100,0,0,${vignetteIntensity * 0.2})`);
  grad.addColorStop(1, `rgba(50,0,0,${vignetteIntensity * 0.5})`);
  X.fillStyle = grad;
  X.fillRect(0, 0, W, H);
  X.restore();
}

function drawChromaticAberration() {
  // Simulated chromatic aberration by drawing tinted overlays
  if (chromaAberration < 0.5) return;
  const offset = chromaAberration * S * 0.5;
  X.save();
  X.globalCompositeOperation = 'screen';
  X.globalAlpha = chromaAberration * 0.03;
  X.fillStyle = '#ff0000';
  X.fillRect(-offset, 0, W, H);
  X.fillStyle = '#0000ff';
  X.fillRect(offset, 0, W, H);
  X.restore();
}

// Enhanced coin collect effects
function coinCollectBurst(x, y, color) {
  // Ring burst
  for (let i = 0; i < 12; i++) {
    const a = (i / 12) * Math.PI * 2;
    const speed = 3 + Math.random() * 2;
    particles.push({
      x, y,
      vx: Math.cos(a) * speed * S,
      vy: Math.sin(a) * speed * S,
      life: 1, decay: 0.025,
      size: (2 + Math.random() * 3) * S,
      color, grav: 0, shape: 'circle',
      rotation: 0, rotSpeed: 0
    });
  }
  // Center flash
  particles.push({
    x, y, vx: 0, vy: 0,
    life: 1, decay: 0.06,
    size: 20 * S, color: '#ffffff',
    grav: 0, shape: 'circle'
  });
  // Sparkle trail upward
  for (let i = 0; i < 6; i++) {
    particles.push({
      x: x + (Math.random() - 0.5) * 20 * S,
      y: y,
      vx: (Math.random() - 0.5) * 1 * S,
      vy: -(2 + Math.random() * 3) * S,
      life: 1, decay: 0.02,
      size: (1 + Math.random() * 2) * S,
      color: '#ffd700', grav: 0.02 * S, shape: 'circle'
    });
  }
}

// Death juice
function deathJuice() {
  screenShake = 25;
  chromaAberration = 8;
  vignetteIntensity = 1;
  // Radial shockwave
  for (let i = 0; i < 24; i++) {
    const a = (i / 24) * Math.PI * 2;
    const speed = 5 + Math.random() * 4;
    particles.push({
      x: gs.player.x, y: gs.player.y,
      vx: Math.cos(a) * speed * S,
      vy: Math.sin(a) * speed * S,
      life: 1, decay: 0.02,
      size: (3 + Math.random() * 4) * S,
      color: '#ff0044', grav: 0.05 * S,
      shape: Math.random() > 0.5 ? 'circle' : 'rect',
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.5
    });
  }
  // Secondary smaller particles
  for (let i = 0; i < 16; i++) {
    const a = Math.random() * Math.PI * 2;
    const speed = 2 + Math.random() * 6;
    particles.push({
      x: gs.player.x + (Math.random() - 0.5) * 10 * S,
      y: gs.player.y + (Math.random() - 0.5) * 10 * S,
      vx: Math.cos(a) * speed * S,
      vy: Math.sin(a) * speed * S,
      life: 1, decay: 0.03,
      size: (1 + Math.random() * 2) * S,
      color: '#ffffff', grav: 0.1 * S, shape: 'circle'
    });
  }
  // Gravity-colored burst
  for (let i = 0; i < 10; i++) {
    const a = Math.random() * Math.PI * 2;
    particles.push({
      x: gs.player.x, y: gs.player.y,
      vx: Math.cos(a) * (3 + Math.random() * 3) * S,
      vy: Math.sin(a) * (3 + Math.random() * 3) * S,
      life: 1, decay: 0.015,
      size: (4 + Math.random() * 5) * S,
      color: currentAccent, grav: 0.03 * S,
      shape: 'rect',
      rotation: Math.random() * Math.PI,
      rotSpeed: (Math.random() - 0.5) * 0.4
    });
  }
}

// Win juice
function winJuice() {
  screenShake = 15;
  chromaAberration = 4;
  // Firework bursts
  for (let burst = 0; burst < 3; burst++) {
    setTimeout(() => {
      const bx = gs.portal.x + (Math.random() - 0.5) * 80 * S;
      const by = gs.portal.y + (Math.random() - 0.5) * 80 * S;
      const colors = ['#ffd700', '#ff6b9d', '#00ffff', '#44ff44', '#ff4444', '#b464ff'];
      const c = colors[Math.floor(Math.random() * colors.length)];
      for (let i = 0; i < 16; i++) {
        const a = (i / 16) * Math.PI * 2;
        const speed = 3 + Math.random() * 4;
        particles.push({
          x: bx, y: by,
          vx: Math.cos(a) * speed * S,
          vy: Math.sin(a) * speed * S,
          life: 1, decay: 0.015 + Math.random() * 0.01,
          size: (2 + Math.random() * 3) * S,
          color: c, grav: 0.06 * S, shape: 'circle'
        });
      }
    }, burst * 200);
  }
  // Confetti
  for (let i = 0; i < 30; i++) {
    const confColors = ['#ffd700', '#ff6b9d', '#00ffff', '#ff4444', '#44ff44', '#ff9944'];
    particles.push({
      x: gs.portal.x + (Math.random() - 0.5) * 60 * S,
      y: gs.portal.y + (Math.random() - 0.5) * 60 * S,
      vx: (Math.random() - 0.5) * 6 * S,
      vy: -(2 + Math.random() * 5) * S,
      life: 1, decay: 0.008 + Math.random() * 0.008,
      size: (3 + Math.random() * 4) * S,
      color: confColors[Math.floor(Math.random() * confColors.length)],
      grav: 0.1 * S, shape: 'rect',
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.3
    });
  }
}

// Near-miss juice
function nearMissJuice(px, py) {
  slowMo = 0.2;
  vignetteIntensity = Math.max(vignetteIntensity, 0.5);
  chromaAberration = Math.max(chromaAberration, 3);
  // Time-warp radial lines
  for (let i = 0; i < 8; i++) {
    const a = Math.random() * Math.PI * 2;
    speedLines.push({
      x: px + Math.cos(a) * 40 * S,
      y: py + Math.sin(a) * 40 * S,
      len: (15 + Math.random() * 25) * S,
      speed: (4 + Math.random() * 4) * S,
      life: 1, decay: 0.06,
      width: (1 + Math.random()) * S
    });
  }
}

// ============================================================
// SOUND EFFECTS for new features
// ============================================================
function sfxLaser() {
  tone(150, 0.15, 'sawtooth', 0.08);
  tone(300, 0.1, 'square', 0.05, 0.05);
  noise(0.1, 0.04);
}

function sfxTeleport() {
  tone(600, 0.08, 'sine', 0.12);
  tone(900, 0.06, 'sine', 0.1, 0.03);
  tone(1200, 0.1, 'sine', 0.08, 0.06);
  tone(1600, 0.08, 'triangle', 0.05, 0.09);
}

function sfxEditorPlace() {
  tone(800, 0.03, 'sine', 0.08);
  tone(1000, 0.02, 'sine', 0.05, 0.01);
}

// Near-miss tracking
let totalNearMisses = 0;
let sessionNearMisses = 0;
try { const nm = localStorage.getItem('gflip3_nearmiss'); if (nm) totalNearMisses = parseInt(nm) || 0; } catch(e) {}
function saveNearMisses() { try { localStorage.setItem('gflip3_nearmiss', totalNearMisses.toString()); } catch(e) {} }

// Leaderboard
let leaderboard = [];
try { const lb = localStorage.getItem('gflip3_lb'); if (lb) leaderboard = JSON.parse(lb); } catch(e) {}
function saveLeaderboard() { try { localStorage.setItem('gflip3_lb', JSON.stringify(leaderboard)); } catch(e) {} }
function addLeaderboardEntry(name, score, level) {
  leaderboard.push({ name: name.substring(0, 3).toUpperCase(), score, level, date: Date.now() });
  leaderboard.sort((a, b) => b.score - a.score);
  if (leaderboard.length > 20) leaderboard.length = 20;
  saveLeaderboard();
}

// Daily challenge
let dailyChallengeCompleted = false;
let dailyChallengeSeed = 0;
let dailyChallengeScreen = false;
function getDailySeed() {
  const d = new Date();
  return d.getFullYear() * 10000 + (d.getMonth() + 1) * 100 + d.getDate();
}
function seededRandom(seed) {
  let s = seed;
  return function() {
    s = (s * 1103515245 + 12345) & 0x7fffffff;
    return s / 0x7fffffff;
  };
}
function generateDailyChallenge() {
  dailyChallengeSeed = getDailySeed();
  const rng = seededRandom(dailyChallengeSeed);
  // Check if already completed today
  try {
    const dc = localStorage.getItem('gflip3_daily');
    if (dc) {
      const data = JSON.parse(dc);
      if (data.seed === dailyChallengeSeed) dailyChallengeCompleted = true;
    }
  } catch(e) {}

  // Generate a procedural level
  const numPlats = 4 + Math.floor(rng() * 4);
  const platforms = [];
  const spikes = [];
  const orbs = [];
  // Floor and ceiling
  platforms.push([0, 0.0, 1.0, 0.02]);
  platforms.push([0, 0.98, 1.0, 0.02]);
  // Random platforms
  for (let i = 0; i < numPlats; i++) {
    const px = 0.1 + rng() * 0.7;
    const py = 0.15 + rng() * 0.7;
    const pw = 0.08 + rng() * 0.15;
    const types = ['solid', 'solid', 'bouncy', 'crumble'];
    const ptype = types[Math.floor(rng() * types.length)];
    platforms.push([px, py, pw, 0.03, ptype]);
  }
  // Spikes
  const numSpikes = 2 + Math.floor(rng() * 3);
  for (let i = 0; i < numSpikes; i++) {
    spikes.push([0.15 + rng() * 0.7, rng() < 0.5 ? 0.02 : 0.88, 0.04 + rng() * 0.06, 0.06]);
  }
  // Orbs
  for (let i = 0; i < 3; i++) {
    orbs.push([0.15 + rng() * 0.7, 0.15 + rng() * 0.65]);
  }
  return {
    name: 'Daily Challenge', stars: [20, 14, 9],
    spawn: [0.05, 0.3 + rng() * 0.3], goal: [0.9, 0.3 + rng() * 0.3],
    width: 1.0, platforms, spikes, orbs, wells: [],
    winds: rng() > 0.5 ? [[0.3, 0.2, 0.3, 0.5, rng() > 0.5 ? 1 : -1, 0, 0.4 + rng() * 0.4]] : []
  };
}

// Stats screen
let showStats = false;
function getStats() {
  let totalStars = 0, levelsCompleted = 0, bestTimes = [];
  for (let i = 0; i < LEVELS.length; i++) {
    if (progress[i]) {
      if (progress[i].stars) totalStars += progress[i].stars;
      if (progress[i].completed) levelsCompleted++;
      if (progress[i].time) bestTimes.push({ level: i, time: progress[i].time });
    }
  }
  return { totalStars, levelsCompleted, totalNearMisses, totalScore, bestTimes };
}

// Initials entry state
let enteringInitials = false;
let initialsText = '';
let initialsCursor = 0;
let initialsScore = 0;
let initialsLevel = 0;

// ============================================================
// LEVELS
// ============================================================
const LEVELS = [
  // 1: Tutorial
  { name: 'Hello Gravity', stars: [15,10,7],
    spawn: [0.05, 0.4], goal: [0.9, 0.6], width: 1.0,
    platforms: [
      [0, 0.5, 1.0, 0.03],
      [0, 0.0, 1.0, 0.03],
    ],
    spikes: [],
    orbs: [[0.3, 0.35], [0.5, 0.35], [0.7, 0.35]],
    wells: []
  },
  // 2
  { name: 'Mind The Gap', stars: [15,10,7],
    spawn: [0.05, 0.4], goal: [0.9, 0.15], width: 1.0,
    platforms: [
      [0, 0.5, 0.4, 0.03],
      [0.6, 0.5, 0.4, 0.03],
      [0, 0.0, 1.0, 0.03],
    ],
    spikes: [[0.4, 0.47, 0.2, 0.06]],
    orbs: [[0.2, 0.35], [0.5, 0.12], [0.8, 0.35]],
    wells: []
  },
  // 3
  { name: 'Corridor', stars: [18,12,8],
    spawn: [0.05, 0.35], goal: [0.9, 0.65], width: 1.0,
    platforms: [
      [0, 0.45, 0.35, 0.03],
      [0.35, 0.0, 0.03, 0.35],
      [0.35, 0.55, 0.35, 0.03],
      [0.65, 0.55, 0.03, 0.45],
      [0.65, 0.45, 0.35, 0.03],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [[0.35, 0.38, 0.3, 0.04]],
    orbs: [[0.15, 0.3], [0.5, 0.45], [0.8, 0.3]],
    wells: []
  },
  // 4
  { name: 'Bounce House', stars: [18,12,8],
    spawn: [0.05, 0.4], goal: [0.9, 0.15], width: 1.0,
    platforms: [
      [0, 0.5, 0.3, 0.03],
      [0.4, 0.6, 0.2, 0.03, 'bouncy'],
      [0.7, 0.5, 0.3, 0.03],
      [0, 0.0, 1.0, 0.02],
    ],
    spikes: [[0.3, 0.47, 0.1, 0.06]],
    orbs: [[0.2, 0.35], [0.5, 0.2], [0.8, 0.35]],
    wells: []
  },
  // 5
  { name: 'Crumbling Path', stars: [20,14,9],
    spawn: [0.05, 0.4], goal: [0.9, 0.4], width: 1.0,
    platforms: [
      [0, 0.5, 0.15, 0.03],
      [0.2, 0.5, 0.15, 0.03, 'crumble'],
      [0.4, 0.5, 0.15, 0.03, 'crumble'],
      [0.6, 0.5, 0.15, 0.03, 'crumble'],
      [0.8, 0.5, 0.2, 0.03],
      [0, 0.0, 1.0, 0.02],
    ],
    spikes: [[0, 0.96, 1.0, 0.04]],
    orbs: [[0.3, 0.35], [0.5, 0.35], [0.7, 0.35]],
    wells: []
  },
  // 6
  { name: 'Strange Attractor', stars: [22,15,10],
    spawn: [0.05, 0.3], goal: [0.9, 0.3], width: 1.0,
    platforms: [
      [0, 0.4, 0.25, 0.03],
      [0.75, 0.4, 0.25, 0.03],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [[0.25, 0.37, 0.08, 0.06], [0.67, 0.37, 0.08, 0.06]],
    orbs: [[0.15, 0.25], [0.5, 0.3], [0.85, 0.25]],
    wells: [[0.5, 0.5, 0.35, 100]],
    winds: [[0.35, 0.0, 0.3, 0.35, 0, 1, 0.3]]
  },
  // 7
  { name: 'Zigzag', stars: [20,14,9],
    spawn: [0.05, 0.15], goal: [0.9, 0.85], width: 1.0,
    platforms: [
      [0, 0.2, 0.35, 0.03],
      [0.25, 0.4, 0.35, 0.03],
      [0, 0.6, 0.35, 0.03],
      [0.25, 0.8, 0.35, 0.03],
      [0.65, 0.3, 0.35, 0.03],
      [0.65, 0.7, 0.35, 0.03],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [[0.2, 0.25, 0.05, 0.12], [0.55, 0.55, 0.1, 0.08]],
    orbs: [[0.15, 0.08], [0.5, 0.5], [0.8, 0.62]],
    wells: []
  },
  // 8
  { name: 'Gauntlet', stars: [25,18,12],
    spawn: [0.05, 0.35], goal: [0.9, 0.65], width: 1.0,
    platforms: [
      [0, 0.45, 0.4, 0.03],
      [0.4, 0.45, 0.2, 0.03, 'moving', 0, 0.08, 1.2],
      [0.6, 0.45, 0.4, 0.03],
      [0, 0.0, 1.0, 0.02],
      [0, 0.55, 1.0, 0.03],
    ],
    spikes: [
      [0.15, 0.03, 0.06, 0.1],
      [0.3, 0.35, 0.06, 0.1],
      [0.45, 0.03, 0.06, 0.1],
      [0.6, 0.35, 0.06, 0.1],
      [0.75, 0.03, 0.06, 0.1],
    ],
    orbs: [[0.22, 0.25], [0.52, 0.25], [0.82, 0.25]],
    wells: []
  },
  // 9
  { name: 'Whirlpool', stars: [28,20,14],
    spawn: [0.05, 0.5], goal: [0.9, 0.5], width: 1.0,
    platforms: [
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
      [0, 0.58, 0.15, 0.03], [0.85, 0.58, 0.15, 0.03],
    ],
    spikes: [[0.35, 0.0, 0.06, 0.15], [0.6, 0.85, 0.06, 0.15]],
    orbs: [[0.2, 0.3], [0.5, 0.5], [0.8, 0.7]],
    wells: [[0.3, 0.35, 0.3, 90], [0.7, 0.65, 0.3, 90]],
    winds: [[0.4, 0.4, 0.2, 0.2, 1, 0, 0.5]]
  },
  // 10
  { name: 'Grand Finale', stars: [35,25,18],
    spawn: [0.05, 0.3], goal: [0.9, 0.7], width: 1.0,
    platforms: [
      [0, 0.4, 0.2, 0.03],
      [0.25, 0.6, 0.15, 0.03, 'bouncy'],
      [0.45, 0.35, 0.1, 0.03, 'crumble'],
      [0.6, 0.55, 0.15, 0.03],
      [0.8, 0.4, 0.1, 0.03, 'crumble'],
      [0.8, 0.75, 0.2, 0.03],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [
      [0.2, 0.02, 0.05, 0.08],
      [0.4, 0.9, 0.15, 0.06],
      [0.55, 0.02, 0.05, 0.08],
      [0.75, 0.9, 0.05, 0.06],
    ],
    orbs: [[0.1, 0.25], [0.5, 0.2], [0.85, 0.62]],
    wells: [[0.5, 0.65, 0.25, 80]]
  },
  // 11-15
  { name: 'Tunnel Vision', stars: [20,14,9],
    spawn: [0.05, 0.48], goal: [0.9, 0.48], width: 1.0,
    platforms: [
      [0, 0.42, 1.0, 0.02], [0, 0.56, 1.0, 0.02],
    ],
    spikes: [
      [0.2, 0.44, 0.05, 0.04],
      [0.35, 0.52, 0.05, 0.04],
      [0.5, 0.44, 0.05, 0.04],
      [0.65, 0.52, 0.05, 0.04],
      [0.8, 0.44, 0.05, 0.04],
    ],
    orbs: [[0.28, 0.48], [0.58, 0.48], [0.88, 0.48]],
    wells: []
  },
  { name: 'Double Well', stars: [30,22,15],
    spawn: [0.05, 0.2], goal: [0.9, 0.8], width: 1.0,
    platforms: [
      [0, 0.3, 0.2, 0.03], [0.8, 0.7, 0.2, 0.03],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [[0.45, 0.45, 0.1, 0.1]],
    orbs: [[0.1, 0.15], [0.5, 0.3], [0.9, 0.65]],
    wells: [[0.3, 0.5, 0.4, 110], [0.7, 0.5, 0.4, 110]]
  },
  { name: 'Bounce Maze', stars: [25,18,12],
    spawn: [0.05, 0.3], goal: [0.9, 0.7], width: 1.0,
    platforms: [
      [0, 0.4, 0.2, 0.03, 'bouncy'],
      [0.3, 0.6, 0.15, 0.03, 'bouncy'],
      [0.5, 0.3, 0.15, 0.03, 'bouncy'],
      [0.7, 0.5, 0.15, 0.03, 'bouncy'],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [[0.25, 0.02, 0.05, 0.1], [0.5, 0.88, 0.1, 0.1], [0.75, 0.02, 0.05, 0.1]],
    orbs: [[0.15, 0.15], [0.45, 0.15], [0.85, 0.6]],
    wells: []
  },
  { name: 'Crumble Run', stars: [22,16,11],
    spawn: [0.05, 0.35], goal: [0.9, 0.35], width: 1.0,
    platforms: [
      [0, 0.45, 0.1, 0.03],
      [0.12, 0.45, 0.1, 0.03, 'crumble'],
      [0.24, 0.45, 0.1, 0.03, 'crumble'],
      [0.36, 0.45, 0.1, 0.03, 'crumble'],
      [0.48, 0.45, 0.1, 0.03, 'crumble'],
      [0.6, 0.45, 0.1, 0.03, 'crumble'],
      [0.72, 0.45, 0.1, 0.03, 'crumble'],
      [0.84, 0.45, 0.16, 0.03],
      [0, 0.0, 1.0, 0.02],
    ],
    spikes: [[0, 0.96, 1.0, 0.04]],
    orbs: [[0.2, 0.3], [0.5, 0.3], [0.8, 0.3]],
    wells: []
  },
  { name: 'Everything', stars: [40,30,20],
    spawn: [0.05, 0.25], goal: [0.9, 0.75], width: 1.0,
    platforms: [
      [0, 0.35, 0.15, 0.03],
      [0.2, 0.55, 0.12, 0.03, 'bouncy'],
      [0.38, 0.3, 0.1, 0.03, 'crumble'],
      [0.55, 0.65, 0.12, 0.03, 'moving', 0, 0.1, 0.8],
      [0.7, 0.4, 0.1, 0.03, 'crumble'],
      [0.85, 0.8, 0.15, 0.03],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [
      [0.15, 0.02, 0.05, 0.08],
      [0.35, 0.9, 0.08, 0.06],
      [0.6, 0.02, 0.05, 0.08],
      [0.8, 0.9, 0.05, 0.06],
    ],
    orbs: [[0.1, 0.18], [0.5, 0.2], [0.9, 0.68]],
    wells: [[0.45, 0.5, 0.3, 90]],
    winds: [[0.15, 0.0, 0.25, 0.3, 0, 1, 0.35], [0.6, 0.7, 0.25, 0.28, -1, 0, 0.4]]
  },
];

// ============================================================
// LEVEL INITIALIZATION
// ============================================================
function startLevel(index, levelData) {
  lvl = index;
  const L = levelData || LEVELS[index];

  const p = new Player(W * L.spawn[0], H * L.spawn[1]);
  p.invuln = 0.5; // brief invulnerability on spawn

  const platforms = L.platforms.map(d => {
    const pl = new Platform(W * d[0], H * d[1], W * d[2], H * d[3], d[4] || 'solid');
    // Moving platform ranges: d[5] = moveRangeX fraction, d[6] = moveRangeY fraction, d[7] = speed
    if (d[4] === 'moving' || d[5] || d[6]) {
      pl.type = pl.type === 'solid' && (d[5] || d[6]) ? 'moving' : pl.type;
      if (d[4] === 'moving') pl.type = 'moving';
      pl.moveRangeX = (d[5] || 0) * W;
      pl.moveRangeY = (d[6] || 0) * H;
      pl.moveSpeed = d[7] || 1;
    }
    return pl;
  });

  const spikes = L.spikes.map(d => new Spike(W * d[0], H * d[1], W * d[2], H * d[3]));
  const orbs = L.orbs.map(d => new Orb(W * d[0], H * d[1]));
  const wells = (L.wells || []).map(d => new GravityWell(W * d[0], H * d[1], d[2], d[3]));
  const winds = (L.winds || []).map(d => new WindZone(W * d[0], H * d[1], W * d[2], H * d[3], d[4], d[5], d[6]));
  const portal = new Portal(W * L.goal[0], H * L.goal[1]);

  // New obstacle types: lasers
  const customLasers = [];
  if (L.lasers) {
    for (const ld of L.lasers) {
      customLasers.push(new LaserBeam(W * ld[0], H * ld[1], W * ld[2], H * ld[3], ld[4] || 1.5, ld[5] || 1.0, ld[6] || 0));
    }
  }
  if (L.dailyLasers) {
    for (const dl of L.dailyLasers) {
      customLasers.push(new LaserBeam(W * dl.x, H * dl.y, W * dl.w, H * dl.h, dl.onTime, dl.offTime, dl.delay || 0));
    }
  }

  // New obstacle types: teleport portals
  const customTeleports = [];
  if (L.teleports) {
    for (const td of L.teleports) {
      customTeleports.push(new TeleportPortal(W * td[0], H * td[1], W * td[2], H * td[3], td[4], td[5]));
    }
  }
  if (L.dailyTeleports) {
    for (const dt2 of L.dailyTeleports) {
      customTeleports.push(new TeleportPortal(W * dt2.x1, H * dt2.y1, W * dt2.x2, H * dt2.y2));
    }
  }

  // New obstacle types: smooth moving platforms
  const customMovingPlatforms = [];
  if (L.movingPlatforms) {
    for (const mp of L.movingPlatforms) {
      customMovingPlatforms.push(new MovingPlatformHV(W * mp[0], H * mp[1], W * mp[2], H * mp[3], mp[4], (mp[4] === 'h' ? W : H) * mp[5], mp[6] || 1));
    }
  }
  if (L.dailyMoving) {
    for (const dm of L.dailyMoving) {
      customMovingPlatforms.push(new MovingPlatformHV(W * dm.x, H * dm.y, W * dm.w, H * dm.h, dm.dir, (dm.dir === 'h' ? W : H) * dm.range, dm.speed));
    }
  }

  sessionNearMisses = 0;

  gs = {
    player: p, platforms, spikes, orbs, portal, wells, winds,
    customLasers, customTeleports, customMovingPlatforms,
    time: 0, orbsCollected: 0, totalOrbs: orbs.length,
    dead: false, won: false,
    deathCount: 0,
    btns: {},
    levelStartTime: performance.now(),
    isDaily: !!levelData, isEditor: false
  };

  combo = 0; comboTimer = 0;
  particles = [];
  floatingTexts = [];
  speedLines = [];
  screen = 'game';
  screenShake = 0;
  screenFlash = 0;
  deathTimer = 0;
  nearMissTimer = 0;
  slowMo = 0;
  cameraZoom = 1;
  cameraZoomTarget = 1;
  currentAccent = (levelColors[index] || levelColors[0]).accent;
  chromaAberration = 0;
  vignetteIntensity = 0;

  ensureAudio();
  startMusic();
}

// ============================================================
// GAME UPDATE
// ============================================================
function updateGame() {
  if (gs.won) return;
  
  if (gs.dead) {
    deathTimer -= dt;
    updateParticles();
    screenShake *= 0.9;
    if (deathTimer <= 0) startLevel(lvl);
    return;
  }
  
  gs.time += dt;
  const p = gs.player;
  p.update();
  
  // Combo timer
  if (comboTimer > 0) {
    comboTimer -= dt;
    if (comboTimer <= 0) combo = 0;
  }
  
  // Near miss cooldown
  if (nearMissTimer > 0) nearMissTimer -= dt;
  
  // Update objects
  gs.platforms.forEach(pl => pl.update());
  gs.spikes.forEach(s => s.update());
  gs.orbs.forEach(o => o.update());
  gs.portal.update();
  gs.wells.forEach(w => w.update());
  if (gs.winds) gs.winds.forEach(w => w.update());
  // Update new obstacle types
  if (gs.customLasers) gs.customLasers.forEach(l => l.update());
  if (gs.customTeleports) gs.customTeleports.forEach(t => t.update());
  if (gs.customMovingPlatforms) gs.customMovingPlatforms.forEach(m => m.update());

  // Gravity wells
  gs.wells.forEach(w => w.applyForce(p));
  // Wind zones
  if (gs.winds) gs.winds.forEach(w => w.applyForce(p));

  // Platform collisions
  gs.platforms.forEach(pl => pl.handleCollision(p));
  // Moving platform collisions (new)
  if (gs.customMovingPlatforms) gs.customMovingPlatforms.forEach(m => m.handleCollision(p));
  // Teleport portal checks
  if (gs.customTeleports) gs.customTeleports.forEach(t => t.check(p));
  
  // Orb collection
  gs.orbs.forEach(o => {
    if (o.check(p)) {
      gs.orbsCollected++;
      combo++;
      comboTimer = 2.5;
      sfxCollect();
      if (combo > 1) {
        sfxCombo();
        addFloatingText(o.x, o.y - 20 * S, `${combo}x COMBO!`, '#ffd700', 22 + combo * 2);
        // Combo speed boost
        p.vx *= 1 + combo * 0.05;
        cameraZoomTarget = 1 + combo * 0.01;
        setTimeout(() => { cameraZoomTarget = 1; }, 300);
      }
      const points = 10 * combo;
      addFloatingText(o.x, o.y, `+${points}`, currentAccent, 16);
      screenShake = Math.max(screenShake, 3 + combo * 1.5);
      slowMo = 0.08; // tiny freeze frame on collect
      // Enhanced coin collect FX
      coinCollectBurst(o.x, o.y, o.color);
      chromaAberration = Math.max(chromaAberration, combo * 0.8);
    }
  });
  
  // Activate portal
  const wasActive = gs.portal.active;
  gs.portal.active = gs.orbsCollected >= gs.totalOrbs;
  if (gs.portal.active && !wasActive) {
    // Portal activation fanfare
    emit(gs.portal.x, gs.portal.y, 25, '#ffd700', 4, 0, { shape: 'circle' });
    screenShake = 6;
    screenFlash = 0.2;
    screenFlashColor = '#ffd700';
    addFloatingText(gs.portal.x, gs.portal.y - 30 * S, 'PORTAL OPEN!', '#ffd700', 18);
    tone(880, 0.2, 'sine', 0.15);
    tone(1100, 0.15, 'sine', 0.1, 0.1);
  }
  if (gs.portal.active) {
    emitTrail(gs.portal.x + (Math.random()-0.5) * 30 * S, 
              gs.portal.y + (Math.random()-0.5) * 30 * S, '#ffd700');
  }
  
  // Spike check
  for (const s of gs.spikes) {
    if (s.check(p)) { killPlayer(); return; }
    // Near miss - dramatic slow-mo moment
    if (nearMissTimer <= 0 && s.nearMiss(p)) {
      nearMissTimer = 0.5;
      sfxNearMiss();
      nearMissJuice(p.x, p.y);
      sessionNearMisses++;
      totalNearMisses++;
      saveNearMisses();
      addFloatingText(p.x, p.y - 25 * S, 'CLOSE!', '#ff4488', 16);
      emitSpark(p.x, p.y, '#ff4488', 5);
      screenShake = Math.max(screenShake, 4);
    }
  }

  // Laser beam check
  if (gs.customLasers) {
    for (const l of gs.customLasers) {
      if (l.check(p)) { killPlayer(); return; }
      if (nearMissTimer <= 0 && l.nearMiss(p)) {
        nearMissTimer = 0.5;
        sfxNearMiss();
        nearMissJuice(p.x, p.y);
        sessionNearMisses++;
        totalNearMisses++;
        saveNearMisses();
        addFloatingText(p.x, p.y - 25 * S, 'CLOSE!', '#ff4488', 16);
      }
    }
  }
  
  // Out of bounds
  if (p.x < -50 || p.x > W + 50 || p.y < -80 || p.y > H + 80) {
    killPlayer(); return;
  }
  
  // Win
  if (gs.portal.check(p)) {
    gs.won = true;
    winLevel();
    return;
  }
  
  updateParticles();
  screenShake *= 0.85;
  if (screenFlash > 0) screenFlash -= dt * 3;
}

function killPlayer() {
  gs.dead = true;
  gs.deathCount++;
  sfxDeath();
  screenFlash = 0.5;
  screenFlashColor = '#ff0044';
  slowMo = 0.5; // dramatic slow-mo
  cameraZoomTarget = 1.2; // zoom in on death
  setTimeout(() => { cameraZoomTarget = 1; }, 700);

  // Enhanced death juice system
  deathJuice();

  // Original death particles too
  emit(gs.player.x, gs.player.y, 45, '#ff0064', 7, 0.1, { shape: 'rect' });
  emit(gs.player.x, gs.player.y, 25, currentAccent, 5, 0.08, { shape: 'circle' });
  emit(gs.player.x, gs.player.y, 15, '#ffffff', 4, 0.05, { size: 2, shape: 'circle' });
  // Shockwave ring
  emit(gs.player.x, gs.player.y, 20, '#ff4488', 8, 0, { shape: 'circle', size: 1.5 });
  gs.player.alive = false;
  deathTimer = 1.2;
}

function winLevel() {
  const time = gs.time;
  const L = gs.isDaily ? { stars: [20, 14, 9], name: 'Daily Challenge' } : LEVELS[lvl];
  let stars = 1;
  if (time <= L.stars[1]) stars = 2;
  if (time <= L.stars[0]) stars = 3;

  gs.victoryStars = stars;
  gs.victoryTime = time;
  victoryAnimTime = 0;

  if (!gs.isDaily && (!progress[lvl] || progress[lvl].stars < stars)) {
    progress[lvl] = { completed: true, stars, time };
    saveProgress();
    calcTotalStars();
  } else if (!gs.isDaily && progress[lvl] && time < progress[lvl].time) {
    progress[lvl].time = time;
    saveProgress();
  }
  
  // Score calculation
  const baseScore = 100 + lvl * 50;
  const timeBonus = Math.max(0, Math.floor((L.stars[0] * 2 - time) * 10));
  const deathPenalty = gs.deathCount * 20;
  const levelScore = Math.max(10, baseScore + timeBonus - deathPenalty + stars * 50);
  gs.levelScore = levelScore;
  totalScore += levelScore;
  saveTotalScore();
  
  // Save daily challenge completion
  if (gs.isDaily) {
    try { localStorage.setItem('gflip3_daily', JSON.stringify({ seed: getDailySeed(), time, stars })); } catch(e) {}
    dailyChallengeCompleted = true;
  }

  sfxWin();
  screenFlash = 0.4;
  screenFlashColor = '#ffd700';
  slowMo = 0.6;
  cameraZoomTarget = 1.12;
  setTimeout(() => { cameraZoomTarget = 1; }, 900);

  // Enhanced win juice
  winJuice();

  // Record high score with date
  const levelIdx = gs.isDaily ? -1 : lvl;
  addHighScore(levelIdx, levelScore, time, stars, gs.deathCount);

  // Big win burst (original)
  for (let i = 0; i < 5; i++) {
    setTimeout(() => {
      emit(gs.portal.x + (Math.random()-0.5) * 60 * S,
           gs.portal.y + (Math.random()-0.5) * 60 * S,
           12, '#ffd700', 4, 0.1, { shape: 'circle' });
    }, i * 100);
  }

  setTimeout(() => { screen = 'victory'; }, 700);
}

// ============================================================
// GAME DRAW
// ============================================================
function drawGame() {
  X.save();
  if (screenShake > 0.5) {
    X.translate(
      (Math.random() - 0.5) * screenShake * S,
      (Math.random() - 0.5) * screenShake * S
    );
  }
  
  gs.wells.forEach(w => w.draw());
  if (gs.winds) gs.winds.forEach(w => w.draw());
  gs.platforms.forEach(pl => pl.draw());
  // Draw new obstacle types
  if (gs.customMovingPlatforms) gs.customMovingPlatforms.forEach(m => m.draw());
  if (gs.customLasers) gs.customLasers.forEach(l => l.draw());
  if (gs.customTeleports) gs.customTeleports.forEach(t => t.draw());
  gs.spikes.forEach(s => s.draw());
  gs.orbs.forEach(o => o.draw());
  gs.portal.draw();
  gs.player.draw();
  drawParticles();
  
  X.restore();
  
  // Screen flash
  if (screenFlash > 0) {
    X.save();
    X.globalAlpha = screenFlash * 0.4;
    X.fillStyle = screenFlashColor;
    X.fillRect(0, 0, W, H);
    X.restore();
  }

  // Enhanced juice effects
  drawVignette();
  drawChromaticAberration();

  // HUD
  drawHUD();
  
  // Tutorial hints
  if (lvl === 0 && gs.time < 4 && !gs.dead) {
    X.save();
    const a = Math.max(0, 1 - gs.time / 4);
    X.globalAlpha = a;
    
    // Animated hand tap icon
    const handY = H * 0.7 + Math.sin(gt * 4) * 8 * S;
    X.font = `${28 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('üëÜ', W/2, handY);
    
    X.fillStyle = '#fff';
    X.font = `bold ${20 * S}px sans-serif`;
    X.shadowColor = '#00ffff';
    X.shadowBlur = 10 * S;
    X.fillText('TAP TO FLIP!', W/2, H * 0.7 + 30 * S);
    X.restore();
  }
  
  // Death overlay
  if (gs.dead) {
    X.save();
    const a = Math.min(0.5, (1.0 - deathTimer) * 0.7);
    X.fillStyle = `rgba(200,0,40,${a * 0.2})`;
    X.fillRect(0, 0, W, H);
    
    // "Oops" text
    if (deathTimer < 0.7) {
      X.globalAlpha = Math.min(1, (0.7 - deathTimer) * 3);
      X.fillStyle = '#ff4466';
      X.font = `bold ${24 * S}px sans-serif`;
      X.textAlign = 'center';
      X.shadowColor = '#ff0044';
      X.shadowBlur = 10 * S;
      const texts = ['OOPS!', 'SPLAT!', 'NOPE!', 'OOF!', 'YIKES!'];
      X.fillText(texts[gs.deathCount % texts.length], W/2, H * 0.45);
    }
    X.restore();
  }
}

function drawHUD() {
  X.save();
  
  // Semi-transparent HUD background
  X.fillStyle = 'rgba(0,0,0,0.3)';
  X.fillRect(0, 0, W, 55 * S);
  
  // Level name
  X.fillStyle = 'rgba(255,255,255,0.7)';
  X.font = `${13 * S}px sans-serif`;
  X.textAlign = 'left';
  const levelLabel = gs.isDaily ? '‚òÄ Daily Challenge' : `${lvl + 1}. ${LEVELS[lvl].name}`;
  X.fillText(levelLabel, 12 * S, 20 * S);
  
  // Orb counter with icons
  const orbFull = gs.orbsCollected >= gs.totalOrbs;
  X.fillStyle = orbFull ? '#ffd700' : '#4488ff';
  X.font = `bold ${16 * S}px sans-serif`;
  X.shadowColor = orbFull ? '#ffd700' : '#4488ff';
  X.shadowBlur = orbFull ? 8 * S : 0;
  
  // Draw orb icons
  for (let i = 0; i < gs.totalOrbs; i++) {
    const ox = 12 * S + i * 20 * S;
    const oy = 38 * S;
    if (i < gs.orbsCollected) {
      X.fillStyle = '#4488ff';
      X.shadowColor = '#4488ff';
      X.shadowBlur = 6 * S;
      X.beginPath();
      X.arc(ox, oy, 5 * S, 0, Math.PI * 2);
      X.fill();
      // Highlight
      X.fillStyle = '#fff';
      X.shadowBlur = 0;
      X.beginPath();
      X.arc(ox - 1.5 * S, oy - 1.5 * S, 1.5 * S, 0, Math.PI * 2);
      X.fill();
    } else {
      X.strokeStyle = 'rgba(68,136,255,0.3)';
      X.lineWidth = 1.5 * S;
      X.shadowBlur = 0;
      X.beginPath();
      X.arc(ox, oy, 5 * S, 0, Math.PI * 2);
      X.stroke();
    }
  }
  
  // Timer
  X.fillStyle = '#fff';
  X.textAlign = 'right';
  X.font = `${15 * S}px monospace`;
  X.shadowBlur = 0;
  X.fillText(`${gs.time.toFixed(1)}s`, W - 12 * S, 20 * S);
  
  // Star time targets
  const L = gs.isDaily ? { stars: [20, 14, 9] } : LEVELS[lvl];
  X.font = `${10 * S}px sans-serif`;
  X.fillStyle = gs.time <= L.stars[0] ? '#ffd700' : 'rgba(255,215,0,0.3)';
  X.fillText(`‚≠ê‚≠ê‚≠ê < ${L.stars[0]}s`, W - 12 * S, 36 * S);
  
  // Gravity indicator
  X.globalAlpha = 0.5;
  X.fillStyle = '#00ffff';
  X.font = `${11 * S}px sans-serif`;
  X.fillText(gs.player.gravDir === 1 ? '‚ñº DOWN' : '‚ñ≤ UP', W - 12 * S, 50 * S);
  
  // Combo display
  if (combo > 1 && comboTimer > 0) {
    X.globalAlpha = Math.min(1, comboTimer);
    X.fillStyle = '#ffd700';
    X.font = `bold ${22 * S}px sans-serif`;
    X.textAlign = 'center';
    X.shadowColor = '#ffd700';
    X.shadowBlur = 12 * S;
    const comboScale = 1 + Math.max(0, (comboTimer - 1.5)) * 3;
    X.save();
    X.translate(W/2, 75 * S);
    X.scale(comboScale, comboScale);
    X.fillText(`${combo}x COMBO!`, 0, 0);
    X.restore();
  }
  
  // Death counter (subtle)
  if (gs.deathCount > 0) {
    X.globalAlpha = 0.4;
    X.fillStyle = '#ff4466';
    X.font = `${10 * S}px sans-serif`;
    X.textAlign = 'left';
    X.shadowBlur = 0;
    X.fillText(`üíÄ ${gs.deathCount}`, 12 * S, 52 * S);
  }
  
  X.restore();
}

// ============================================================
// MENU
// ============================================================
function drawMenu() {
  menuPulse += dt;
  
  // Floating character
  const orbY = H * 0.18 + Math.sin(gt * 1.5) * 12 * S;
  const orbX = W/2 + Math.sin(gt * 0.7) * 8 * S;
  
  X.save();
  // Big glow
  const bigGrad = X.createRadialGradient(orbX, orbY, 0, orbX, orbY, 60 * S);
  bigGrad.addColorStop(0, 'rgba(0,255,255,0.15)');
  bigGrad.addColorStop(1, 'rgba(0,255,255,0)');
  X.fillStyle = bigGrad;
  X.beginPath(); X.arc(orbX, orbY, 60 * S, 0, Math.PI * 2); X.fill();
  
  // Character
  const charGrad = X.createRadialGradient(orbX - 5*S, orbY - 5*S, 0, orbX, orbY, 22*S);
  charGrad.addColorStop(0, '#88ffff');
  charGrad.addColorStop(0.5, '#00ffff');
  charGrad.addColorStop(1, '#00aacc');
  X.fillStyle = charGrad;
  X.shadowColor = '#00ffff'; X.shadowBlur = 30 * S;
  X.beginPath(); X.arc(orbX, orbY, 22 * S, 0, Math.PI * 2); X.fill();
  
  // Eyes
  X.fillStyle = '#fff'; X.shadowBlur = 0;
  X.beginPath();
  X.arc(orbX - 6*S, orbY - 3*S, 4*S, 0, Math.PI*2);
  X.arc(orbX + 6*S, orbY - 3*S, 4*S, 0, Math.PI*2);
  X.fill();
  X.fillStyle = '#111';
  X.beginPath();
  X.arc(orbX - 5*S, orbY - 3*S, 2.5*S, 0, Math.PI*2);
  X.arc(orbX + 7*S, orbY - 3*S, 2.5*S, 0, Math.PI*2);
  X.fill();
  X.fillStyle = '#fff';
  X.beginPath();
  X.arc(orbX - 6.5*S, orbY - 4.5*S, 1.2*S, 0, Math.PI*2);
  X.arc(orbX + 5.5*S, orbY - 4.5*S, 1.2*S, 0, Math.PI*2);
  X.fill();
  
  // Smile
  X.strokeStyle = '#005566';
  X.lineWidth = 1.5 * S;
  X.beginPath();
  X.arc(orbX, orbY + 1*S, 6*S, 0.1 * Math.PI, 0.9 * Math.PI);
  X.stroke();
  X.restore();
  
  // Title with slight animation
  const titleY = H * 0.35;
  drawNeonText('GRAVITY', W/2, titleY, 46, '#00ffff');
  drawNeonText('FLIP', W/2, titleY + 52 * S, 46, '#00ffff');
  
  // Subtitle
  X.save();
  X.fillStyle = 'rgba(255,255,255,0.45)';
  X.font = `${13 * S}px sans-serif`;
  X.textAlign = 'center';
  X.fillText('Tap to flip gravity ‚Ä¢ Collect orbs ‚Ä¢ Reach the portal', W/2, titleY + 85 * S);
  X.restore();
  
  const bw = 200 * S, bh = 48 * S;
  const btnY = H * 0.55;
  const btnGap = 10 * S;
  gs.btns = gs.btns || {};
  gs.btns.start = drawBtn(W/2 - bw/2, btnY, bw, bh, '‚ñ∂  PLAY');
  gs.btns.select = drawBtn(W/2 - bw/2, btnY + bh + btnGap, bw, bh, 'üìã  LEVELS', false);
  gs.btns.daily = drawBtn(W/2 - bw/2, btnY + (bh + btnGap) * 2, bw, bh, '‚òÄ  DAILY', false);
  gs.btns.editor = drawBtn(W/2 - bw/2, btnY + (bh + btnGap) * 3, bw, bh, 'üîß  EDITOR', false);

  // Small buttons row
  const smallW = 95 * S, smallH = 36 * S;
  gs.btns.stats = drawBtn(W/2 - smallW - 5 * S, btnY + (bh + btnGap) * 4, smallW, smallH, 'STATS', false);
  gs.btns.leaders = drawBtn(W/2 + 5 * S, btnY + (bh + btnGap) * 4, smallW, smallH, 'TOP 10', false);

  // Stars and score display
  if (bestTotalStars > 0 || totalScore > 0) {
    X.save();
    X.fillStyle = '#ffd700';
    X.font = `bold ${13 * S}px sans-serif`;
    X.textAlign = 'center';
    X.shadowColor = '#ffd700';
    X.shadowBlur = 6 * S;
    X.fillText(`‚≠ê ${bestTotalStars} / ${LEVELS.length * 3}`, W/2, H * 0.93);
    if (totalScore > 0) {
      X.fillStyle = '#00ffff';
      X.shadowColor = '#00ffff';
      X.fillText(`Score: ${totalScore}`, W/2, H * 0.97);
    }
    X.restore();
  }
}

// ============================================================
// STATS SCREEN
// ============================================================
function drawStatsScreen() {
  drawNeonText('STATISTICS', W/2, 50 * S, 26, '#00ffff');

  const stats = getStats();
  const items = [
    { label: 'Levels Completed', value: `${stats.levelsCompleted} / ${LEVELS.length}` },
    { label: 'Total Stars', value: `${stats.totalStars} / ${LEVELS.length * 3}` },
    { label: 'Total Score', value: `${stats.totalScore}` },
    { label: 'Near Misses', value: `${stats.totalNearMisses}` },
  ];

  const startY = 100 * S;
  items.forEach((item, i) => {
    const y = startY + i * 55 * S;
    X.save();
    X.fillStyle = 'rgba(0,255,255,0.06)';
    X.beginPath();
    X.roundRect(W * 0.1, y, W * 0.8, 42 * S, 6 * S);
    X.fill();
    X.strokeStyle = 'rgba(0,255,255,0.15)';
    X.lineWidth = 1 * S;
    X.stroke();

    X.fillStyle = 'rgba(255,255,255,0.6)';
    X.font = `${14 * S}px sans-serif`;
    X.textAlign = 'left';
    X.fillText(item.label, W * 0.15, y + 27 * S);

    X.fillStyle = '#00ffff';
    X.font = `bold ${16 * S}px sans-serif`;
    X.textAlign = 'right';
    X.fillText(item.value, W * 0.85, y + 27 * S);
    X.restore();
  });

  // Best times
  if (stats.bestTimes.length > 0) {
    const btY = startY + items.length * 55 * S + 20 * S;
    X.save();
    X.fillStyle = 'rgba(255,255,255,0.5)';
    X.font = `bold ${13 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('BEST TIMES', W/2, btY);
    stats.bestTimes.forEach((bt, i) => {
      if (i >= 8) return;
      const ty = btY + 22 * S + i * 22 * S;
      X.fillStyle = 'rgba(255,255,255,0.4)';
      X.font = `${11 * S}px sans-serif`;
      X.textAlign = 'left';
      X.fillText(`${bt.level + 1}. ${LEVELS[bt.level].name}`, W * 0.15, ty);
      X.textAlign = 'right';
      X.fillStyle = '#ffd700';
      X.fillText(`${bt.time.toFixed(1)}s`, W * 0.85, ty);
    });
    X.restore();
  }

  gs.btns = gs.btns || {};
  gs.btns.back = drawBtn(W/2 - 50 * S, H - 60 * S, 100 * S, 42 * S, '‚Üê BACK', false);
}

// ============================================================
// LEADERBOARD SCREEN
// ============================================================
function drawLeaderboardScreen() {
  drawNeonText('TOP 20', W/2, 50 * S, 26, '#ffd700');

  if (leaderboard.length === 0) {
    X.save();
    X.fillStyle = 'rgba(255,255,255,0.4)';
    X.font = `${14 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('No scores yet! Complete a level.', W/2, H * 0.4);
    X.restore();
  } else {
    const startY = 85 * S;
    leaderboard.forEach((entry, i) => {
      if (i >= 15) return;
      const y = startY + i * 28 * S;
      const isTop3 = i < 3;
      X.save();
      if (isTop3) {
        X.fillStyle = ['rgba(255,215,0,0.08)', 'rgba(192,192,192,0.06)', 'rgba(205,127,50,0.05)'][i];
        X.fillRect(W * 0.08, y - 8 * S, W * 0.84, 26 * S);
      }
      // Rank
      X.fillStyle = isTop3 ? ['#ffd700', '#c0c0c0', '#cd7f32'][i] : 'rgba(255,255,255,0.4)';
      X.font = `bold ${12 * S}px sans-serif`;
      X.textAlign = 'left';
      X.fillText(`${i + 1}.`, W * 0.1, y + 6 * S);
      // Name
      X.fillStyle = '#fff';
      X.font = `bold ${13 * S}px monospace`;
      X.fillText(entry.name || '???', W * 0.2, y + 6 * S);
      // Score
      X.fillStyle = '#00ffff';
      X.font = `${13 * S}px sans-serif`;
      X.textAlign = 'right';
      X.fillText(`${entry.score}`, W * 0.7, y + 6 * S);
      // Level
      X.fillStyle = 'rgba(255,255,255,0.3)';
      X.font = `${10 * S}px sans-serif`;
      X.fillText(`Lv.${entry.level + 1}`, W * 0.9, y + 6 * S);
      X.restore();
    });
  }

  gs.btns = gs.btns || {};
  gs.btns.back = drawBtn(W/2 - 50 * S, H - 60 * S, 100 * S, 42 * S, '‚Üê BACK', false);
}

// ============================================================
// INITIALS ENTRY SCREEN
// ============================================================
function drawInitialsEntry() {
  X.save();
  X.fillStyle = 'rgba(0,0,0,0.92)';
  X.fillRect(0, 0, W, H);
  X.restore();

  drawNeonText('NEW HIGH SCORE!', W/2, H * 0.2, 22, '#ffd700');

  X.save();
  X.fillStyle = '#00ffff';
  X.font = `bold ${28 * S}px sans-serif`;
  X.textAlign = 'center';
  X.fillText(`${initialsScore}`, W/2, H * 0.32);
  X.restore();

  // Initials boxes
  X.save();
  X.fillStyle = 'rgba(255,255,255,0.5)';
  X.font = `${14 * S}px sans-serif`;
  X.textAlign = 'center';
  X.fillText('Enter your initials:', W/2, H * 0.42);

  for (let i = 0; i < 3; i++) {
    const bx = W/2 + (i - 1) * 50 * S;
    const by = H * 0.48;
    const bw = 40 * S, bhh = 50 * S;

    X.fillStyle = i === initialsCursor ? 'rgba(0,255,255,0.15)' : 'rgba(255,255,255,0.05)';
    X.beginPath();
    X.roundRect(bx - bw/2, by, bw, bhh, 6 * S);
    X.fill();
    X.strokeStyle = i === initialsCursor ? '#00ffff' : 'rgba(255,255,255,0.2)';
    X.lineWidth = 2 * S;
    X.stroke();

    const ch = initialsText[i] || (i === initialsCursor ? '_' : '');
    X.fillStyle = '#fff';
    X.font = `bold ${28 * S}px monospace`;
    X.textAlign = 'center';
    if (i === initialsCursor && !initialsText[i]) {
      X.globalAlpha = 0.4 + Math.sin(gt * 5) * 0.3;
    }
    X.fillText(ch, bx, by + 35 * S);
    X.globalAlpha = 1;
  }
  X.restore();

  // Letter grid
  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const cols = 7;
  const gridStartY = H * 0.62;
  const cellSize = 38 * S;
  const gridW = cols * cellSize;
  const gridStartX = W/2 - gridW/2;

  gs.btns = gs.btns || {};
  gs.btns.letterBtns = [];

  for (let i = 0; i < letters.length; i++) {
    const col = i % cols;
    const row = Math.floor(i / cols);
    const lx = gridStartX + col * cellSize;
    const ly = gridStartY + row * cellSize;

    X.save();
    X.fillStyle = 'rgba(0,255,255,0.06)';
    X.beginPath();
    X.roundRect(lx + 2 * S, ly + 2 * S, cellSize - 4 * S, cellSize - 4 * S, 4 * S);
    X.fill();
    X.fillStyle = '#fff';
    X.font = `bold ${16 * S}px monospace`;
    X.textAlign = 'center';
    X.fillText(letters[i], lx + cellSize/2, ly + cellSize/2 + 6 * S);
    X.restore();

    gs.btns.letterBtns.push({ x: lx, y: ly, w: cellSize, h: cellSize, letter: letters[i] });
  }

  // Done / Back buttons
  const doneBw = 100 * S;
  gs.btns.initialsDone = drawBtn(W/2 - doneBw - 8 * S, H - 65 * S, doneBw, 42 * S, 'SAVE');
  gs.btns.initialsSkip = drawBtn(W/2 + 8 * S, H - 65 * S, doneBw, 42 * S, 'SKIP', false);
}

// ============================================================
// LEVEL SELECT
// ============================================================
function drawSelect() {
  drawNeonText('SELECT LEVEL', W/2, 50 * S, 26, '#00ffff');
  
  const cols = 4;
  const boxSz = Math.min(72 * S, (W - 60 * S) / cols);
  const gap = 12 * S;
  const startX = W/2 - (cols * (boxSz + gap) - gap) / 2;
  const startY = 80 * S;
  
  gs.btns = gs.btns || {};
  gs.btns.levelBoxes = [];
  
  for (let i = 0; i < LEVELS.length; i++) {
    const col = i % cols;
    const row = Math.floor(i / cols);
    const x = startX + col * (boxSz + gap);
    const y = startY + row * (boxSz + gap + 5 * S);
    
    const unlocked = i === 0 || (progress[i - 1] && progress[i - 1].completed);
    const prog = progress[i];
    
    X.save();
    const r = 4 * S;
    X.beginPath();
    X.roundRect(x, y, boxSz, boxSz, r);
    
    if (unlocked) {
      X.fillStyle = prog && prog.completed ? 'rgba(0,255,255,0.12)' : 'rgba(0,255,255,0.04)';
      X.fill();
      X.strokeStyle = prog && prog.completed ? '#00ddff' : '#006688';
      X.lineWidth = 2 * S;
      if (prog && prog.completed) { X.shadowColor = '#00ffff'; X.shadowBlur = 6 * S; }
      X.stroke();
    } else {
      X.fillStyle = 'rgba(30,30,40,0.4)';
      X.fill();
      X.strokeStyle = '#222';
      X.lineWidth = 1 * S;
      X.stroke();
    }
    X.restore();
    
    // Number
    X.save();
    X.fillStyle = unlocked ? '#fff' : '#333';
    X.font = `bold ${18 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText(i + 1, x + boxSz/2, y + boxSz/2 - (prog && prog.completed ? 5 * S : 0));
    X.restore();
    
    // Stars
    if (prog && prog.completed) {
      X.save();
      X.font = `${10 * S}px sans-serif`;
      X.textAlign = 'center';
      for (let s = 0; s < 3; s++) {
        X.fillStyle = s < prog.stars ? '#ffd700' : 'rgba(255,255,255,0.15)';
        X.fillText(s < prog.stars ? '‚òÖ' : '‚òÜ', x + boxSz/2 + (s - 1) * 12 * S, y + boxSz - 7 * S);
      }
      X.restore();
    }
    
    if (!unlocked) {
      X.save();
      X.font = `${14 * S}px sans-serif`;
      X.textAlign = 'center';
      X.globalAlpha = 0.5;
      X.fillText('üîí', x + boxSz/2, y + boxSz - 10 * S);
      X.restore();
    }
    
    gs.btns.levelBoxes[i] = { x, y, w: boxSz, h: boxSz, unlocked };
  }
  
  gs.btns.back = drawBtn(W/2 - 50 * S, H - 60 * S, 100 * S, 42 * S, '‚Üê BACK', false);
}

// ============================================================
// VICTORY SCREEN
// ============================================================
function drawVictory() {
  victoryAnimTime += dt;
  
  X.save();
  X.fillStyle = 'rgba(0,0,0,0.88)';
  X.fillRect(0, 0, W, H);
  X.restore();
  
  // Confetti particles in background
  if (victoryAnimTime < 2) {
    for (let i = 0; i < 2; i++) {
      const colors = ['#ffd700', '#ff6b9d', '#00ffff', '#ff4444', '#44ff44'];
      emit(
        Math.random() * W, -10,
        1, colors[Math.floor(Math.random() * colors.length)],
        1, 0.12, { size: 3 + Math.random() * 3, shape: 'rect' }
      );
    }
  }
  updateParticles();
  drawParticles();
  
  const titleScale = Math.min(1, easeOutBack(Math.min(1, victoryAnimTime * 2)));
  X.save();
  X.translate(W/2, H * 0.13);
  X.scale(titleScale, titleScale);
  drawNeonText('LEVEL COMPLETE!', 0, 0, 28, '#ffd700');
  X.restore();
  
  const victoryLevelName = gs.isDaily ? 'Daily Challenge' : LEVELS[lvl].name;
  drawNeonText(victoryLevelName, W/2, H * 0.13 + 35 * S, 14, 'rgba(255,255,255,0.5)');
  
  // Stars with staggered pop-in
  const stars = gs.victoryStars || 1;
  for (let i = 0; i < 3; i++) {
    const sx = W/2 + (i - 1) * 55 * S;
    const sy = H * 0.26;
    const filled = i < stars;
    const starDelay = 0.3 + i * 0.25;
    const starProgress = Math.max(0, Math.min(1, (victoryAnimTime - starDelay) * 3));
    
    if (starProgress <= 0) continue;
    
    X.save();
    X.translate(sx, sy);
    const scale = filled ? easeOutElastic(starProgress) : starProgress;
    X.scale(scale, scale);
    X.font = `${34 * S}px sans-serif`;
    X.textAlign = 'center';
    if (filled) {
      X.shadowColor = '#ffd700';
      X.shadowBlur = 15 * S;
    }
    X.fillText(filled ? '‚≠ê' : '‚òÜ', 0, 0);
    X.restore();
  }
  
  // Stats
  const statsAlpha = Math.min(1, Math.max(0, (victoryAnimTime - 1) * 2));
  X.save();
  X.globalAlpha = statsAlpha;
  const cy = H * 0.38;

  // Stat boxes
  const statBoxW = W * 0.18;
  const statBoxH = 55 * S;
  const victoryStats = [
    { label: 'TIME', value: `${(gs.victoryTime || 0).toFixed(1)}s`, x: W * 0.15 },
    { label: 'DEATHS', value: `${gs.deathCount}`, x: W * 0.35 },
    { label: 'CLOSE', value: `${sessionNearMisses}`, x: W * 0.55 },
    { label: 'SCORE', value: `${gs.levelScore || 0}`, x: W * 0.75 },
  ];
  
  victoryStats.forEach((stat, i) => {
    X.fillStyle = 'rgba(255,255,255,0.05)';
    X.beginPath();
    X.roundRect(stat.x - statBoxW/2, cy - 10 * S, statBoxW, statBoxH, 6 * S);
    X.fill();
    
    X.fillStyle = 'rgba(255,255,255,0.4)';
    X.font = `${11 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText(stat.label, stat.x, cy + 5 * S);
    
    X.fillStyle = '#00ffff';
    X.font = `bold ${18 * S}px sans-serif`;
    X.fillText(stat.value, stat.x, cy + 30 * S);
  });
  X.restore();
  
  // Best time
  if (!gs.isDaily && progress[lvl] && progress[lvl].time < gs.victoryTime) {
    X.save();
    X.globalAlpha = statsAlpha * 0.5;
    X.fillStyle = '#888';
    X.font = `${11 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText(`Best: ${progress[lvl].time.toFixed(1)}s`, W/2, cy + statBoxH + 5 * S);
    X.restore();
  }
  
  // Buttons
  const btnAlpha = Math.min(1, Math.max(0, (victoryAnimTime - 1.3) * 2));
  if (btnAlpha > 0) {
    X.save();
    X.globalAlpha = btnAlpha;
    const bw = 130 * S, bh = 45 * S;
    const btnY = H * 0.62;
    gs.btns = gs.btns || {};
    gs.btns.replay = drawBtn(W/2 - bw - 10 * S, btnY, bw, bh, '‚Ü∫ RETRY', false);
    
    if (gs.isDaily) {
      gs.btns.next = drawBtn(W/2 + 10 * S, btnY, bw, bh, 'üè† MENU');
    } else if (lvl < LEVELS.length - 1) {
      gs.btns.next = drawBtn(W/2 + 10 * S, btnY, bw, bh, 'NEXT ‚Üí');
    } else {
      gs.btns.next = drawBtn(W/2 + 10 * S, btnY, bw, bh, 'üè† MENU');
    }
    
    gs.btns.share = drawBtn(W/2 - bw - 10 * S, btnY + bh + 12 * S, bw, 38 * S, 'üì§ SHARE', false);
    gs.btns.addScore = drawBtn(W/2 + 10 * S, btnY + bh + 12 * S, bw, 38 * S, 'üèÜ SAVE', false);
    X.restore();
  }

  // Daily challenge badge
  if (gs.isDaily) {
    X.save();
    X.fillStyle = '#ffd700';
    X.font = `bold ${12 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('‚òÄ DAILY CHALLENGE COMPLETE!', W/2, H * 0.10);
    X.restore();
  }
}

function shareResult() {
  const stars = gs.victoryStars || 1;
  const levelName = gs.isDaily ? 'Daily Challenge' : `Level ${lvl + 1}: ${LEVELS[lvl].name}`;
  const text = `üîÆ Gravity Flip - ${levelName}\n${'‚≠ê'.repeat(stars)}${'‚òÜ'.repeat(3 - stars)} in ${(gs.victoryTime || 0).toFixed(1)}s\nCan you beat my time?`;
  if (navigator.share) {
    navigator.share({ title: 'Gravity Flip', text }).catch(() => {});
  } else if (navigator.clipboard) {
    navigator.clipboard.writeText(text).then(() => {
      screenShake = 3;
      addFloatingText(W/2, H * 0.85, 'Copied!', '#00ffff', 14);
    });
  }
}

// ============================================================
// INPUT
// ============================================================
function handleTap(x, y) {
  ensureAudio();

  if (transAlpha > 0.1) return;

  // Initials entry screen
  if (enteringInitials) {
    if (gs.btns.letterBtns) {
      for (const btn of gs.btns.letterBtns) {
        if (hit(x, y, btn)) {
          sfxClick();
          if (initialsCursor < 3) {
            initialsText += btn.letter;
            initialsCursor++;
          }
          if (initialsCursor >= 3) {
            // Auto-complete: save and return
          }
          return;
        }
      }
    }
    if (hit(x, y, gs.btns.initialsDone)) {
      sfxClick();
      const name = initialsText.padEnd(3, 'A');
      addLeaderboardEntry(name, initialsScore, initialsLevel);
      enteringInitials = false;
      initialsText = '';
      initialsCursor = 0;
      return;
    }
    if (hit(x, y, gs.btns.initialsSkip)) {
      sfxClick();
      enteringInitials = false;
      initialsText = '';
      initialsCursor = 0;
      return;
    }
    return;
  }

  if (screen === 'menu') {
    if (hit(x, y, gs.btns.start)) {
      sfxClick();
      let startLvl = 0;
      for (let i = 0; i < LEVELS.length; i++) {
        if (!progress[i] || !progress[i].completed) { startLvl = i; break; }
        if (i === LEVELS.length - 1) startLvl = 0;
      }
      startLevel(startLvl);
    }
    else if (hit(x, y, gs.btns.select)) { sfxClick(); screen = 'select'; gs.btns = {}; }
    else if (hit(x, y, gs.btns.daily)) {
      sfxClick();
      const dailyLevel = generateDailyChallenge_v2();
      startLevel(0, dailyLevel);
    }
    else if (hit(x, y, gs.btns.editor)) { sfxClick(); editorInit(); }
    else if (hit(x, y, gs.btns.stats)) { sfxClick(); screen = 'stats'; gs.btns = {}; }
    else if (hit(x, y, gs.btns.leaders)) { sfxClick(); screen = 'highscores'; highScoreScreen = 'global'; gs.btns = {}; }
  } else if (screen === 'select') {
    if (hit(x, y, gs.btns.back)) { sfxClick(); screen = 'menu'; gs.btns = {}; }
    else if (gs.btns.levelBoxes) {
      for (let i = 0; i < gs.btns.levelBoxes.length; i++) {
        const b = gs.btns.levelBoxes[i];
        if (b && b.unlocked && hit(x, y, b)) { sfxClick(); startLevel(i); break; }
      }
    }
  } else if (screen === 'editor') {
    handleEditorTap(x, y);
  } else if (screen === 'highscores') {
    if (hit(x, y, gs.btns.back)) { sfxClick(); screen = 'menu'; gs.btns = {}; }
    else if (gs.btns.hsLevel && hit(x, y, gs.btns.hsLevel)) { sfxClick(); highScoreScreen = 'level'; highScoreLevel = 0; gs.btns = {}; }
    else if (gs.btns.hsGlobal && hit(x, y, gs.btns.hsGlobal)) { sfxClick(); highScoreScreen = 'global'; gs.btns = {}; }
    else if (gs.btns.hsPrev && hit(x, y, gs.btns.hsPrev)) { sfxClick(); highScoreLevel = Math.max(0, highScoreLevel - 1); gs.btns = {}; }
    else if (gs.btns.hsNext && hit(x, y, gs.btns.hsNext)) { sfxClick(); highScoreLevel = Math.min(LEVELS.length - 1, highScoreLevel + 1); gs.btns = {}; }
  } else if (screen === 'stats' || screen === 'leaderboard') {
    if (hit(x, y, gs.btns.back)) { sfxClick(); screen = 'menu'; gs.btns = {}; }
  } else if (screen === 'game') {
    if (!gs.dead && !gs.won) {
      gs.player.flip();
    }
  } else if (screen === 'victory') {
    if (hit(x, y, gs.btns.replay)) {
      sfxClick();
      if (gs.isDaily) {
        const dailyLevel = generateDailyChallenge();
        startLevel(0, dailyLevel);
      } else {
        startLevel(lvl);
      }
    }
    else if (hit(x, y, gs.btns.next)) {
      sfxClick();
      if (gs.isDaily) { screen = 'menu'; gs.btns = {}; }
      else if (lvl < LEVELS.length - 1) startLevel(lvl + 1);
      else { screen = 'menu'; gs.btns = {}; }
    }
    else if (gs.btns.share && hit(x, y, gs.btns.share)) { sfxClick(); shareResult(); }
    else if (gs.btns.addScore && hit(x, y, gs.btns.addScore)) {
      sfxClick();
      enteringInitials = true;
      initialsText = '';
      initialsCursor = 0;
      initialsScore = gs.levelScore || 0;
      initialsLevel = lvl;
    }
  }
}

C.addEventListener('touchstart', e => {
  e.preventDefault();
  handleTap(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });

C.addEventListener('mousedown', e => {
  handleTap(e.clientX, e.clientY);
});

document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown') {
    e.preventDefault();
    if (screen === 'game' && !gs.dead && !gs.won) {
      gs.player.flip();
    }
  }
  if (e.code === 'KeyR' && screen === 'game') {
    startLevel(lvl);
  }
  if (e.code === 'Escape') {
    if (screen === 'game' || screen === 'victory') {
      screen = 'menu'; gs.btns = {};
    }
  }
});

// ============================================================
// MAIN LOOP
// ============================================================
function updateSpeedLines() {
  // Add new speed lines when in game
  if (screen === 'game' && !gs.dead && !gs.won && gs.player.alive) {
    const speed = Math.abs(gs.player.vx) + Math.abs(gs.player.vy);
    if (speed > 3 * S && Math.random() > 0.6) {
      speedLines.push({
        x: gs.player.x + W * 0.3 + Math.random() * W * 0.7,
        y: Math.random() * H,
        len: (30 + Math.random() * 60) * S,
        speed: (8 + Math.random() * 6) * S,
        life: 1, decay: 0.03 + Math.random() * 0.02,
        width: (1 + Math.random() * 2) * S
      });
    }
  }
  for (let i = speedLines.length - 1; i >= 0; i--) {
    const l = speedLines[i];
    const sld60 = dt * 60;
    l.x -= l.speed * sld60;
    l.life -= l.decay * sld60;
    if (l.life <= 0 || l.x + l.len < 0) speedLines.splice(i, 1);
  }
  if (speedLines.length > 30) speedLines.splice(0, speedLines.length - 30);
}

function drawSpeedLines() {
  X.save();
  for (const l of speedLines) {
    X.globalAlpha = l.life * 0.15;
    X.strokeStyle = currentAccent;
    X.lineWidth = l.width;
    X.beginPath();
    X.moveTo(l.x, l.y);
    X.lineTo(l.x + l.len, l.y);
    X.stroke();
  }
  X.restore();
}

function loop(time) {
  time /= 1000;
  dt = Math.min(time - lt, 0.05);
  lt = time;
  gt = time;
  
  // Apply slow motion
  if (slowMo > 0) {
    const realDt = dt; // save real dt before scaling
    dt *= 0.3;
    slowMo -= realDt; // decrement using real elapsed time
    if (slowMo < 0) slowMo = 0;
  }
  
  // Camera zoom lerp
  cameraZoom += (cameraZoomTarget - cameraZoom) * (1 - Math.pow(0.92, dt * 60));
  
  updateSpeedLines();
  
  X.clearRect(0, 0, W, H);
  drawBg();
  
  drawSpeedLines();
  
  if (screen === 'menu') drawMenu();
  else if (screen === 'select') drawSelect();
  else if (screen === 'stats') drawStatsScreen();
  else if (screen === 'leaderboard') drawLeaderboardScreen();
  else if (screen === 'game') {
    // Apply camera zoom
    if (cameraZoom !== 1) {
      X.save();
      const cx = gs.player.alive ? gs.player.x : W/2;
      const cy = gs.player.alive ? gs.player.y : H/2;
      X.translate(cx, cy);
      X.scale(cameraZoom, cameraZoom);
      X.translate(-cx, -cy);
    }
    updateGame(); drawGame();
    if (cameraZoom !== 1) X.restore();
  }
  else if (screen === 'victory') drawVictory();
  
  // Initials entry overlay
  if (enteringInitials) drawInitialsEntry();

  // Transition overlay
  if (transAlpha > 0.01 || transTarget > 0) {
    transAlpha += (transTarget - transAlpha) * 0.1;
    X.save();
    X.fillStyle = `rgba(0,0,0,${transAlpha})`;
    X.fillRect(0, 0, W, H);
    X.restore();
  }

  requestAnimationFrame(loop);
}

gs.btns = {};
requestAnimationFrame(loop);

</script>
</body>
</html>
