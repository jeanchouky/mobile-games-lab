<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#1a0033">
<title>Gravity Flip</title>
<meta name="description" content="Tap to flip gravity in this fast-paced procedural platformer">
<meta property="og:title" content="Gravity Flip ‚Äî Mobile Games Lab">
<meta property="og:description" content="Flip gravity and soar through procedurally generated worlds">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gravity Flip">
<meta name="twitter:description" content="Fast-paced gravity-flipping platformer in your browser">
<link rel="manifest" href="manifest.json">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a001a;touch-action:none;user-select:none;-webkit-user-select:none;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',system-ui,sans-serif}
canvas{display:block;width:100%;height:100%}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
'use strict';

// ============================================================
// GRAVITY FLIP ‚Äî Polished Mobile Platformer v2
// Tap anywhere to flip gravity. Collect orbs. Reach the portal.
// ============================================================

const C = document.getElementById('game');
const X = C.getContext('2d');

// --- GLOBALS ---
let W, H, S;
let gt = 0, dt = 0, lt = 0;
let screen = 'menu';
let lvl = 0;
let gs = {};
let particles = [];
let floatingTexts = [];
let screenShake = 0;
let screenFlash = 0;
let screenFlashColor = '#fff';
let combo = 0, comboTimer = 0;
let deathTimer = 0;
let transAlpha = 0, transTarget = 0, transCallback = null;
let starField = [];
let audioCtx = null, masterGain = null;
let musicOscs = [];
let bestTotalStars = 0;
let nearMissTimer = 0;
let bestRun = null; // ghost data
let menuPulse = 0;
let tapPromptAlpha = 1;
let victoryAnimTime = 0;
let slowMo = 0; // slow motion effect on death/win
let speedLines = [];
let cameraZoom = 1;
let cameraZoomTarget = 1;
let levelColors = [
  { accent: '#00ffff', bg1: '#0a001a', bg2: '#1a0033' },
  { accent: '#00ff88', bg1: '#001a0a', bg2: '#003320' },
  { accent: '#ff6644', bg1: '#1a0800', bg2: '#331500' },
  { accent: '#ff44aa', bg1: '#1a000a', bg2: '#330020' },
  { accent: '#ffaa00', bg1: '#1a0f00', bg2: '#332200' },
  { accent: '#b464ff', bg1: '#0f001a', bg2: '#200033' },
  { accent: '#44ddff', bg1: '#001018', bg2: '#002030' },
  { accent: '#ff4444', bg1: '#1a0000', bg2: '#330000' },
  { accent: '#66ff66', bg1: '#001a00', bg2: '#003300' },
  { accent: '#ffd700', bg1: '#1a1000', bg2: '#332800' },
  { accent: '#00ffff', bg1: '#0a001a', bg2: '#1a0033' },
  { accent: '#ff66ff', bg1: '#1a001a', bg2: '#330033' },
  { accent: '#44ff88', bg1: '#001a0a', bg2: '#003320' },
  { accent: '#ffaa44', bg1: '#1a0f00', bg2: '#332200' },
  { accent: '#ff2266', bg1: '#1a000a', bg2: '#330015' },
];
let currentAccent = '#00ffff';
let totalScore = 0;
try { const ts = localStorage.getItem('gflip3_score'); if (ts) totalScore = parseInt(ts) || 0; } catch(e) {}
function saveTotalScore() { try { localStorage.setItem('gflip3_score', totalScore.toString()); } catch(e) {} }

// Progress
let progress = {};
try { const s = localStorage.getItem('gflip3'); if (s) progress = JSON.parse(s); } catch(e) {}
function saveProgress() { try { localStorage.setItem('gflip3', JSON.stringify(progress)); } catch(e) {} }

function calcTotalStars() {
  bestTotalStars = 0;
  for (const k in progress) if (progress[k].stars) bestTotalStars += progress[k].stars;
}
calcTotalStars();

// Leaderboard
let leaderboard = {};
try { const lb = localStorage.getItem('gflip3_lb'); if (lb) leaderboard = JSON.parse(lb); } catch(e) {}
function saveLeaderboard() { try { localStorage.setItem('gflip3_lb', JSON.stringify(leaderboard)); } catch(e) {} }
function addLeaderboardEntry(levelId, time, stars, deaths) {
  if (!leaderboard[levelId]) leaderboard[levelId] = [];
  leaderboard[levelId].push({ time: +time.toFixed(2), stars, deaths, date: Date.now() });
  leaderboard[levelId].sort((a, b) => a.time - b.time);
  if (leaderboard[levelId].length > 10) leaderboard[levelId].length = 10;
  saveLeaderboard();
}

// Custom levels (editor)
let customLevels = [];
try { const cl = localStorage.getItem('gflip3_custom'); if (cl) customLevels = JSON.parse(cl); } catch(e) {}
function saveCustomLevels() { try { localStorage.setItem('gflip3_custom', JSON.stringify(customLevels)); } catch(e) {} }

// Infinite mode tracking
let infiniteLvl = 0;
let isInfiniteMode = false;
let isCustomLevel = false;
let customLevelIndex = -1;

// Editor state
let editor = {
  tool: 'platform', // platform, spike, orb, portal, bouncy, crumble, eraser
  elements: { platforms: [], spikes: [], orbs: [], portal: null },
  dragging: false, dragStart: null, dragEnd: null,
  scrollY: 0, selectedIndex: -1, selectedType: '',
  testMode: false
};

// --- RESIZE ---
function resize() {
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = window.innerWidth; H = window.innerHeight;
  C.width = W * dpr; C.height = H * dpr;
  C.style.width = W + 'px'; C.style.height = H + 'px';
  X.setTransform(dpr, 0, 0, dpr, 0, 0);
  S = Math.min(W / 400, H / 700);
  initStarField();
}
window.addEventListener('resize', resize);
resize();

function initStarField() {
  starField = [];
  for (let i = 0; i < 100; i++) {
    starField.push({
      x: Math.random() * W, y: Math.random() * H,
      size: (0.5 + Math.random() * 2) * S,
      speed: (0.1 + Math.random() * 0.3) * S,
      brightness: 0.3 + Math.random() * 0.7,
      twinkleSpeed: 1 + Math.random() * 3,
      layer: Math.random() < 0.3 ? 2 : 1 // parallax layers
    });
  }
}

// ============================================================
// AUDIO ‚Äî richer sound design
// ============================================================
function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.3;
    masterGain.connect(audioCtx.destination);
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function tone(freq, dur, type = 'sine', vol = 0.15, delay = 0) {
  if (!audioCtx) return;
  const t = audioCtx.currentTime + delay;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.setValueAtTime(vol, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur);
  o.connect(g); g.connect(masterGain);
  o.start(t); o.stop(t + dur);
}

function noise(dur, vol = 0.1) {
  if (!audioCtx) return;
  const bufferSize = audioCtx.sampleRate * dur;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);
  const src = audioCtx.createBufferSource();
  src.buffer = buffer;
  const g = audioCtx.createGain();
  const f = audioCtx.createBiquadFilter();
  f.type = 'bandpass'; f.frequency.value = 2000; f.Q.value = 1;
  g.gain.setValueAtTime(vol, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  src.connect(f); f.connect(g); g.connect(masterGain);
  src.start(); src.stop(audioCtx.currentTime + dur);
}

function sfxFlip() {
  tone(280, 0.06, 'square', 0.1);
  tone(420, 0.08, 'sine', 0.12, 0.02);
  tone(560, 0.04, 'sine', 0.06, 0.04);
}

function sfxCollect() {
  const base = 700 + combo * 100;
  tone(base, 0.12, 'sine', 0.2);
  tone(base * 1.25, 0.1, 'sine', 0.15, 0.04);
  tone(base * 1.5, 0.08, 'triangle', 0.1, 0.08);
  if (combo > 2) tone(base * 2, 0.06, 'sine', 0.08, 0.1);
}

function sfxDeath() {
  tone(200, 0.3, 'sawtooth', 0.2);
  tone(100, 0.4, 'sawtooth', 0.15, 0.1);
  tone(50, 0.5, 'square', 0.1, 0.2);
  noise(0.3, 0.08);
}

function sfxWin() {
  const notes = [523, 659, 784, 1047, 1319];
  notes.forEach((f, i) => {
    tone(f, 0.25, 'sine', 0.18, i * 0.08);
    tone(f * 0.5, 0.2, 'triangle', 0.06, i * 0.08);
  });
}

function sfxBounce() {
  tone(300 + Math.random() * 200, 0.08, 'triangle', 0.1);
  tone(600 + Math.random() * 200, 0.04, 'sine', 0.06, 0.02);
}

function sfxClick() { tone(900, 0.04, 'sine', 0.1); tone(1200, 0.03, 'sine', 0.05, 0.02); }

function sfxCombo() {
  const f = 1400 + combo * 120;
  tone(f, 0.15, 'sine', 0.12);
  tone(f * 1.5, 0.1, 'sine', 0.08, 0.05);
}

function sfxNearMiss() {
  tone(1600, 0.05, 'sine', 0.06);
  tone(2000, 0.03, 'sine', 0.04, 0.02);
}

function sfxCrumble() {
  noise(0.2, 0.06);
  tone(120, 0.15, 'square', 0.05);
}

// Adaptive music
let musicPlaying = false;
let musicGainNode = null;
let musicBeat = 0;
let musicBPM = 90;

function startMusic() {
  if (musicPlaying || !audioCtx) return;
  musicPlaying = true;
  
  musicGainNode = audioCtx.createGain();
  musicGainNode.gain.value = 0.02;
  musicGainNode.connect(masterGain);
  
  // Ambient pad
  const notes = [55, 82.5, 110, 165];
  notes.forEach(f => {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = f;
    g.gain.value = 0.4;
    o.connect(g); g.connect(musicGainNode);
    o.start();
    musicOscs.push(o);
  });
}

// ============================================================
// PARTICLES ‚Äî enhanced system
// ============================================================
function emit(x, y, count, color = '#00ffff', spread = 3, grav = 0.15, opts = {}) {
  for (let i = 0; i < count; i++) {
    const angle = opts.dir !== undefined ? opts.dir + (Math.random() - 0.5) * (opts.spread || 1) : Math.random() * Math.PI * 2;
    const speed = (opts.speed || spread) * (0.5 + Math.random() * 0.5) * S;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      decay: 0.01 + Math.random() * 0.02,
      size: (opts.size || (2 + Math.random() * 5)) * S,
      color, grav: grav * S,
      shape: opts.shape || 'rect',
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.3
    });
  }
}

function emitTrail(x, y, color = '#00ffff') {
  if (Math.random() > 0.5) return;
  particles.push({
    x: x + (Math.random() - 0.5) * 6 * S,
    y: y + (Math.random() - 0.5) * 6 * S,
    vx: (Math.random() - 0.5) * 0.3 * S,
    vy: (Math.random() - 0.5) * 0.3 * S,
    life: 0.7, decay: 0.025,
    size: (1 + Math.random() * 3) * S,
    color, grav: 0, shape: 'circle'
  });
}

function emitSpark(x, y, color, count = 5) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const s = (2 + Math.random() * 4) * S;
    particles.push({
      x, y,
      vx: Math.cos(a) * s, vy: Math.sin(a) * s,
      life: 1, decay: 0.03 + Math.random() * 0.03,
      size: (1 + Math.random() * 2) * S,
      color, grav: 0.05 * S, shape: 'circle'
    });
  }
}

function addFloatingText(x, y, text, color = '#ffd700', size = 20) {
  floatingTexts.push({
    x, y, text, color, size,
    vy: -1.5 * S, life: 1, decay: 0.015
  });
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vy += (p.grav || 0);
    p.vx *= 0.99; p.vy *= 0.99;
    if (p.rotation !== undefined) p.rotation += p.rotSpeed || 0;
    p.life -= p.decay;
    if (p.life <= 0) particles.splice(i, 1);
  }
  // Cap particles
  if (particles.length > 300) particles.splice(0, particles.length - 300);
  
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const f = floatingTexts[i];
    f.y += f.vy;
    f.life -= f.decay;
    if (f.life <= 0) floatingTexts.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    X.save();
    X.globalAlpha = Math.min(1, p.life * 0.9);
    X.fillStyle = p.color;
    X.shadowColor = p.color;
    X.shadowBlur = 4 * S;
    if (p.shape === 'circle') {
      X.beginPath();
      X.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
      X.fill();
    } else {
      X.translate(p.x, p.y);
      if (p.rotation) X.rotate(p.rotation);
      X.fillRect(-p.size/2, -p.size/2, p.size, p.size);
    }
    X.restore();
  }
  
  for (const f of floatingTexts) {
    X.save();
    X.globalAlpha = f.life;
    X.fillStyle = f.color;
    X.font = `bold ${f.size * S}px sans-serif`;
    X.textAlign = 'center';
    X.shadowColor = f.color;
    X.shadowBlur = 8 * S;
    X.fillText(f.text, f.x, f.y);
    X.restore();
  }
}

// ============================================================
// DRAWING HELPERS
// ============================================================
function drawBg() {
  const lc = levelColors[lvl % levelColors.length] || levelColors[0];
  const bg1 = (screen === 'game' || screen === 'victory') ? lc.bg1 : '#0a001a';
  const bg2 = (screen === 'game' || screen === 'victory') ? lc.bg2 : '#1a0033';
  const g = X.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, bg1);
  g.addColorStop(0.5, bg2);
  g.addColorStop(1, bg1);
  X.fillStyle = g;
  X.fillRect(0, 0, W, H);
  
  for (const s of starField) {
    s.y += s.speed * s.layer * 0.5;
    if (s.y > H) { s.y = -2; s.x = Math.random() * W; }
    const b = s.brightness * (0.5 + Math.sin(gt * s.twinkleSpeed) * 0.5);
    X.fillStyle = `rgba(200,200,255,${b})`;
    if (s.layer === 2) {
      X.beginPath();
      X.arc(s.x, s.y, s.size * 0.6, 0, Math.PI * 2);
      X.fill();
    } else {
      X.fillRect(s.x, s.y, s.size, s.size);
    }
  }
}

function drawNeonText(text, x, y, size, color = '#00ffff', align = 'center') {
  X.save();
  X.fillStyle = color;
  X.font = `bold ${size * S}px sans-serif`;
  X.textAlign = align;
  X.shadowColor = color;
  X.shadowBlur = 20 * S;
  X.fillText(text, x, y);
  X.shadowBlur = 8 * S;
  X.fillText(text, x, y);
  X.shadowBlur = 0;
  X.fillStyle = '#fff';
  X.globalAlpha = 0.3;
  X.fillText(text, x, y);
  X.restore();
}

function drawBtn(x, y, w, h, text, primary = true) {
  X.save();
  const hovered = false;
  const r = 6 * S;
  
  X.beginPath();
  X.roundRect(x, y, w, h, r);
  
  if (primary) {
    const grad = X.createLinearGradient(x, y, x, y + h);
    grad.addColorStop(0, '#00ffff');
    grad.addColorStop(1, '#0088aa');
    X.fillStyle = grad;
    X.shadowColor = '#00ffff';
    X.shadowBlur = 15 * S;
    X.fill();
    X.fillStyle = '#000';
  } else {
    X.fillStyle = 'rgba(0,255,255,0.08)';
    X.fill();
    X.strokeStyle = '#00ffff';
    X.lineWidth = 2 * S;
    X.shadowColor = '#00ffff';
    X.shadowBlur = 8 * S;
    X.stroke();
    X.fillStyle = '#00ffff';
  }
  X.font = `bold ${18 * S}px sans-serif`;
  X.textAlign = 'center';
  X.shadowBlur = 0;
  X.fillText(text, x + w/2, y + h/2 + 6 * S);
  X.restore();
  return { x, y, w, h };
}

function hit(px, py, box) {
  return box && px >= box.x && px <= box.x + box.w && py >= box.y && py <= box.y + box.h;
}

// Ease functions
function easeOutBack(t) { const c = 1.70158; return 1 + (c + 1) * Math.pow(t - 1, 3) + c * Math.pow(t - 1, 2); }
function easeOutElastic(t) { return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * (2 * Math.PI / 3)) + 1; }
function easeInOutCubic(t) { return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2; }

// ============================================================
// PLAYER
// ============================================================
class Player {
  constructor(x, y) {
    this.x = x; this.y = y;
    this.vx = 0; this.vy = 0;
    this.radius = 11 * S;
    this.gravDir = 1;
    this.gravity = 0.5 * S;
    this.moveSpeed = 2.8 * S;
    this.grounded = false;
    this.trail = [];
    this.flipAnim = 0;
    this.alive = true;
    this.squash = 1;
    this.flipCount = 0;
    this.lastGroundY = y;
    this.airTime = 0;
    this.glowPulse = 0;
    this.flipTimer = 1; // 1 = done, for eased flip animation
    this.invuln = 0; // brief invulnerability after respawn
  }

  flip() {
    if (!this.alive) return;
    this.gravDir *= -1;
    this.vy = this.gravDir * -3.5 * S;
    this.flipAnim = 1;
    this.flipTimer = 0;
    this.squash = 0.55;
    this.flipCount++;
    this.airTime = 0;
    sfxFlip();
    
    // Directional burst particles
    const dir = this.gravDir === 1 ? -Math.PI/2 : Math.PI/2;
    emit(this.x, this.y, 8, '#00ffff', 2.5, 0, { dir, spread: 1.2, shape: 'circle' });
    emit(this.x, this.y, 4, '#ffffff', 1.5, 0, { dir, spread: 0.8, size: 1.5, shape: 'circle' });
    screenShake = Math.max(screenShake, 4);
  }

  update() {
    if (!this.alive) return;
    
    this.vx = this.moveSpeed;
    this.vy += this.gravity * this.gravDir;
    
    if (Math.abs(this.vy) > 9 * S) this.vy = 9 * S * Math.sign(this.vy);
    
    this.x += this.vx;
    this.y += this.vy;
    
    this.squash += (1 - this.squash) * 0.18;
    this.flipTimer = Math.min(1, this.flipTimer + dt * 5.5);
    this.flipAnim = this.flipTimer < 1 ? Math.max(0, 1 - easeOutBack(this.flipTimer)) : 0;
    this.glowPulse += dt * 5;
    this.airTime += dt;
    if (this.invuln > 0) this.invuln -= dt;
    
    // Trail
    this.trail.push({ x: this.x, y: this.y, life: 1 });
    if (this.trail.length > 25) this.trail.shift();
    for (const t of this.trail) t.life -= 0.035;
    
    // Speed trail particles
    emitTrail(this.x - 8 * S, this.y);
    
    this.grounded = false;
  }

  draw() {
    if (!this.alive) return;
    
    // Trail with gradient
    X.save();
    for (let i = 1; i < this.trail.length; i++) {
      const t = this.trail[i];
      const prev = this.trail[i-1];
      if (t.life <= 0 || prev.life <= 0) continue;
      X.globalAlpha = t.life * 0.25;
      X.strokeStyle = '#00ffff';
      X.lineWidth = t.life * this.radius * 1.5;
      X.lineCap = 'round';
      X.beginPath();
      X.moveTo(prev.x, prev.y);
      X.lineTo(t.x, t.y);
      X.stroke();
    }
    X.restore();
    
    // Outer glow (pulsing)
    X.save();
    const glowSize = this.radius * (2.5 + Math.sin(this.glowPulse) * 0.3);
    const grad = X.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
    grad.addColorStop(0, 'rgba(0,255,255,0.25)');
    grad.addColorStop(0.5, 'rgba(0,255,255,0.08)');
    grad.addColorStop(1, 'rgba(0,255,255,0)');
    X.fillStyle = grad;
    X.beginPath();
    X.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
    X.fill();
    X.restore();
    
    // Invulnerability flash
    if (this.invuln > 0 && Math.sin(gt * 30) > 0) return;
    
    // Body
    X.save();
    X.translate(this.x, this.y);
    const sy = this.squash;
    const sx = 1 + (1 - sy) * 0.6;
    X.scale(sx, sy);
    
    if (this.flipAnim > 0.01) {
      X.rotate(this.flipAnim * Math.PI * 2 * -this.gravDir);
    }
    
    // Shadow/depth
    X.fillStyle = '#008899';
    X.beginPath();
    X.arc(1 * S, 1 * S, this.radius, 0, Math.PI * 2);
    X.fill();
    
    // Main body
    const bodyGrad = X.createRadialGradient(-3*S, -3*S, 0, 0, 0, this.radius);
    bodyGrad.addColorStop(0, '#66ffff');
    bodyGrad.addColorStop(0.6, '#00ffff');
    bodyGrad.addColorStop(1, '#00bbcc');
    X.fillStyle = bodyGrad;
    X.shadowColor = '#00ffff';
    X.shadowBlur = 18 * S;
    X.beginPath();
    X.arc(0, 0, this.radius, 0, Math.PI * 2);
    X.fill();
    
    // Highlight
    X.fillStyle = 'rgba(255,255,255,0.4)';
    X.shadowBlur = 0;
    X.beginPath();
    X.arc(-3 * S, -3 * S, this.radius * 0.4, 0, Math.PI * 2);
    X.fill();
    
    // Eyes
    X.fillStyle = '#000';
    const eyeY = this.gravDir * -2.5 * S;
    const eyeSpread = 3.5 * S;
    // Eye whites
    X.fillStyle = '#fff';
    X.beginPath();
    X.arc(-eyeSpread, eyeY, 3 * S, 0, Math.PI * 2);
    X.arc(eyeSpread, eyeY, 3 * S, 0, Math.PI * 2);
    X.fill();
    // Pupils (look in movement direction)
    X.fillStyle = '#111';
    X.beginPath();
    X.arc(-eyeSpread + 0.8 * S, eyeY, 1.8 * S, 0, Math.PI * 2);
    X.arc(eyeSpread + 0.8 * S, eyeY, 1.8 * S, 0, Math.PI * 2);
    X.fill();
    // Eye shine
    X.fillStyle = '#fff';
    X.beginPath();
    X.arc(-eyeSpread - 0.5 * S, eyeY - 1 * S, 0.8 * S, 0, Math.PI * 2);
    X.arc(eyeSpread - 0.5 * S, eyeY - 1 * S, 0.8 * S, 0, Math.PI * 2);
    X.fill();
    
    X.restore();
    
    // Small gravity arrow
    X.save();
    X.globalAlpha = 0.35 + Math.sin(gt * 4) * 0.1;
    X.fillStyle = '#00ffff';
    const arrowY = this.y + this.gravDir * (this.radius + 10 * S);
    X.beginPath();
    X.moveTo(this.x, arrowY + this.gravDir * 5 * S);
    X.lineTo(this.x - 4 * S, arrowY);
    X.lineTo(this.x + 4 * S, arrowY);
    X.closePath();
    X.fill();
    X.restore();
  }

  collideRect(rx, ry, rw, rh) {
    const cx = Math.max(rx, Math.min(this.x, rx + rw));
    const cy = Math.max(ry, Math.min(this.y, ry + rh));
    const dx = this.x - cx, dy = this.y - cy;
    return (dx * dx + dy * dy) < (this.radius * this.radius);
  }

  collideCircle(cx, cy, r) {
    const dx = this.x - cx, dy = this.y - cy;
    return Math.sqrt(dx * dx + dy * dy) < (this.radius + r);
  }
  
  // Near miss detection ‚Äî how close to a rect
  nearMissRect(rx, ry, rw, rh, threshold) {
    const cx = Math.max(rx, Math.min(this.x, rx + rw));
    const cy = Math.max(ry, Math.min(this.y, ry + rh));
    const dx = this.x - cx, dy = this.y - cy;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return dist < this.radius + threshold && dist >= this.radius;
  }
}

// ============================================================
// LEVEL OBJECTS
// ============================================================
class Platform {
  constructor(x, y, w, h, type = 'solid') {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.type = type;
    this.ox = x; this.oy = y;
    this.moveTimer = Math.random() * Math.PI * 2;
    this.moveRangeX = 0; this.moveRangeY = 0;
    this.moveSpeed = 1;
    this.crumbleTimer = 0;
    this.crumbling = false;
    this.gone = false;
    this.hitAnim = 0;
  }

  update() {
    if (this.gone) return;
    if (this.type === 'moving') {
      this.moveTimer += dt * this.moveSpeed;
      this.x = this.ox + Math.sin(this.moveTimer) * this.moveRangeX;
      this.y = this.oy + Math.sin(this.moveTimer * 0.7) * this.moveRangeY;
    }
    if (this.crumbling) {
      this.crumbleTimer -= dt;
      if (this.crumbleTimer <= 0) {
        this.gone = true;
        emit(this.x + this.w/2, this.y + this.h/2, 15, '#c8a050', 3, 0.15);
        sfxCrumble();
      }
    }
    if (this.hitAnim > 0) this.hitAnim -= dt * 4;
  }

  draw() {
    if (this.gone) return;
    X.save();
    
    // Hit animation offset
    const hitOffset = this.hitAnim > 0 ? Math.sin(this.hitAnim * 20) * 2 * S : 0;
    
    const alpha = this.crumbling ? 0.3 + Math.sin(gt * 25) * 0.3 : 0.8;
    
    if (this.type === 'bouncy') {
      const grad = X.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
      grad.addColorStop(0, `rgba(0,255,128,${alpha * 0.7})`);
      grad.addColorStop(1, `rgba(0,200,80,${alpha * 0.5})`);
      X.fillStyle = grad;
      X.strokeStyle = '#00ff80';
      // Bouncy spring lines
      X.fillRect(this.x, this.y + hitOffset, this.w, this.h);
      X.lineWidth = 2 * S;
      X.shadowColor = '#00ff80';
      X.shadowBlur = 10 * S;
      X.strokeRect(this.x, this.y + hitOffset, this.w, this.h);
      // Spring zigzag decoration
      X.shadowBlur = 0;
      X.strokeStyle = 'rgba(0,255,128,0.3)';
      X.lineWidth = 1.5 * S;
      X.beginPath();
      const segs = Math.floor(this.w / (6 * S));
      for (let i = 0; i <= segs; i++) {
        const px = this.x + (i / segs) * this.w;
        const py = this.y + hitOffset + (i % 2 === 0 ? 0 : this.h);
        if (i === 0) X.moveTo(px, py); else X.lineTo(px, py);
      }
      X.stroke();
    } else if (this.type === 'crumble') {
      // Cracked appearance
      X.fillStyle = `rgba(160,130,80,${alpha * 0.6})`;
      X.strokeStyle = '#c8a050';
      X.fillRect(this.x, this.y + hitOffset, this.w, this.h);
      X.lineWidth = 2 * S;
      X.shadowColor = '#c8a050';
      X.shadowBlur = 6 * S;
      X.strokeRect(this.x, this.y + hitOffset, this.w, this.h);
      // Crack lines
      if (this.crumbling) {
        X.strokeStyle = 'rgba(200,160,80,0.6)';
        X.lineWidth = 1 * S;
        X.shadowBlur = 0;
        for (let i = 0; i < 3; i++) {
          const cx = this.x + this.w * (0.2 + i * 0.3);
          X.beginPath();
          X.moveTo(cx, this.y + hitOffset);
          X.lineTo(cx + (Math.random()-0.5) * 8 * S, this.y + this.h + hitOffset);
          X.stroke();
        }
      }
    } else {
      const grad = X.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
      grad.addColorStop(0, `rgba(60,60,100,${alpha * 0.7})`);
      grad.addColorStop(1, `rgba(40,40,70,${alpha * 0.5})`);
      X.fillStyle = grad;
      X.strokeStyle = '#00ccff';
      X.fillRect(this.x, this.y + hitOffset, this.w, this.h);
      X.lineWidth = 1.5 * S;
      X.shadowColor = '#00ccff';
      X.shadowBlur = 6 * S;
      X.strokeRect(this.x, this.y + hitOffset, this.w, this.h);
      // Edge highlight
      X.strokeStyle = 'rgba(0,255,255,0.2)';
      X.shadowBlur = 0;
      X.beginPath();
      X.moveTo(this.x, this.y + hitOffset);
      X.lineTo(this.x + this.w, this.y + hitOffset);
      X.stroke();
    }
    X.restore();
  }

  handleCollision(player) {
    if (this.gone || !player.collideRect(this.x, this.y, this.w, this.h)) return false;
    
    const overlapLeft = (player.x + player.radius) - this.x;
    const overlapRight = (this.x + this.w) - (player.x - player.radius);
    const overlapTop = (player.y + player.radius) - this.y;
    const overlapBottom = (this.y + this.h) - (player.y - player.radius);
    
    const minOverlapX = Math.min(overlapLeft, overlapRight);
    const minOverlapY = Math.min(overlapTop, overlapBottom);
    
    if (minOverlapX < minOverlapY) {
      if (overlapLeft < overlapRight) {
        player.x = this.x - player.radius;
      } else {
        player.x = this.x + this.w + player.radius;
      }
      player.vx = 0;
    } else {
      if (overlapTop < overlapBottom) {
        player.y = this.y - player.radius;
        if (player.gravDir === 1) { player.grounded = true; player.lastGroundY = player.y; }
      } else {
        player.y = this.y + this.h + player.radius;
        if (player.gravDir === -1) { player.grounded = true; player.lastGroundY = player.y; }
      }
      
      if (this.type === 'bouncy') {
        player.vy = -player.vy * 1.35;
        sfxBounce();
        screenShake = Math.max(screenShake, 5);
        this.hitAnim = 1;
        emit(player.x, player.y, 10, '#00ff80', 3.5, 0, { shape: 'circle' });
        player.squash = 0.45;
      } else {
        // Landing particles
        if (Math.abs(player.vy) > 2 * S) {
          const count = Math.min(8, Math.floor(Math.abs(player.vy) / S));
          emit(player.x, player.y + player.radius * player.gravDir, count, '#00ffff', 2, 0, { dir: player.gravDir > 0 ? 0 : Math.PI, spread: 2 });
          screenShake = Math.max(screenShake, Math.min(3, Math.abs(player.vy) / S * 0.5));
        }
        player.vy = 0;
        player.squash = 0.7 + Math.min(0.2, Math.abs(player.vy) * 0.02);
      }
      
      if (this.type === 'crumble' && !this.crumbling) {
        this.crumbling = true;
        this.crumbleTimer = 0.45;
        this.hitAnim = 0.5;
        emitSpark(player.x, this.y + this.h/2, '#c8a050', 3);
      }
    }
    return true;
  }
}

class Spike {
  constructor(x, y, w, h) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.pulse = Math.random() * Math.PI * 2;
  }
  update() { this.pulse += dt * 3; }
  draw() {
    const b = 0.5 + Math.sin(this.pulse) * 0.3;
    X.save();
    
    // Danger glow
    const grad = X.createRadialGradient(
      this.x + this.w/2, this.y + this.h/2, 0,
      this.x + this.w/2, this.y + this.h/2, Math.max(this.w, this.h)
    );
    grad.addColorStop(0, `rgba(255,0,100,${b * 0.15})`);
    grad.addColorStop(1, 'rgba(255,0,100,0)');
    X.fillStyle = grad;
    X.fillRect(this.x - this.w*0.5, this.y - this.h*0.5, this.w*2, this.h*2);
    
    X.fillStyle = `rgba(255,0,100,${b * 0.4})`;
    X.fillRect(this.x, this.y, this.w, this.h);
    X.strokeStyle = '#ff0064';
    X.lineWidth = 2 * S;
    X.shadowColor = '#ff0064';
    X.shadowBlur = 12 * S;
    X.strokeRect(this.x, this.y, this.w, this.h);
    
    // Danger triangles on top and bottom
    const numSpikes = Math.max(2, Math.floor(this.w / (8 * S)));
    X.fillStyle = `rgba(255,0,100,${b * 0.9})`;
    X.shadowBlur = 6 * S;
    for (let i = 0; i < numSpikes; i++) {
      const sx = this.x + (i + 0.5) * (this.w / numSpikes);
      X.beginPath();
      X.moveTo(sx - 3 * S, this.y);
      X.lineTo(sx + 3 * S, this.y);
      X.lineTo(sx, this.y - 7 * S);
      X.closePath();
      X.fill();
      X.beginPath();
      X.moveTo(sx - 3 * S, this.y + this.h);
      X.lineTo(sx + 3 * S, this.y + this.h);
      X.lineTo(sx, this.y + this.h + 7 * S);
      X.closePath();
      X.fill();
    }
    X.restore();
  }
  check(player) { return player.invuln <= 0 && player.collideRect(this.x, this.y, this.w, this.h); }
  nearMiss(player) { return player.nearMissRect(this.x, this.y, this.w, this.h, 8 * S); }
}

class Orb {
  constructor(x, y, color = '#4488ff') {
    this.x = x; this.y = y;
    this.radius = 9 * S;
    this.collected = false;
    this.pulse = Math.random() * Math.PI * 2;
    this.color = color;
    this.collectAnim = 0;
    this.bobOffset = Math.random() * Math.PI * 2;
  }
  update() { 
    this.pulse += dt * 4;
    if (this.collectAnim > 0) this.collectAnim -= dt * 3;
  }
  draw() {
    if (this.collected) return;
    const bob = Math.sin(this.pulse * 0.8 + this.bobOffset) * 3 * S;
    const s = this.radius * (1 + Math.sin(this.pulse) * 0.15);
    const dy = this.y + bob;
    
    X.save();
    // Outer glow
    const grad = X.createRadialGradient(this.x, dy, 0, this.x, dy, s * 2.5);
    grad.addColorStop(0, this.color + '44');
    grad.addColorStop(1, this.color + '00');
    X.fillStyle = grad;
    X.beginPath(); X.arc(this.x, dy, s * 2.5, 0, Math.PI * 2); X.fill();
    
    // Ring
    X.strokeStyle = this.color + '66';
    X.lineWidth = 1.5 * S;
    X.beginPath();
    X.arc(this.x, dy, s * 1.5 + Math.sin(this.pulse * 1.5) * 2 * S, 0, Math.PI * 2);
    X.stroke();
    
    // Core
    const coreGrad = X.createRadialGradient(this.x - s*0.3, dy - s*0.3, 0, this.x, dy, s);
    coreGrad.addColorStop(0, '#ffffff');
    coreGrad.addColorStop(0.3, this.color);
    coreGrad.addColorStop(1, this.color + 'aa');
    X.fillStyle = coreGrad;
    X.shadowColor = this.color;
    X.shadowBlur = 15 * S;
    X.beginPath(); X.arc(this.x, dy, s, 0, Math.PI * 2); X.fill();
    
    // Sparkle
    X.fillStyle = '#fff';
    X.shadowBlur = 0;
    X.globalAlpha = 0.7 + Math.sin(this.pulse * 2) * 0.3;
    X.beginPath(); X.arc(this.x - s * 0.3, dy - s * 0.3, s * 0.25, 0, Math.PI * 2); X.fill();
    X.restore();
  }
  check(player) {
    if (this.collected) return false;
    const bob = Math.sin(this.pulse * 0.8 + this.bobOffset) * 3 * S;
    if (player.collideCircle(this.x, this.y + bob, this.radius * 1.3)) {
      this.collected = true;
      // Big collection burst
      emit(this.x, this.y, 15, this.color, 3, 0, { shape: 'circle' });
      emit(this.x, this.y, 8, '#ffffff', 2, 0, { size: 2, shape: 'circle' });
      screenFlash = 0.15;
      screenFlashColor = this.color;
      return true;
    }
    return false;
  }
}

class Portal {
  constructor(x, y) {
    this.x = x; this.y = y;
    this.radius = 24 * S;
    this.pulse = 0;
    this.active = false;
    this.activateAnim = 0;
  }
  update() { 
    this.pulse += dt * 2.5;
    if (this.active && this.activateAnim < 1) {
      this.activateAnim = Math.min(1, this.activateAnim + dt * 2);
    }
  }
  draw() {
    const s = this.radius * (1 + Math.sin(this.pulse) * 0.08);
    const a = this.activateAnim;
    
    X.save();
    
    // Background swirl
    if (this.active) {
      for (let i = 0; i < 4; i++) {
        const angle = this.pulse * 1.5 + i * Math.PI / 2;
        const dist = s * 0.6;
        const px = this.x + Math.cos(angle) * dist;
        const py = this.y + Math.sin(angle) * dist;
        const grad = X.createRadialGradient(px, py, 0, px, py, 8 * S);
        grad.addColorStop(0, `rgba(255,215,0,${0.4 * a})`);
        grad.addColorStop(1, 'rgba(255,215,0,0)');
        X.fillStyle = grad;
        X.beginPath(); X.arc(px, py, 8 * S, 0, Math.PI * 2); X.fill();
      }
    }
    
    // Rings
    for (let i = 3; i > 0; i--) {
      const ringA = this.active ? 0.4 * a / i : 0.15 / i;
      X.strokeStyle = this.active ? `rgba(255,215,0,${ringA})` : `rgba(100,100,100,${ringA})`;
      X.lineWidth = (this.active ? 3 : 2) * S;
      if (this.active) { X.shadowColor = '#ffd700'; X.shadowBlur = 12 * S; }
      X.beginPath();
      X.arc(this.x, this.y, s * (1 + i * 0.22) + Math.sin(this.pulse + i) * 3 * S, 0, Math.PI * 2);
      X.stroke();
    }
    
    // Core
    const grad = X.createRadialGradient(this.x, this.y, 0, this.x, this.y, s);
    if (this.active) {
      grad.addColorStop(0, `rgba(255,230,100,${0.9 * a})`);
      grad.addColorStop(0.5, `rgba(255,215,0,${0.4 * a})`);
      grad.addColorStop(1, 'rgba(255,215,0,0)');
    } else {
      grad.addColorStop(0, 'rgba(100,100,100,0.3)');
      grad.addColorStop(1, 'rgba(100,100,100,0)');
    }
    X.fillStyle = grad;
    X.beginPath(); X.arc(this.x, this.y, s, 0, Math.PI * 2); X.fill();
    
    // Spinning particles
    if (this.active) {
      X.shadowColor = '#ffd700'; X.shadowBlur = 8 * S;
      for (let i = 0; i < 8; i++) {
        const angle = this.pulse * 2.5 + i * Math.PI / 4;
        const r = s * (0.5 + Math.sin(this.pulse + i) * 0.2);
        const px = this.x + Math.cos(angle) * r;
        const py = this.y + Math.sin(angle) * r;
        X.fillStyle = '#ffd700';
        X.globalAlpha = 0.8 * a;
        X.beginPath(); X.arc(px, py, 2.5 * S, 0, Math.PI * 2); X.fill();
      }
      
      // "ENTER" hint
      if (a >= 1) {
        X.globalAlpha = 0.5 + Math.sin(gt * 3) * 0.3;
        X.fillStyle = '#ffd700';
        X.font = `bold ${10 * S}px sans-serif`;
        X.textAlign = 'center';
        X.shadowBlur = 4 * S;
        X.fillText('‚óè', this.x, this.y + this.radius + 18 * S);
      }
    } else {
      // Lock icon hint
      X.globalAlpha = 0.4;
      X.fillStyle = '#666';
      X.font = `${12 * S}px sans-serif`;
      X.textAlign = 'center';
      X.fillText('üîí', this.x, this.y + 4 * S);
    }
    
    X.restore();
  }
  check(player) { return this.active && player.collideCircle(this.x, this.y, this.radius); }
}

class GravityWell {
  constructor(x, y, strength, radius) {
    this.x = x; this.y = y;
    this.strength = strength * S;
    this.radius = radius * S;
    this.pulse = 0;
  }
  update() { this.pulse += dt * 2; }
  draw() {
    X.save();
    const grad = X.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
    grad.addColorStop(0, 'rgba(138,43,226,0.3)');
    grad.addColorStop(0.5, 'rgba(138,43,226,0.1)');
    grad.addColorStop(1, 'rgba(138,43,226,0)');
    X.fillStyle = grad;
    X.beginPath(); X.arc(this.x, this.y, this.radius, 0, Math.PI * 2); X.fill();
    
    // Animated spiral
    X.strokeStyle = `rgba(180,100,255,${0.25 + Math.sin(this.pulse) * 0.15})`;
    X.lineWidth = 1.5 * S;
    for (let i = 0; i < 3; i++) {
      X.beginPath();
      for (let a = 0; a < Math.PI * 4; a += 0.1) {
        const r = (a / (Math.PI * 4)) * this.radius * 0.8;
        const px = this.x + Math.cos(a + this.pulse + i * 2.1) * r;
        const py = this.y + Math.sin(a + this.pulse + i * 2.1) * r;
        if (a === 0) X.moveTo(px, py); else X.lineTo(px, py);
      }
      X.stroke();
    }
    
    // Center pulse
    X.fillStyle = `rgba(180,100,255,${0.3 + Math.sin(this.pulse * 2) * 0.2})`;
    X.shadowColor = '#b464ff';
    X.shadowBlur = 10 * S;
    X.beginPath();
    X.arc(this.x, this.y, 4 * S, 0, Math.PI * 2);
    X.fill();
    
    X.restore();
  }
  applyForce(player) {
    const dx = this.x - player.x, dy = this.y - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < this.radius && dist > 0) {
      const force = this.strength * (1 - dist / this.radius);
      player.vx += (dx / dist) * force;
      player.vy += (dy / dist) * force;
      // Visual pull particles
      if (Math.random() > 0.85) {
        emitTrail(
          player.x + (Math.random()-0.5) * 10 * S,
          player.y + (Math.random()-0.5) * 10 * S,
          '#b464ff'
        );
      }
    }
  }
}

class WindZone {
  constructor(x, y, w, h, dirX, dirY, strength) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.dirX = dirX; this.dirY = dirY;
    this.strength = strength * S;
    this.pulse = Math.random() * Math.PI * 2;
    this.particles = [];
  }
  update() {
    this.pulse += dt * 2;
    // spawn wind particles
    if (Math.random() > 0.7) {
      this.particles.push({
        x: this.dirX >= 0 ? this.x : this.x + this.w,
        y: this.y + Math.random() * this.h,
        life: 1
      });
    }
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.x += this.dirX * 3 * S;
      p.y += this.dirY * 3 * S;
      p.life -= 0.025;
      if (p.life <= 0 || p.x < this.x - 10 || p.x > this.x + this.w + 10 ||
          p.y < this.y - 10 || p.y > this.y + this.h + 10) {
        this.particles.splice(i, 1);
      }
    }
    if (this.particles.length > 40) this.particles.splice(0, this.particles.length - 40);
  }
  draw() {
    X.save();
    // Zone background
    const alpha = 0.04 + Math.sin(this.pulse) * 0.02;
    X.fillStyle = `rgba(100,200,255,${alpha})`;
    X.fillRect(this.x, this.y, this.w, this.h);
    // Border lines (dashed)
    X.strokeStyle = 'rgba(100,200,255,0.15)';
    X.lineWidth = 1 * S;
    X.setLineDash([4 * S, 4 * S]);
    X.strokeRect(this.x, this.y, this.w, this.h);
    X.setLineDash([]);
    // Wind streaks
    for (const p of this.particles) {
      X.globalAlpha = p.life * 0.3;
      X.strokeStyle = '#88ccff';
      X.lineWidth = 1 * S;
      X.beginPath();
      X.moveTo(p.x, p.y);
      X.lineTo(p.x - this.dirX * 12 * S, p.y - this.dirY * 12 * S);
      X.stroke();
    }
    // Arrow indicator
    X.globalAlpha = 0.2 + Math.sin(this.pulse * 1.5) * 0.1;
    X.fillStyle = '#88ccff';
    const cx = this.x + this.w / 2;
    const cy = this.y + this.h / 2;
    const arrowLen = 10 * S;
    const ax = cx + this.dirX * arrowLen;
    const ay = cy + this.dirY * arrowLen;
    X.beginPath();
    X.moveTo(ax, ay);
    X.lineTo(ax - this.dirX * 8 * S - this.dirY * 4 * S, ay - this.dirY * 8 * S + this.dirX * 4 * S);
    X.lineTo(ax - this.dirX * 8 * S + this.dirY * 4 * S, ay - this.dirY * 8 * S - this.dirX * 4 * S);
    X.closePath();
    X.fill();
    X.restore();
  }
  applyForce(player) {
    if (player.x > this.x && player.x < this.x + this.w &&
        player.y > this.y && player.y < this.y + this.h) {
      player.vx += this.dirX * this.strength * 0.15;
      player.vy += this.dirY * this.strength * 0.15;
    }
  }
}

// Near-miss tracking
let totalNearMisses = 0;
let sessionNearMisses = 0;
try { const nm = localStorage.getItem('gflip3_nearmiss'); if (nm) totalNearMisses = parseInt(nm) || 0; } catch(e) {}
function saveNearMisses() { try { localStorage.setItem('gflip3_nearmiss', totalNearMisses.toString()); } catch(e) {} }

// Leaderboard
let leaderboard = [];
try { const lb = localStorage.getItem('gflip3_lb'); if (lb) leaderboard = JSON.parse(lb); } catch(e) {}
function saveLeaderboard() { try { localStorage.setItem('gflip3_lb', JSON.stringify(leaderboard)); } catch(e) {} }
function addLeaderboardEntry(name, score, level) {
  leaderboard.push({ name: name.substring(0, 3).toUpperCase(), score, level, date: Date.now() });
  leaderboard.sort((a, b) => b.score - a.score);
  if (leaderboard.length > 20) leaderboard.length = 20;
  saveLeaderboard();
}

// Daily challenge
let dailyChallengeCompleted = false;
let dailyChallengeSeed = 0;
let dailyChallengeScreen = false;
function getDailySeed() {
  const d = new Date();
  return d.getFullYear() * 10000 + (d.getMonth() + 1) * 100 + d.getDate();
}
function seededRandom(seed) {
  let s = seed;
  return function() {
    s = (s * 1103515245 + 12345) & 0x7fffffff;
    return s / 0x7fffffff;
  };
}
function generateDailyChallenge() {
  dailyChallengeSeed = getDailySeed();
  const rng = seededRandom(dailyChallengeSeed);
  // Check if already completed today
  try {
    const dc = localStorage.getItem('gflip3_daily');
    if (dc) {
      const data = JSON.parse(dc);
      if (data.seed === dailyChallengeSeed) dailyChallengeCompleted = true;
    }
  } catch(e) {}

  // Generate a procedural level
  const numPlats = 4 + Math.floor(rng() * 4);
  const platforms = [];
  const spikes = [];
  const orbs = [];
  // Floor and ceiling
  platforms.push([0, 0.0, 1.0, 0.02]);
  platforms.push([0, 0.98, 1.0, 0.02]);
  // Random platforms
  for (let i = 0; i < numPlats; i++) {
    const px = 0.1 + rng() * 0.7;
    const py = 0.15 + rng() * 0.7;
    const pw = 0.08 + rng() * 0.15;
    const types = ['solid', 'solid', 'bouncy', 'crumble'];
    const ptype = types[Math.floor(rng() * types.length)];
    platforms.push([px, py, pw, 0.03, ptype]);
  }
  // Spikes
  const numSpikes = 2 + Math.floor(rng() * 3);
  for (let i = 0; i < numSpikes; i++) {
    spikes.push([0.15 + rng() * 0.7, rng() < 0.5 ? 0.02 : 0.88, 0.04 + rng() * 0.06, 0.06]);
  }
  // Orbs
  for (let i = 0; i < 3; i++) {
    orbs.push([0.15 + rng() * 0.7, 0.15 + rng() * 0.65]);
  }
  return {
    name: 'Daily Challenge', stars: [20, 14, 9],
    spawn: [0.05, 0.3 + rng() * 0.3], goal: [0.9, 0.3 + rng() * 0.3],
    width: 1.0, platforms, spikes, orbs, wells: [],
    winds: rng() > 0.5 ? [[0.3, 0.2, 0.3, 0.5, rng() > 0.5 ? 1 : -1, 0, 0.4 + rng() * 0.4]] : []
  };
}

// Stats screen
let showStats = false;
function getStats() {
  let totalStars = 0, levelsCompleted = 0, bestTimes = [];
  for (let i = 0; i < LEVELS.length; i++) {
    if (progress[i]) {
      if (progress[i].stars) totalStars += progress[i].stars;
      if (progress[i].completed) levelsCompleted++;
      if (progress[i].time) bestTimes.push({ level: i, time: progress[i].time });
    }
  }
  return { totalStars, levelsCompleted, totalNearMisses, totalScore, bestTimes };
}

// Initials entry state
let enteringInitials = false;
let initialsText = '';
let initialsCursor = 0;
let initialsScore = 0;
let initialsLevel = 0;

// ============================================================
// LASER BEAMS ‚Äî toggling hazard for later levels
// ============================================================
class LaserBeam {
  constructor(x, y, w, h, onTime, offTime, startDelay) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.onTime = onTime || 1.5;
    this.offTime = offTime || 2;
    this.timer = -(startDelay || 0);
    this.active = false;
    this.warning = false;
    this.intensity = 0;
    this.horizontal = w > h;
  }
  update() {
    this.timer += dt;
    if (this.timer < 0) { this.active = false; this.warning = false; this.intensity = 0; return; }
    const cycle = this.onTime + this.offTime;
    const phase = this.timer % cycle;
    this.active = phase < this.onTime;
    const warmup = 0.6;
    this.warning = !this.active && (cycle - phase) < warmup;
    if (this.active) {
      this.intensity = Math.min(1, this.intensity + dt * 8);
    } else {
      this.intensity = Math.max(0, this.intensity - dt * 6);
    }
  }
  draw() {
    X.save();
    if (this.active || this.intensity > 0) {
      const a = this.intensity;
      // Outer glow
      const expand = 10 * S * a;
      X.fillStyle = `rgba(255,50,50,${0.12 * a})`;
      X.fillRect(this.x - expand, this.y - expand, this.w + expand * 2, this.h + expand * 2);
      // Beam body
      X.fillStyle = `rgba(255,80,80,${0.7 * a})`;
      X.shadowColor = '#ff3333';
      X.shadowBlur = 18 * S * a;
      X.fillRect(this.x, this.y, this.w, this.h);
      // Hot core
      X.fillStyle = `rgba(255,220,220,${0.8 * a})`;
      X.shadowBlur = 8 * S * a;
      const coreOff = Math.max(1 * S, Math.min(this.w, this.h) * 0.3);
      X.fillRect(this.x + coreOff, this.y + coreOff,
        Math.max(1, this.w - coreOff * 2), Math.max(1, this.h - coreOff * 2));
      // Sparks at edges
      if (a > 0.5 && Math.random() > 0.7) {
        const sx = this.horizontal
          ? this.x + Math.random() * this.w
          : this.x + this.w / 2;
        const sy = this.horizontal
          ? this.y + this.h / 2
          : this.y + Math.random() * this.h;
        emitSpark(sx, sy, '#ff6666', 1);
      }
    } else if (this.warning) {
      const warnA = 0.15 + Math.sin(gt * 20) * 0.15;
      X.fillStyle = `rgba(255,80,80,${warnA})`;
      X.fillRect(this.x, this.y, this.w, this.h);
      X.strokeStyle = `rgba(255,80,80,${warnA + 0.15})`;
      X.lineWidth = 1.5 * S;
      X.setLineDash([3 * S, 3 * S]);
      X.strokeRect(this.x, this.y, this.w, this.h);
    } else {
      // Emitter dots at endpoints
      X.globalAlpha = 0.3 + Math.sin(gt * 2) * 0.1;
      X.fillStyle = '#ff4444';
      if (this.horizontal) {
        X.beginPath();
        X.arc(this.x, this.y + this.h / 2, 3 * S, 0, Math.PI * 2);
        X.arc(this.x + this.w, this.y + this.h / 2, 3 * S, 0, Math.PI * 2);
        X.fill();
      } else {
        X.beginPath();
        X.arc(this.x + this.w / 2, this.y, 3 * S, 0, Math.PI * 2);
        X.arc(this.x + this.w / 2, this.y + this.h, 3 * S, 0, Math.PI * 2);
        X.fill();
      }
      // Faint dashed line
      X.globalAlpha = 0.08;
      X.strokeStyle = '#ff4444';
      X.lineWidth = 1 * S;
      X.setLineDash([4 * S, 6 * S]);
      if (this.horizontal) {
        X.beginPath();
        X.moveTo(this.x, this.y + this.h / 2);
        X.lineTo(this.x + this.w, this.y + this.h / 2);
        X.stroke();
      } else {
        X.beginPath();
        X.moveTo(this.x + this.w / 2, this.y);
        X.lineTo(this.x + this.w / 2, this.y + this.h);
        X.stroke();
      }
    }
    X.restore();
  }
  check(player) {
    return this.active && player.invuln <= 0 && player.collideRect(this.x, this.y, this.w, this.h);
  }
}

function sfxLaser() {
  tone(180, 0.15, 'sawtooth', 0.08);
  tone(90, 0.2, 'square', 0.05, 0.05);
}

// ============================================================
// LEVELS
// ============================================================
const LEVELS = [
  // 1: Tutorial
  { name: 'Hello Gravity', stars: [15,10,7],
    spawn: [0.05, 0.4], goal: [0.9, 0.6], width: 1.0,
    platforms: [
      [0, 0.5, 1.0, 0.03],
      [0, 0.0, 1.0, 0.03],
    ],
    spikes: [],
    orbs: [[0.3, 0.35], [0.5, 0.35], [0.7, 0.35]],
    wells: []
  },
  // 2
  { name: 'Mind The Gap', stars: [15,10,7],
    spawn: [0.05, 0.4], goal: [0.9, 0.15], width: 1.0,
    platforms: [
      [0, 0.5, 0.4, 0.03],
      [0.6, 0.5, 0.4, 0.03],
      [0, 0.0, 1.0, 0.03],
    ],
    spikes: [[0.4, 0.47, 0.2, 0.06]],
    orbs: [[0.2, 0.35], [0.5, 0.12], [0.8, 0.35]],
    wells: []
  },
  // 3
  { name: 'Corridor', stars: [18,12,8],
    spawn: [0.05, 0.35], goal: [0.9, 0.65], width: 1.0,
    platforms: [
      [0, 0.45, 0.35, 0.03],
      [0.35, 0.0, 0.03, 0.35],
      [0.35, 0.55, 0.35, 0.03],
      [0.65, 0.55, 0.03, 0.45],
      [0.65, 0.45, 0.35, 0.03],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [[0.35, 0.38, 0.3, 0.04]],
    orbs: [[0.15, 0.3], [0.5, 0.45], [0.8, 0.3]],
    wells: []
  },
  // 4
  { name: 'Bounce House', stars: [18,12,8],
    spawn: [0.05, 0.4], goal: [0.9, 0.15], width: 1.0,
    platforms: [
      [0, 0.5, 0.3, 0.03],
      [0.4, 0.6, 0.2, 0.03, 'bouncy'],
      [0.7, 0.5, 0.3, 0.03],
      [0, 0.0, 1.0, 0.02],
    ],
    spikes: [[0.3, 0.47, 0.1, 0.06]],
    orbs: [[0.2, 0.35], [0.5, 0.2], [0.8, 0.35]],
    wells: []
  },
  // 5
  { name: 'Crumbling Path', stars: [20,14,9],
    spawn: [0.05, 0.4], goal: [0.9, 0.4], width: 1.0,
    platforms: [
      [0, 0.5, 0.15, 0.03],
      [0.2, 0.5, 0.15, 0.03, 'crumble'],
      [0.4, 0.5, 0.15, 0.03, 'crumble'],
      [0.6, 0.5, 0.15, 0.03, 'crumble'],
      [0.8, 0.5, 0.2, 0.03],
      [0, 0.0, 1.0, 0.02],
    ],
    spikes: [[0, 0.96, 1.0, 0.04]],
    orbs: [[0.3, 0.35], [0.5, 0.35], [0.7, 0.35]],
    wells: []
  },
  // 6
  { name: 'Strange Attractor', stars: [22,15,10],
    spawn: [0.05, 0.3], goal: [0.9, 0.3], width: 1.0,
    platforms: [
      [0, 0.4, 0.25, 0.03],
      [0.75, 0.4, 0.25, 0.03],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [[0.25, 0.37, 0.08, 0.06], [0.67, 0.37, 0.08, 0.06]],
    orbs: [[0.15, 0.25], [0.5, 0.3], [0.85, 0.25]],
    wells: [[0.5, 0.5, 0.35, 100]],
    winds: [[0.35, 0.0, 0.3, 0.35, 0, 1, 0.3]]
  },
  // 7
  { name: 'Zigzag', stars: [20,14,9],
    spawn: [0.05, 0.15], goal: [0.9, 0.85], width: 1.0,
    platforms: [
      [0, 0.2, 0.35, 0.03],
      [0.25, 0.4, 0.35, 0.03],
      [0, 0.6, 0.35, 0.03],
      [0.25, 0.8, 0.35, 0.03],
      [0.65, 0.3, 0.35, 0.03],
      [0.65, 0.7, 0.35, 0.03],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [[0.2, 0.25, 0.05, 0.12], [0.55, 0.55, 0.1, 0.08]],
    orbs: [[0.15, 0.08], [0.5, 0.5], [0.8, 0.62]],
    wells: []
  },
  // 8
  { name: 'Gauntlet', stars: [25,18,12],
    spawn: [0.05, 0.35], goal: [0.9, 0.65], width: 1.0,
    platforms: [
      [0, 0.45, 0.4, 0.03],
      [0.4, 0.45, 0.2, 0.03, 'moving', 0, 0.08, 1.2],
      [0.6, 0.45, 0.4, 0.03],
      [0, 0.0, 1.0, 0.02],
      [0, 0.55, 1.0, 0.03],
    ],
    spikes: [
      [0.15, 0.03, 0.06, 0.1],
      [0.3, 0.35, 0.06, 0.1],
      [0.45, 0.03, 0.06, 0.1],
      [0.6, 0.35, 0.06, 0.1],
      [0.75, 0.03, 0.06, 0.1],
    ],
    orbs: [[0.22, 0.25], [0.52, 0.25], [0.82, 0.25]],
    wells: [],
    lasers: [[0.87, 0.03, 0.03, 0.32, 1.4, 2.2, 1.5]]
  },
  // 9
  { name: 'Whirlpool', stars: [28,20,14],
    spawn: [0.05, 0.5], goal: [0.9, 0.5], width: 1.0,
    platforms: [
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
      [0, 0.58, 0.15, 0.03], [0.85, 0.58, 0.15, 0.03],
    ],
    spikes: [[0.35, 0.0, 0.06, 0.15], [0.6, 0.85, 0.06, 0.15]],
    orbs: [[0.2, 0.3], [0.5, 0.5], [0.8, 0.7]],
    wells: [[0.3, 0.35, 0.3, 90], [0.7, 0.65, 0.3, 90]],
    lasers: [[0.48, 0.15, 0.04, 0.3, 1.6, 2.0, 0.5]],
    winds: [[0.4, 0.4, 0.2, 0.2, 1, 0, 0.5]]
  },
  // 10
  { name: 'Grand Finale', stars: [35,25,18],
    spawn: [0.05, 0.3], goal: [0.9, 0.7], width: 1.0,
    platforms: [
      [0, 0.4, 0.2, 0.03],
      [0.25, 0.6, 0.15, 0.03, 'bouncy'],
      [0.35, 0.5, 0.1, 0.03, 'moving', 0, 0.08, 1.5],
      [0.45, 0.35, 0.1, 0.03, 'crumble'],
      [0.6, 0.55, 0.15, 0.03],
      [0.8, 0.4, 0.1, 0.03, 'crumble'],
      [0.8, 0.75, 0.2, 0.03],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [
      [0.2, 0.02, 0.05, 0.08],
      [0.4, 0.9, 0.15, 0.06],
      [0.55, 0.02, 0.05, 0.08],
      [0.75, 0.9, 0.05, 0.06],
    ],
    orbs: [[0.1, 0.25], [0.5, 0.2], [0.85, 0.62]],
    wells: [[0.5, 0.65, 0.25, 80]],
    lasers: [[0.7, 0.02, 0.03, 0.35, 1.3, 2.0, 1.0]]
  },
  // 11-15
  { name: 'Tunnel Vision', stars: [20,14,9],
    spawn: [0.05, 0.48], goal: [0.9, 0.48], width: 1.0,
    platforms: [
      [0, 0.42, 1.0, 0.02], [0, 0.56, 1.0, 0.02],
    ],
    spikes: [
      [0.2, 0.44, 0.05, 0.04],
      [0.35, 0.52, 0.05, 0.04],
      [0.5, 0.44, 0.05, 0.04],
      [0.65, 0.52, 0.05, 0.04],
      [0.8, 0.44, 0.05, 0.04],
    ],
    orbs: [[0.28, 0.48], [0.58, 0.48], [0.88, 0.48]],
    wells: [],
    lasers: [[0.27, 0.44, 0.03, 0.12, 1.2, 1.8, 0], [0.57, 0.44, 0.03, 0.12, 1.2, 1.8, 0.9]]
  },
  { name: 'Double Well', stars: [30,22,15],
    spawn: [0.05, 0.2], goal: [0.9, 0.8], width: 1.0,
    platforms: [
      [0, 0.3, 0.2, 0.03], [0.8, 0.7, 0.2, 0.03],
      [0.4, 0.5, 0.12, 0.03, 'moving', 0, 0.1, 1.2],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [[0.45, 0.45, 0.1, 0.1]],
    orbs: [[0.1, 0.15], [0.5, 0.3], [0.9, 0.65]],
    wells: [[0.3, 0.5, 0.4, 110], [0.7, 0.5, 0.4, 110]]
  },
  { name: 'Bounce Maze', stars: [25,18,12],
    spawn: [0.05, 0.3], goal: [0.9, 0.7], width: 1.0,
    platforms: [
      [0, 0.4, 0.2, 0.03, 'bouncy'],
      [0.3, 0.6, 0.15, 0.03, 'bouncy'],
      [0.5, 0.3, 0.15, 0.03, 'bouncy'],
      [0.7, 0.5, 0.15, 0.03, 'moving', 0.08, 0, 1.0],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [[0.25, 0.02, 0.05, 0.1], [0.5, 0.88, 0.1, 0.1], [0.75, 0.02, 0.05, 0.1]],
    orbs: [[0.15, 0.15], [0.45, 0.15], [0.85, 0.6]],
    wells: [],
    lasers: [[0.44, 0.4, 0.03, 0.25, 1.5, 2.5, 0.8]]
  },
  { name: 'Crumble Run', stars: [22,16,11],
    spawn: [0.05, 0.35], goal: [0.9, 0.35], width: 1.0,
    platforms: [
      [0, 0.45, 0.1, 0.03],
      [0.12, 0.45, 0.1, 0.03, 'crumble'],
      [0.24, 0.45, 0.1, 0.03, 'crumble'],
      [0.36, 0.45, 0.1, 0.03, 'crumble'],
      [0.48, 0.45, 0.1, 0.03, 'crumble'],
      [0.6, 0.45, 0.1, 0.03, 'crumble'],
      [0.72, 0.45, 0.1, 0.03, 'crumble'],
      [0.84, 0.45, 0.16, 0.03],
      [0, 0.0, 1.0, 0.02],
    ],
    spikes: [[0, 0.96, 1.0, 0.04]],
    orbs: [[0.2, 0.3], [0.5, 0.3], [0.8, 0.3]],
    wells: [],
    lasers: [[0.76, 0.1, 0.03, 0.35, 1.5, 2.2, 1.0]]
  },
  { name: 'Everything', stars: [40,30,20],
    spawn: [0.05, 0.25], goal: [0.9, 0.75], width: 1.0,
    platforms: [
      [0, 0.35, 0.15, 0.03],
      [0.2, 0.55, 0.12, 0.03, 'bouncy'],
      [0.38, 0.3, 0.1, 0.03, 'crumble'],
      [0.48, 0.5, 0.08, 0.03, 'moving', 0, 0.06, 1.3],
      [0.55, 0.65, 0.12, 0.03, 'moving', 0, 0.1, 0.8],
      [0.7, 0.4, 0.1, 0.03, 'crumble'],
      [0.85, 0.8, 0.15, 0.03],
      [0, 0.0, 1.0, 0.02], [0, 0.98, 1.0, 0.02],
    ],
    spikes: [
      [0.15, 0.02, 0.05, 0.08],
      [0.35, 0.9, 0.08, 0.06],
      [0.6, 0.02, 0.05, 0.08],
      [0.8, 0.9, 0.05, 0.06],
    ],
    orbs: [[0.1, 0.18], [0.5, 0.2], [0.9, 0.68]],
    wells: [[0.45, 0.5, 0.3, 90]],
    lasers: [[0.32, 0.35, 0.03, 0.28, 1.4, 2.0, 0.3], [0.65, 0.35, 0.03, 0.28, 1.4, 2.0, 1.3]],
    winds: [[0.15, 0.0, 0.25, 0.3, 0, 1, 0.35], [0.6, 0.7, 0.25, 0.28, -1, 0, 0.4]]
  },
];

// ============================================================
// PROCEDURAL LEVEL GENERATION
// ============================================================
function seededRandom(seed) {
  let s = seed;
  return function() {
    s = (s * 1664525 + 1013904223) & 0xFFFFFFFF;
    return (s >>> 0) / 0xFFFFFFFF;
  };
}

function generateProceduralLevel(index) {
  const difficulty = index - LEVELS.length + 1; // 1, 2, 3, ...
  const rng = seededRandom(index * 7919 + 42);
  const names = ['Void Walk','Nebula Run','Star Drift','Dark Matter','Quantum Leap',
    'Warp Zone','Singularity','Nova Burst','Cosmic Drift','Antimatter',
    'Photon Path','Ion Storm','Pulsar Way','Quasar Run','Event Horizon'];
  const name = names[index % names.length] + (index >= names.length ? ` ${Math.floor(index / names.length) + 1}` : '');

  const numPlatforms = 4 + Math.min(8, Math.floor(difficulty * 0.8));
  const numSpikes = 2 + Math.min(6, Math.floor(difficulty * 0.6));
  const numOrbs = 3;
  const hasWell = difficulty >= 3 && rng() > 0.4;
  const hasLaser = difficulty >= 5 && rng() > 0.3;

  const platforms = [];
  // Top and bottom boundaries
  platforms.push([0, 0.0, 1.0, 0.02]);
  platforms.push([0, 0.98, 1.0, 0.02]);
  // Starting platform
  platforms.push([0, 0.5, 0.12, 0.03]);

  for (let i = 0; i < numPlatforms; i++) {
    const px = 0.12 + (i / numPlatforms) * 0.75;
    const py = 0.15 + rng() * 0.65;
    const pw = 0.06 + rng() * 0.12;
    const types = ['solid', 'solid', 'solid'];
    if (difficulty >= 2) types.push('bouncy');
    if (difficulty >= 3) types.push('crumble');
    if (difficulty >= 4) types.push('moving');
    const type = types[Math.floor(rng() * types.length)];
    const p = [px, py, pw, 0.03, type];
    if (type === 'moving') {
      p.push(rng() > 0.5 ? 0.05 + rng() * 0.08 : 0);
      p.push(rng() > 0.5 ? 0.04 + rng() * 0.06 : 0);
      p.push(0.8 + rng() * 1.0);
    }
    platforms.push(p);
  }
  // End platform
  platforms.push([0.88, 0.3 + rng() * 0.4, 0.12, 0.03]);

  const spikes = [];
  for (let i = 0; i < numSpikes; i++) {
    const sx = 0.1 + rng() * 0.75;
    const sy = rng() > 0.5 ? 0.02 + rng() * 0.05 : 0.88 + rng() * 0.08;
    spikes.push([sx, sy, 0.04 + rng() * 0.06, 0.04 + rng() * 0.04]);
  }

  const orbs = [];
  for (let i = 0; i < numOrbs; i++) {
    orbs.push([0.15 + (i / numOrbs) * 0.7 + rng() * 0.1, 0.15 + rng() * 0.6]);
  }

  const wells = hasWell ? [[0.3 + rng() * 0.4, 0.3 + rng() * 0.4, 0.2 + rng() * 0.15, 70 + difficulty * 10]] : [];
  const lasers = hasLaser ? [[0.2 + rng() * 0.6, 0.1 + rng() * 0.3, 0.03, 0.2 + rng() * 0.2, 1.2 + rng() * 0.5, 1.8 + rng() * 0.8, rng() * 2]] : [];

  const baseTime = 12 + difficulty * 2;
  return {
    name,
    stars: [baseTime, baseTime + 5, baseTime + 10],
    spawn: [0.05, 0.4],
    goal: [0.92, platforms[platforms.length - 1][1]],
    width: 1.0,
    platforms, spikes, orbs, wells, lasers,
    procedural: true
  };
}

function getLevelData(index) {
  if (isCustomLevel && customLevelIndex >= 0) {
    return customLevels[customLevelIndex];
  }
  if (index < LEVELS.length) return LEVELS[index];
  return generateProceduralLevel(index);
}

// ============================================================
// LEVEL INITIALIZATION
// ============================================================
function startLevel(index, levelData) {
  lvl = index;
  const L = levelData || getLevelData(index);

  const p = new Player(W * L.spawn[0], H * L.spawn[1]);
  p.invuln = 0.5; // brief invulnerability on spawn

  const platforms = L.platforms.map(d => {
    const pl = new Platform(W * d[0], H * d[1], W * d[2], H * d[3], d[4] || 'solid');
    // Moving platform ranges: d[5] = moveRangeX fraction, d[6] = moveRangeY fraction, d[7] = speed
    if (d[4] === 'moving' || d[5] || d[6]) {
      pl.type = pl.type === 'solid' && (d[5] || d[6]) ? 'moving' : pl.type;
      if (d[4] === 'moving') pl.type = 'moving';
      pl.moveRangeX = (d[5] || 0) * W;
      pl.moveRangeY = (d[6] || 0) * H;
      pl.moveSpeed = d[7] || 1;
    }
    return pl;
  });

  const spikes = L.spikes.map(d => new Spike(W * d[0], H * d[1], W * d[2], H * d[3]));
  const orbs = L.orbs.map(d => new Orb(W * d[0], H * d[1]));
  const wells = (L.wells || []).map(d => new GravityWell(W * d[0], H * d[1], d[2], d[3]));
  const lasers = (L.lasers || []).map(d => new LaserBeam(W * d[0], H * d[1], W * d[2], H * d[3], d[4], d[5], d[6]));
  const winds = (L.winds || []).map(d => new WindZone(W * d[0], H * d[1], W * d[2], H * d[3], d[4], d[5], d[6]));
  const portal = new Portal(W * L.goal[0], H * L.goal[1]);

  sessionNearMisses = 0;

  gs = {
    player: p, platforms, spikes, orbs, portal, wells, lasers, winds,
    time: 0, orbsCollected: 0, totalOrbs: orbs.length,
    dead: false, won: false,
    deathCount: 0,
    btns: {},
    levelStartTime: performance.now(),
    isDaily: !!levelData
  };
  
  combo = 0; comboTimer = 0;
  particles = [];
  floatingTexts = [];
  speedLines = [];
  screen = 'game';
  screenShake = 0;
  screenFlash = 0;
  deathTimer = 0;
  nearMissTimer = 0;
  slowMo = 0;
  cameraZoom = 1;
  cameraZoomTarget = 1;
  currentAccent = (levelColors[index % levelColors.length] || levelColors[0]).accent;

  ensureAudio();
  startMusic();
}

// ============================================================
// GAME UPDATE
// ============================================================
function updateGame() {
  if (gs.won) return;
  
  if (gs.dead) {
    deathTimer -= dt;
    updateParticles();
    screenShake *= 0.9;
    if (deathTimer <= 0) startLevel(lvl);
    return;
  }
  
  gs.time += dt;
  const p = gs.player;
  p.update();
  
  // Combo timer
  if (comboTimer > 0) {
    comboTimer -= dt;
    if (comboTimer <= 0) combo = 0;
  }
  
  // Near miss cooldown
  if (nearMissTimer > 0) nearMissTimer -= dt;
  
  // Update objects
  gs.platforms.forEach(pl => pl.update());
  gs.spikes.forEach(s => s.update());
  gs.orbs.forEach(o => o.update());
  gs.portal.update();
  gs.wells.forEach(w => w.update());
  gs.lasers.forEach(l => l.update());
  if (gs.winds) gs.winds.forEach(w => w.update());

  // Gravity wells
  gs.wells.forEach(w => w.applyForce(p));
  // Wind zones
  if (gs.winds) gs.winds.forEach(w => w.applyForce(p));
  
  // Platform collisions
  gs.platforms.forEach(pl => pl.handleCollision(p));
  
  // Orb collection
  gs.orbs.forEach(o => {
    if (o.check(p)) {
      gs.orbsCollected++;
      combo++;
      comboTimer = 2.5;
      sfxCollect();
      if (combo > 1) {
        sfxCombo();
        addFloatingText(o.x, o.y - 20 * S, `${combo}x COMBO!`, '#ffd700', 22 + combo * 2);
        // Combo speed boost
        p.vx *= 1 + combo * 0.05;
        cameraZoomTarget = 1 + combo * 0.01;
        setTimeout(() => { cameraZoomTarget = 1; }, 300);
      }
      const points = 10 * combo;
      addFloatingText(o.x, o.y, `+${points}`, currentAccent, 16);
      screenShake = Math.max(screenShake, 3 + combo * 1.5);
      slowMo = 0.08; // tiny freeze frame on collect
    }
  });
  
  // Activate portal
  const wasActive = gs.portal.active;
  gs.portal.active = gs.orbsCollected >= gs.totalOrbs;
  if (gs.portal.active && !wasActive) {
    // Portal activation fanfare
    emit(gs.portal.x, gs.portal.y, 25, '#ffd700', 4, 0, { shape: 'circle' });
    screenShake = 6;
    screenFlash = 0.2;
    screenFlashColor = '#ffd700';
    addFloatingText(gs.portal.x, gs.portal.y - 30 * S, 'PORTAL OPEN!', '#ffd700', 18);
    tone(880, 0.2, 'sine', 0.15);
    tone(1100, 0.15, 'sine', 0.1, 0.1);
  }
  if (gs.portal.active) {
    emitTrail(gs.portal.x + (Math.random()-0.5) * 30 * S, 
              gs.portal.y + (Math.random()-0.5) * 30 * S, '#ffd700');
  }
  
  // Spike check
  for (const s of gs.spikes) {
    if (s.check(p)) { killPlayer(); return; }
    // Near miss - dramatic slow-mo moment
    if (nearMissTimer <= 0 && s.nearMiss(p)) {
      nearMissTimer = 0.5;
      sfxNearMiss();
      slowMo = 0.15; // brief time slowdown
      sessionNearMisses++;
      totalNearMisses++;
      saveNearMisses();
      addFloatingText(p.x, p.y - 25 * S, 'CLOSE!', '#ff4488', 16);
      emitSpark(p.x, p.y, '#ff4488', 5);
      screenShake = Math.max(screenShake, 3);
    }
  }

  // Laser check
  for (const l of gs.lasers) {
    if (l.check(p)) { sfxLaser(); killPlayer(); return; }
  }
  
  // Out of bounds
  if (p.x < -50 || p.x > W + 50 || p.y < -80 || p.y > H + 80) {
    killPlayer(); return;
  }
  
  // Win
  if (gs.portal.check(p)) {
    gs.won = true;
    winLevel();
    return;
  }
  
  updateParticles();
  screenShake *= 0.85;
  if (screenFlash > 0) screenFlash -= dt * 3;
}

function killPlayer() {
  gs.dead = true;
  gs.deathCount++;
  sfxDeath();
  screenShake = 22;
  screenFlash = 0.4;
  screenFlashColor = '#ff0044';
  slowMo = 0.4; // dramatic slow-mo
  cameraZoomTarget = 1.15; // zoom in on death
  setTimeout(() => { cameraZoomTarget = 1; }, 600);
  
  // Death explosion - bigger and more dramatic
  emit(gs.player.x, gs.player.y, 45, '#ff0064', 7, 0.1, { shape: 'rect' });
  emit(gs.player.x, gs.player.y, 25, currentAccent, 5, 0.08, { shape: 'circle' });
  emit(gs.player.x, gs.player.y, 15, '#ffffff', 4, 0.05, { size: 2, shape: 'circle' });
  // Shockwave ring
  emit(gs.player.x, gs.player.y, 20, '#ff4488', 8, 0, { shape: 'circle', size: 1.5 });
  gs.player.alive = false;
  deathTimer = 1.2;
}

function winLevel() {
  const time = gs.time;
  const L = gs.isDaily ? { stars: [20, 14, 9], name: 'Daily Challenge' } : getLevelData(lvl);
  let stars = 1;
  if (time <= L.stars[1]) stars = 2;
  if (time <= L.stars[0]) stars = 3;

  gs.victoryStars = stars;
  gs.victoryTime = time;
  victoryAnimTime = 0;

  const levelId = isCustomLevel ? 'custom_' + customLevelIndex : (isInfiniteMode ? 'inf_' + lvl : '' + lvl);
  addLeaderboardEntry(levelId, time, stars, gs.deathCount);

  if (!isCustomLevel && !gs.isDaily) {
    if (!progress[lvl] || progress[lvl].stars < stars) {
      progress[lvl] = { completed: true, stars, time };
      saveProgress();
      calcTotalStars();
    } else if (progress[lvl] && time < progress[lvl].time) {
      progress[lvl].time = time;
      saveProgress();
    }
  }
  
  // Score calculation
  const baseScore = 100 + lvl * 50;
  const timeBonus = Math.max(0, Math.floor((L.stars[0] * 2 - time) * 10));
  const deathPenalty = gs.deathCount * 20;
  const levelScore = Math.max(10, baseScore + timeBonus - deathPenalty + stars * 50);
  gs.levelScore = levelScore;
  if (!isCustomLevel) {
    totalScore += levelScore;
    saveTotalScore();
  }
  
  // Save daily challenge completion
  if (gs.isDaily) {
    try { localStorage.setItem('gflip3_daily', JSON.stringify({ seed: getDailySeed(), time, stars })); } catch(e) {}
    dailyChallengeCompleted = true;
  }

  sfxWin();
  screenShake = 12;
  screenFlash = 0.35;
  screenFlashColor = '#ffd700';
  slowMo = 0.5;
  cameraZoomTarget = 1.1;
  setTimeout(() => { cameraZoomTarget = 1; }, 800);
  
  // Big win burst
  for (let i = 0; i < 5; i++) {
    setTimeout(() => {
      emit(gs.portal.x + (Math.random()-0.5) * 60 * S, 
           gs.portal.y + (Math.random()-0.5) * 60 * S, 
           12, '#ffd700', 4, 0.1, { shape: 'circle' });
    }, i * 100);
  }
  
  setTimeout(() => { screen = 'victory'; }, 700);
}

// ============================================================
// GAME DRAW
// ============================================================
function drawGame() {
  X.save();
  if (screenShake > 0.5) {
    X.translate(
      (Math.random() - 0.5) * screenShake * S,
      (Math.random() - 0.5) * screenShake * S
    );
  }
  
  gs.wells.forEach(w => w.draw());
  gs.lasers.forEach(l => l.draw());
  if (gs.winds) gs.winds.forEach(w => w.draw());
  gs.platforms.forEach(pl => pl.draw());
  gs.spikes.forEach(s => s.draw());
  gs.orbs.forEach(o => o.draw());
  gs.portal.draw();
  gs.player.draw();
  drawParticles();
  
  X.restore();
  
  // Screen flash
  if (screenFlash > 0) {
    X.save();
    X.globalAlpha = screenFlash * 0.4;
    X.fillStyle = screenFlashColor;
    X.fillRect(0, 0, W, H);
    X.restore();
  }
  
  // HUD
  drawHUD();
  
  // Tutorial hints
  if (lvl === 0 && gs.time < 4 && !gs.dead) {
    X.save();
    const a = Math.max(0, 1 - gs.time / 4);
    X.globalAlpha = a;
    
    // Animated hand tap icon
    const handY = H * 0.7 + Math.sin(gt * 4) * 8 * S;
    X.font = `${28 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('üëÜ', W/2, handY);
    
    X.fillStyle = '#fff';
    X.font = `bold ${20 * S}px sans-serif`;
    X.shadowColor = '#00ffff';
    X.shadowBlur = 10 * S;
    X.fillText('TAP TO FLIP!', W/2, H * 0.7 + 30 * S);
    X.restore();
  }
  
  // Death overlay
  if (gs.dead) {
    X.save();
    const a = Math.min(0.5, (1.0 - deathTimer) * 0.7);
    X.fillStyle = `rgba(200,0,40,${a * 0.2})`;
    X.fillRect(0, 0, W, H);
    
    // "Oops" text
    if (deathTimer < 0.7) {
      X.globalAlpha = Math.min(1, (0.7 - deathTimer) * 3);
      X.fillStyle = '#ff4466';
      X.font = `bold ${24 * S}px sans-serif`;
      X.textAlign = 'center';
      X.shadowColor = '#ff0044';
      X.shadowBlur = 10 * S;
      const texts = ['OOPS!', 'SPLAT!', 'NOPE!', 'OOF!', 'YIKES!'];
      X.fillText(texts[gs.deathCount % texts.length], W/2, H * 0.45);
    }
    X.restore();
  }
}

function drawHUD() {
  X.save();
  
  // Semi-transparent HUD background
  X.fillStyle = 'rgba(0,0,0,0.3)';
  X.fillRect(0, 0, W, 55 * S);
  
  // Level name with progress
  X.fillStyle = 'rgba(255,255,255,0.7)';
  X.font = `${13 * S}px sans-serif`;
  X.textAlign = 'left';
  const curLevelData = getLevelData(lvl);
  const levelLabel = gs.isDaily ? '‚òÄ Daily Challenge' : isInfiniteMode ? `‚àû ${lvl - LEVELS.length + 1}` : isCustomLevel ? 'Custom' : `${lvl + 1}/${LEVELS.length}`;
  X.fillText(`${levelLabel}  ${curLevelData.name}`, 12 * S, 20 * S);

  // Level progress bar
  const progW = 80 * S;
  const progH = 2.5 * S;
  const progX = 12 * S;
  const progY = 26 * S;
  X.fillStyle = 'rgba(255,255,255,0.08)';
  X.beginPath();
  X.roundRect(progX, progY, progW, progH, progH / 2);
  X.fill();
  X.fillStyle = currentAccent;
  X.shadowColor = currentAccent;
  X.shadowBlur = 3 * S;
  const progFill = gs.isDaily ? 1 : isInfiniteMode ? 1 : (lvl + 1) / LEVELS.length;
  X.beginPath();
  X.roundRect(progX, progY, Math.max(progH, progW * progFill), progH, progH / 2);
  X.fill();
  X.shadowBlur = 0;
  
  // Orb counter with icons
  const orbFull = gs.orbsCollected >= gs.totalOrbs;
  X.fillStyle = orbFull ? '#ffd700' : '#4488ff';
  X.font = `bold ${16 * S}px sans-serif`;
  X.shadowColor = orbFull ? '#ffd700' : '#4488ff';
  X.shadowBlur = orbFull ? 8 * S : 0;
  
  // Draw orb icons
  for (let i = 0; i < gs.totalOrbs; i++) {
    const ox = 12 * S + i * 20 * S;
    const oy = 38 * S;
    if (i < gs.orbsCollected) {
      X.fillStyle = '#4488ff';
      X.shadowColor = '#4488ff';
      X.shadowBlur = 6 * S;
      X.beginPath();
      X.arc(ox, oy, 5 * S, 0, Math.PI * 2);
      X.fill();
      // Highlight
      X.fillStyle = '#fff';
      X.shadowBlur = 0;
      X.beginPath();
      X.arc(ox - 1.5 * S, oy - 1.5 * S, 1.5 * S, 0, Math.PI * 2);
      X.fill();
    } else {
      X.strokeStyle = 'rgba(68,136,255,0.3)';
      X.lineWidth = 1.5 * S;
      X.shadowBlur = 0;
      X.beginPath();
      X.arc(ox, oy, 5 * S, 0, Math.PI * 2);
      X.stroke();
    }
  }
  
  // Timer
  X.fillStyle = '#fff';
  X.textAlign = 'right';
  X.font = `${15 * S}px monospace`;
  X.shadowBlur = 0;
  X.fillText(`${gs.time.toFixed(1)}s`, W - 12 * S, 20 * S);
  
  // Star time targets
  const L = gs.isDaily ? { stars: [20, 14, 9] } : getLevelData(lvl);
  X.font = `${10 * S}px sans-serif`;
  X.fillStyle = gs.time <= L.stars[0] ? '#ffd700' : 'rgba(255,215,0,0.3)';
  X.fillText(`‚≠ê‚≠ê‚≠ê < ${L.stars[0]}s`, W - 12 * S, 36 * S);
  
  // Gravity indicator
  X.globalAlpha = 0.5;
  X.fillStyle = '#00ffff';
  X.font = `${11 * S}px sans-serif`;
  X.fillText(gs.player.gravDir === 1 ? '‚ñº DOWN' : '‚ñ≤ UP', W - 12 * S, 50 * S);
  
  // Combo display
  if (combo > 1 && comboTimer > 0) {
    X.globalAlpha = Math.min(1, comboTimer);
    X.fillStyle = '#ffd700';
    X.font = `bold ${22 * S}px sans-serif`;
    X.textAlign = 'center';
    X.shadowColor = '#ffd700';
    X.shadowBlur = 12 * S;
    const comboScale = 1 + Math.max(0, (comboTimer - 1.5)) * 3;
    X.save();
    X.translate(W/2, 75 * S);
    X.scale(comboScale, comboScale);
    X.fillText(`${combo}x COMBO!`, 0, 0);
    X.restore();
  }
  
  // Death counter (subtle)
  if (gs.deathCount > 0) {
    X.globalAlpha = 0.4;
    X.fillStyle = '#ff4466';
    X.font = `${10 * S}px sans-serif`;
    X.textAlign = 'left';
    X.shadowBlur = 0;
    X.fillText(`üíÄ ${gs.deathCount}`, 12 * S, 52 * S);
  }
  
  X.restore();
}

// ============================================================
// MENU
// ============================================================
function drawMenu() {
  menuPulse += dt;
  
  // Floating character
  const orbY = H * 0.18 + Math.sin(gt * 1.5) * 12 * S;
  const orbX = W/2 + Math.sin(gt * 0.7) * 8 * S;
  
  X.save();
  // Big glow
  const bigGrad = X.createRadialGradient(orbX, orbY, 0, orbX, orbY, 60 * S);
  bigGrad.addColorStop(0, 'rgba(0,255,255,0.15)');
  bigGrad.addColorStop(1, 'rgba(0,255,255,0)');
  X.fillStyle = bigGrad;
  X.beginPath(); X.arc(orbX, orbY, 60 * S, 0, Math.PI * 2); X.fill();
  
  // Character
  const charGrad = X.createRadialGradient(orbX - 5*S, orbY - 5*S, 0, orbX, orbY, 22*S);
  charGrad.addColorStop(0, '#88ffff');
  charGrad.addColorStop(0.5, '#00ffff');
  charGrad.addColorStop(1, '#00aacc');
  X.fillStyle = charGrad;
  X.shadowColor = '#00ffff'; X.shadowBlur = 30 * S;
  X.beginPath(); X.arc(orbX, orbY, 22 * S, 0, Math.PI * 2); X.fill();
  
  // Eyes
  X.fillStyle = '#fff'; X.shadowBlur = 0;
  X.beginPath();
  X.arc(orbX - 6*S, orbY - 3*S, 4*S, 0, Math.PI*2);
  X.arc(orbX + 6*S, orbY - 3*S, 4*S, 0, Math.PI*2);
  X.fill();
  X.fillStyle = '#111';
  X.beginPath();
  X.arc(orbX - 5*S, orbY - 3*S, 2.5*S, 0, Math.PI*2);
  X.arc(orbX + 7*S, orbY - 3*S, 2.5*S, 0, Math.PI*2);
  X.fill();
  X.fillStyle = '#fff';
  X.beginPath();
  X.arc(orbX - 6.5*S, orbY - 4.5*S, 1.2*S, 0, Math.PI*2);
  X.arc(orbX + 5.5*S, orbY - 4.5*S, 1.2*S, 0, Math.PI*2);
  X.fill();
  
  // Smile
  X.strokeStyle = '#005566';
  X.lineWidth = 1.5 * S;
  X.beginPath();
  X.arc(orbX, orbY + 1*S, 6*S, 0.1 * Math.PI, 0.9 * Math.PI);
  X.stroke();
  X.restore();
  
  // Title with slight animation
  const titleY = H * 0.35;
  drawNeonText('GRAVITY', W/2, titleY, 46, '#00ffff');
  drawNeonText('FLIP', W/2, titleY + 52 * S, 46, '#00ffff');
  
  // Subtitle
  X.save();
  X.fillStyle = 'rgba(255,255,255,0.45)';
  X.font = `${13 * S}px sans-serif`;
  X.textAlign = 'center';
  X.fillText('Tap to flip gravity ‚Ä¢ Collect orbs ‚Ä¢ Reach the portal', W/2, titleY + 85 * S);
  X.restore();
  
  const bw = 200 * S, bh = 46 * S;
  const btnY = H * 0.50;
  const btnGap = 10 * S;
  gs.btns = gs.btns || {};
  gs.btns.start = drawBtn(W/2 - bw/2, btnY, bw, bh, '‚ñ∂  PLAY');
  gs.btns.select = drawBtn(W/2 - bw/2, btnY + bh + btnGap, bw, bh, 'üìã  LEVELS', false);
  gs.btns.infinite = drawBtn(W/2 - bw/2, btnY + (bh + btnGap) * 2, bw, bh, '‚àû  INFINITE', false);
  gs.btns.daily = drawBtn(W/2 - bw/2, btnY + (bh + btnGap) * 3, bw, bh, '‚òÄ  DAILY', false);
  gs.btns.editor = drawBtn(W/2 - bw/2, btnY + (bh + btnGap) * 4, bw, bh, 'üîß  EDITOR', false);

  // Small buttons row
  const smallW = 95 * S, smallH = 36 * S;
  gs.btns.stats = drawBtn(W/2 - smallW - 5 * S, btnY + (bh + btnGap) * 5, smallW, smallH, 'STATS', false);
  gs.btns.leaders = drawBtn(W/2 + 5 * S, btnY + (bh + btnGap) * 5, smallW, smallH, 'TOP 20', false);
  gs.btns.leaderboard = drawBtn(W/2 - bw/2, btnY + (bh + btnGap) * 5 + smallH + btnGap, bw, smallH, 'üèÜ  TIMES', false);

  // Stars and score display
  if (bestTotalStars > 0 || totalScore > 0) {
    X.save();
    X.fillStyle = '#ffd700';
    X.font = `bold ${13 * S}px sans-serif`;
    X.textAlign = 'center';
    X.shadowColor = '#ffd700';
    X.shadowBlur = 6 * S;
    X.fillText(`‚≠ê ${bestTotalStars} / ${LEVELS.length * 3}`, W/2, H * 0.93);
    if (totalScore > 0) {
      X.fillStyle = '#00ffff';
      X.shadowColor = '#00ffff';
      X.fillText(`Score: ${totalScore}`, W/2, H * 0.97);
    }
    X.restore();
  }
}

// ============================================================
// STATS SCREEN
// ============================================================
function drawStatsScreen() {
  drawNeonText('STATISTICS', W/2, 50 * S, 26, '#00ffff');

  const stats = getStats();
  const items = [
    { label: 'Levels Completed', value: `${stats.levelsCompleted} / ${LEVELS.length}` },
    { label: 'Total Stars', value: `${stats.totalStars} / ${LEVELS.length * 3}` },
    { label: 'Total Score', value: `${stats.totalScore}` },
    { label: 'Near Misses', value: `${stats.totalNearMisses}` },
  ];

  const startY = 100 * S;
  items.forEach((item, i) => {
    const y = startY + i * 55 * S;
    X.save();
    X.fillStyle = 'rgba(0,255,255,0.06)';
    X.beginPath();
    X.roundRect(W * 0.1, y, W * 0.8, 42 * S, 6 * S);
    X.fill();
    X.strokeStyle = 'rgba(0,255,255,0.15)';
    X.lineWidth = 1 * S;
    X.stroke();

    X.fillStyle = 'rgba(255,255,255,0.6)';
    X.font = `${14 * S}px sans-serif`;
    X.textAlign = 'left';
    X.fillText(item.label, W * 0.15, y + 27 * S);

    X.fillStyle = '#00ffff';
    X.font = `bold ${16 * S}px sans-serif`;
    X.textAlign = 'right';
    X.fillText(item.value, W * 0.85, y + 27 * S);
    X.restore();
  });

  // Best times
  if (stats.bestTimes.length > 0) {
    const btY = startY + items.length * 55 * S + 20 * S;
    X.save();
    X.fillStyle = 'rgba(255,255,255,0.5)';
    X.font = `bold ${13 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('BEST TIMES', W/2, btY);
    stats.bestTimes.forEach((bt, i) => {
      if (i >= 8) return;
      const ty = btY + 22 * S + i * 22 * S;
      X.fillStyle = 'rgba(255,255,255,0.4)';
      X.font = `${11 * S}px sans-serif`;
      X.textAlign = 'left';
      X.fillText(`${bt.level + 1}. ${LEVELS[bt.level].name}`, W * 0.15, ty);
      X.textAlign = 'right';
      X.fillStyle = '#ffd700';
      X.fillText(`${bt.time.toFixed(1)}s`, W * 0.85, ty);
    });
    X.restore();
  }

  gs.btns = gs.btns || {};
  gs.btns.back = drawBtn(W/2 - 50 * S, H - 60 * S, 100 * S, 42 * S, '‚Üê BACK', false);
}

// ============================================================
// LEADERBOARD SCREEN
// ============================================================
function drawLeaderboardScreen() {
  drawNeonText('TOP 20', W/2, 50 * S, 26, '#ffd700');

  if (leaderboard.length === 0) {
    X.save();
    X.fillStyle = 'rgba(255,255,255,0.4)';
    X.font = `${14 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('No scores yet! Complete a level.', W/2, H * 0.4);
    X.restore();
  } else {
    const startY = 85 * S;
    leaderboard.forEach((entry, i) => {
      if (i >= 15) return;
      const y = startY + i * 28 * S;
      const isTop3 = i < 3;
      X.save();
      if (isTop3) {
        X.fillStyle = ['rgba(255,215,0,0.08)', 'rgba(192,192,192,0.06)', 'rgba(205,127,50,0.05)'][i];
        X.fillRect(W * 0.08, y - 8 * S, W * 0.84, 26 * S);
      }
      // Rank
      X.fillStyle = isTop3 ? ['#ffd700', '#c0c0c0', '#cd7f32'][i] : 'rgba(255,255,255,0.4)';
      X.font = `bold ${12 * S}px sans-serif`;
      X.textAlign = 'left';
      X.fillText(`${i + 1}.`, W * 0.1, y + 6 * S);
      // Name
      X.fillStyle = '#fff';
      X.font = `bold ${13 * S}px monospace`;
      X.fillText(entry.name || '???', W * 0.2, y + 6 * S);
      // Score
      X.fillStyle = '#00ffff';
      X.font = `${13 * S}px sans-serif`;
      X.textAlign = 'right';
      X.fillText(`${entry.score}`, W * 0.7, y + 6 * S);
      // Level
      X.fillStyle = 'rgba(255,255,255,0.3)';
      X.font = `${10 * S}px sans-serif`;
      X.fillText(`Lv.${entry.level + 1}`, W * 0.9, y + 6 * S);
      X.restore();
    });
  }

  gs.btns = gs.btns || {};
  gs.btns.back = drawBtn(W/2 - 50 * S, H - 60 * S, 100 * S, 42 * S, '‚Üê BACK', false);
}

// ============================================================
// INITIALS ENTRY SCREEN
// ============================================================
function drawInitialsEntry() {
  X.save();
  X.fillStyle = 'rgba(0,0,0,0.92)';
  X.fillRect(0, 0, W, H);
  X.restore();

  drawNeonText('NEW HIGH SCORE!', W/2, H * 0.2, 22, '#ffd700');

  X.save();
  X.fillStyle = '#00ffff';
  X.font = `bold ${28 * S}px sans-serif`;
  X.textAlign = 'center';
  X.fillText(`${initialsScore}`, W/2, H * 0.32);
  X.restore();

  // Initials boxes
  X.save();
  X.fillStyle = 'rgba(255,255,255,0.5)';
  X.font = `${14 * S}px sans-serif`;
  X.textAlign = 'center';
  X.fillText('Enter your initials:', W/2, H * 0.42);

  for (let i = 0; i < 3; i++) {
    const bx = W/2 + (i - 1) * 50 * S;
    const by = H * 0.48;
    const bw = 40 * S, bhh = 50 * S;

    X.fillStyle = i === initialsCursor ? 'rgba(0,255,255,0.15)' : 'rgba(255,255,255,0.05)';
    X.beginPath();
    X.roundRect(bx - bw/2, by, bw, bhh, 6 * S);
    X.fill();
    X.strokeStyle = i === initialsCursor ? '#00ffff' : 'rgba(255,255,255,0.2)';
    X.lineWidth = 2 * S;
    X.stroke();

    const ch = initialsText[i] || (i === initialsCursor ? '_' : '');
    X.fillStyle = '#fff';
    X.font = `bold ${28 * S}px monospace`;
    X.textAlign = 'center';
    if (i === initialsCursor && !initialsText[i]) {
      X.globalAlpha = 0.4 + Math.sin(gt * 5) * 0.3;
    }
    X.fillText(ch, bx, by + 35 * S);
    X.globalAlpha = 1;
  }
  X.restore();

  // Letter grid
  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const cols = 7;
  const gridStartY = H * 0.62;
  const cellSize = 38 * S;
  const gridW = cols * cellSize;
  const gridStartX = W/2 - gridW/2;

  gs.btns = gs.btns || {};
  gs.btns.letterBtns = [];

  for (let i = 0; i < letters.length; i++) {
    const col = i % cols;
    const row = Math.floor(i / cols);
    const lx = gridStartX + col * cellSize;
    const ly = gridStartY + row * cellSize;

    X.save();
    X.fillStyle = 'rgba(0,255,255,0.06)';
    X.beginPath();
    X.roundRect(lx + 2 * S, ly + 2 * S, cellSize - 4 * S, cellSize - 4 * S, 4 * S);
    X.fill();
    X.fillStyle = '#fff';
    X.font = `bold ${16 * S}px monospace`;
    X.textAlign = 'center';
    X.fillText(letters[i], lx + cellSize/2, ly + cellSize/2 + 6 * S);
    X.restore();

    gs.btns.letterBtns.push({ x: lx, y: ly, w: cellSize, h: cellSize, letter: letters[i] });
  }

  // Done / Back buttons
  const doneBw = 100 * S;
  gs.btns.initialsDone = drawBtn(W/2 - doneBw - 8 * S, H - 65 * S, doneBw, 42 * S, 'SAVE');
  gs.btns.initialsSkip = drawBtn(W/2 + 8 * S, H - 65 * S, doneBw, 42 * S, 'SKIP', false);
}

// ============================================================
// LEVEL SELECT
// ============================================================
function drawSelect() {
  drawNeonText('SELECT LEVEL', W/2, 50 * S, 26, '#00ffff');
  
  const cols = 4;
  const boxSz = Math.min(72 * S, (W - 60 * S) / cols);
  const gap = 12 * S;
  const startX = W/2 - (cols * (boxSz + gap) - gap) / 2;
  const startY = 80 * S;
  
  gs.btns = gs.btns || {};
  gs.btns.levelBoxes = [];
  
  for (let i = 0; i < LEVELS.length; i++) {
    const col = i % cols;
    const row = Math.floor(i / cols);
    const x = startX + col * (boxSz + gap);
    const y = startY + row * (boxSz + gap + 5 * S);
    
    const unlocked = i === 0 || (progress[i - 1] && progress[i - 1].completed);
    const prog = progress[i];
    
    X.save();
    const r = 4 * S;
    X.beginPath();
    X.roundRect(x, y, boxSz, boxSz, r);
    
    if (unlocked) {
      X.fillStyle = prog && prog.completed ? 'rgba(0,255,255,0.12)' : 'rgba(0,255,255,0.04)';
      X.fill();
      X.strokeStyle = prog && prog.completed ? '#00ddff' : '#006688';
      X.lineWidth = 2 * S;
      if (prog && prog.completed) { X.shadowColor = '#00ffff'; X.shadowBlur = 6 * S; }
      X.stroke();
    } else {
      X.fillStyle = 'rgba(30,30,40,0.4)';
      X.fill();
      X.strokeStyle = '#222';
      X.lineWidth = 1 * S;
      X.stroke();
    }
    X.restore();
    
    // Number
    X.save();
    X.fillStyle = unlocked ? '#fff' : '#333';
    X.font = `bold ${18 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText(i + 1, x + boxSz/2, y + boxSz/2 - (prog && prog.completed ? 5 * S : 0));
    X.restore();
    
    // Stars
    if (prog && prog.completed) {
      X.save();
      X.font = `${10 * S}px sans-serif`;
      X.textAlign = 'center';
      for (let s = 0; s < 3; s++) {
        X.fillStyle = s < prog.stars ? '#ffd700' : 'rgba(255,255,255,0.15)';
        X.fillText(s < prog.stars ? '‚òÖ' : '‚òÜ', x + boxSz/2 + (s - 1) * 12 * S, y + boxSz - 7 * S);
      }
      X.restore();
    }
    
    if (!unlocked) {
      X.save();
      X.font = `${14 * S}px sans-serif`;
      X.textAlign = 'center';
      X.globalAlpha = 0.5;
      X.fillText('üîí', x + boxSz/2, y + boxSz - 10 * S);
      X.restore();
    }
    
    gs.btns.levelBoxes[i] = { x, y, w: boxSz, h: boxSz, unlocked };
  }
  
  if (customLevels.length > 0) {
    gs.btns.customBtn = drawBtn(W/2 - 80 * S, H - 105 * S, 160 * S, 38 * S, 'üîß CUSTOM (' + customLevels.length + ')', false);
  }
  gs.btns.back = drawBtn(W/2 - 50 * S, H - 60 * S, 100 * S, 42 * S, '‚Üê BACK', false);
}

// ============================================================
// VICTORY SCREEN
// ============================================================
function drawVictory() {
  victoryAnimTime += dt;
  
  X.save();
  X.fillStyle = 'rgba(0,0,0,0.88)';
  X.fillRect(0, 0, W, H);
  X.restore();
  
  // Confetti particles in background
  if (victoryAnimTime < 2) {
    for (let i = 0; i < 2; i++) {
      const colors = ['#ffd700', '#ff6b9d', '#00ffff', '#ff4444', '#44ff44'];
      emit(
        Math.random() * W, -10,
        1, colors[Math.floor(Math.random() * colors.length)],
        1, 0.12, { size: 3 + Math.random() * 3, shape: 'rect' }
      );
    }
  }
  updateParticles();
  drawParticles();
  
  const titleScale = Math.min(1, easeOutBack(Math.min(1, victoryAnimTime * 2)));
  X.save();
  X.translate(W/2, H * 0.13);
  X.scale(titleScale, titleScale);
  drawNeonText('LEVEL COMPLETE!', 0, 0, 28, '#ffd700');
  X.restore();
  
  const victoryLevelName = gs.isDaily ? 'Daily Challenge' : getLevelData(lvl).name;
  drawNeonText(victoryLevelName, W/2, H * 0.13 + 35 * S, 14, 'rgba(255,255,255,0.5)');
  
  // Stars with staggered pop-in
  const stars = gs.victoryStars || 1;
  for (let i = 0; i < 3; i++) {
    const sx = W/2 + (i - 1) * 55 * S;
    const sy = H * 0.26;
    const filled = i < stars;
    const starDelay = 0.3 + i * 0.25;
    const starProgress = Math.max(0, Math.min(1, (victoryAnimTime - starDelay) * 3));
    
    if (starProgress <= 0) continue;
    
    X.save();
    X.translate(sx, sy);
    const scale = filled ? easeOutElastic(starProgress) : starProgress;
    X.scale(scale, scale);
    X.font = `${34 * S}px sans-serif`;
    X.textAlign = 'center';
    if (filled) {
      X.shadowColor = '#ffd700';
      X.shadowBlur = 15 * S;
    }
    X.fillText(filled ? '‚≠ê' : '‚òÜ', 0, 0);
    X.restore();
  }
  
  // Stats
  const statsAlpha = Math.min(1, Math.max(0, (victoryAnimTime - 1) * 2));
  X.save();
  X.globalAlpha = statsAlpha;
  const cy = H * 0.38;

  // Stat boxes
  const statBoxW = W * 0.18;
  const statBoxH = 55 * S;
  const victoryStats = [
    { label: 'TIME', value: `${(gs.victoryTime || 0).toFixed(1)}s`, x: W * 0.15 },
    { label: 'DEATHS', value: `${gs.deathCount}`, x: W * 0.35 },
    { label: 'CLOSE', value: `${sessionNearMisses}`, x: W * 0.55 },
    { label: 'SCORE', value: `${gs.levelScore || 0}`, x: W * 0.75 },
  ];
  
  victoryStats.forEach((stat, i) => {
    X.fillStyle = 'rgba(255,255,255,0.05)';
    X.beginPath();
    X.roundRect(stat.x - statBoxW/2, cy - 10 * S, statBoxW, statBoxH, 6 * S);
    X.fill();
    
    X.fillStyle = 'rgba(255,255,255,0.4)';
    X.font = `${11 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText(stat.label, stat.x, cy + 5 * S);
    
    X.fillStyle = '#00ffff';
    X.font = `bold ${18 * S}px sans-serif`;
    X.fillText(stat.value, stat.x, cy + 30 * S);
  });
  X.restore();
  
  // Best time
  if (!gs.isDaily && progress[lvl] && progress[lvl].time < gs.victoryTime) {
    X.save();
    X.globalAlpha = statsAlpha * 0.5;
    X.fillStyle = '#888';
    X.font = `${11 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText(`Best: ${progress[lvl].time.toFixed(1)}s`, W/2, cy + statBoxH + 5 * S);
    X.restore();
  }
  
  // Buttons
  const btnAlpha = Math.min(1, Math.max(0, (victoryAnimTime - 1.3) * 2));
  if (btnAlpha > 0) {
    X.save();
    X.globalAlpha = btnAlpha;
    const bw = 130 * S, bh = 45 * S;
    const btnY = H * 0.62;
    gs.btns = gs.btns || {};
    gs.btns.replay = drawBtn(W/2 - bw - 10 * S, btnY, bw, bh, '‚Ü∫ RETRY', false);
    
    if (gs.isDaily) {
      gs.btns.next = drawBtn(W/2 + 10 * S, btnY, bw, bh, 'üè† MENU');
    } else if (isInfiniteMode || lvl < LEVELS.length - 1) {
      gs.btns.next = drawBtn(W/2 + 10 * S, btnY, bw, bh, 'NEXT ‚Üí');
    } else {
      gs.btns.next = drawBtn(W/2 + 10 * S, btnY, bw, bh, 'üè† MENU');
    }

    // Leaderboard button
    gs.btns.lbBtn = drawBtn(W/2 - 65 * S, btnY + bh + 60 * S, 130 * S, 38 * S, 'üèÜ TIMES', false);
    
    gs.btns.share = drawBtn(W/2 - bw - 10 * S, btnY + bh + 12 * S, bw, 38 * S, 'üì§ SHARE', false);
    gs.btns.addScore = drawBtn(W/2 + 10 * S, btnY + bh + 12 * S, bw, 38 * S, 'üèÜ SAVE', false);
    X.restore();
  }

  // Daily challenge badge
  if (gs.isDaily) {
    X.save();
    X.fillStyle = '#ffd700';
    X.font = `bold ${12 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('‚òÄ DAILY CHALLENGE COMPLETE!', W/2, H * 0.10);
    X.restore();
  }
}

function shareResult() {
  const stars = gs.victoryStars || 1;
  const levelName = gs.isDaily ? 'Daily Challenge' : `Level ${lvl + 1}: ${getLevelData(lvl).name}`;
  const text = `üîÆ Gravity Flip - ${levelName}\n${'‚≠ê'.repeat(stars)}${'‚òÜ'.repeat(3 - stars)} in ${(gs.victoryTime || 0).toFixed(1)}s\nCan you beat my time?`;
  if (navigator.share) {
    navigator.share({ title: 'Gravity Flip', text }).catch(() => {});
  } else if (navigator.clipboard) {
    navigator.clipboard.writeText(text).then(() => {
      screenShake = 3;
      addFloatingText(W/2, H * 0.85, 'Copied!', '#00ffff', 14);
    });
  }
}

// ============================================================
// LEADERBOARD SCREEN
// ============================================================
let lbPage = 0;
let lbLevelId = null;

function drawLeaderboard() {
  drawNeonText('BEST TIMES', W/2, 45 * S, 26, '#ffd700');

  // Level tabs
  const tabW = 50 * S;
  const tabH = 30 * S;
  const tabsPerRow = Math.floor((W - 20 * S) / (tabW + 5 * S));
  gs.btns = gs.btns || {};
  gs.btns.lbTabs = [];

  const allIds = [];
  for (let i = 0; i < LEVELS.length; i++) allIds.push({ id: '' + i, label: '' + (i + 1) });
  // Add infinite levels found in leaderboard
  Object.keys(leaderboard).filter(k => k.startsWith('inf_')).sort((a, b) => {
    return parseInt(a.split('_')[1]) - parseInt(b.split('_')[1]);
  }).forEach(k => allIds.push({ id: k, label: '‚àû' + (parseInt(k.split('_')[1]) - LEVELS.length + 1) }));
  // Add custom levels
  Object.keys(leaderboard).filter(k => k.startsWith('custom_')).forEach(k =>
    allIds.push({ id: k, label: 'C' + (parseInt(k.split('_')[1]) + 1) })
  );

  if (!lbLevelId && allIds.length > 0) lbLevelId = allIds[0].id;

  const startY = 70 * S;
  for (let i = 0; i < Math.min(allIds.length, tabsPerRow * 2); i++) {
    const col = i % tabsPerRow;
    const row = Math.floor(i / tabsPerRow);
    const tx = 10 * S + col * (tabW + 5 * S);
    const ty = startY + row * (tabH + 5 * S);
    const active = allIds[i].id === lbLevelId;

    X.save();
    X.beginPath();
    X.roundRect(tx, ty, tabW, tabH, 4 * S);
    X.fillStyle = active ? 'rgba(0,255,255,0.2)' : 'rgba(255,255,255,0.05)';
    X.fill();
    if (active) {
      X.strokeStyle = '#00ffff';
      X.lineWidth = 2 * S;
      X.shadowColor = '#00ffff'; X.shadowBlur = 6 * S;
      X.stroke();
    }
    X.fillStyle = active ? '#00ffff' : '#888';
    X.font = `bold ${11 * S}px sans-serif`;
    X.textAlign = 'center';
    X.shadowBlur = 0;
    X.fillText(allIds[i].label, tx + tabW / 2, ty + tabH / 2 + 4 * S);
    X.restore();

    gs.btns.lbTabs.push({ x: tx, y: ty, w: tabW, h: tabH, id: allIds[i].id });
  }

  // Show entries for selected level
  const entries = lbLevelId ? (leaderboard[lbLevelId] || []) : [];
  const listY = startY + (Math.ceil(Math.min(allIds.length, tabsPerRow * 2) / tabsPerRow)) * (tabH + 5 * S) + 15 * S;

  if (entries.length === 0) {
    X.save();
    X.fillStyle = 'rgba(255,255,255,0.3)';
    X.font = `${14 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('No times recorded yet', W / 2, listY + 40 * S);
    X.restore();
  } else {
    for (let i = 0; i < Math.min(entries.length, 8); i++) {
      const e = entries[i];
      const ey = listY + i * 32 * S;
      const isTop = i === 0;

      X.save();
      X.beginPath();
      X.roundRect(15 * S, ey, W - 30 * S, 28 * S, 4 * S);
      X.fillStyle = isTop ? 'rgba(255,215,0,0.08)' : 'rgba(255,255,255,0.03)';
      X.fill();

      X.fillStyle = isTop ? '#ffd700' : '#888';
      X.font = `bold ${14 * S}px sans-serif`;
      X.textAlign = 'left';
      X.fillText(`#${i + 1}`, 22 * S, ey + 19 * S);

      X.fillStyle = '#fff';
      X.font = `${14 * S}px monospace`;
      X.fillText(`${e.time.toFixed(2)}s`, 55 * S, ey + 19 * S);

      X.fillStyle = '#ffd700';
      X.font = `${12 * S}px sans-serif`;
      X.textAlign = 'center';
      X.fillText('‚≠ê'.repeat(e.stars), W / 2 + 20 * S, ey + 19 * S);

      X.fillStyle = '#ff4466';
      X.font = `${11 * S}px sans-serif`;
      X.textAlign = 'right';
      X.fillText(`üíÄ${e.deaths}`, W - 22 * S, ey + 19 * S);
      X.restore();
    }
  }

  gs.btns.back = drawBtn(W / 2 - 50 * S, H - 55 * S, 100 * S, 40 * S, '‚Üê BACK', false);
}

// ============================================================
// LEVEL EDITOR
// ============================================================
const editorTools = [
  { id: 'platform', label: 'Plat', color: '#00ccff' },
  { id: 'bouncy', label: 'Bncy', color: '#00ff80' },
  { id: 'crumble', label: 'Crmb', color: '#c8a050' },
  { id: 'spike', label: 'Spke', color: '#ff0064' },
  { id: 'orb', label: 'Orb', color: '#4488ff' },
  { id: 'portal', label: 'Goal', color: '#ffd700' },
  { id: 'eraser', label: 'Eras', color: '#ff4444' },
];

function editorReset() {
  editor = {
    tool: 'platform',
    elements: { platforms: [], spikes: [], orbs: [], portal: null },
    dragging: false, dragStart: null, dragEnd: null,
    scrollY: 0, selectedIndex: -1, selectedType: '',
    testMode: false, saved: false
  };
}

function drawEditor() {
  gs.btns = gs.btns || {};

  // Grid
  X.save();
  X.strokeStyle = 'rgba(255,255,255,0.04)';
  X.lineWidth = 1;
  const gridSize = 20 * S;
  for (let x = 0; x < W; x += gridSize) {
    X.beginPath(); X.moveTo(x, 60 * S); X.lineTo(x, H - 60 * S); X.stroke();
  }
  for (let y = 60 * S; y < H - 60 * S; y += gridSize) {
    X.beginPath(); X.moveTo(0, y); X.lineTo(W, y); X.stroke();
  }
  X.restore();

  // Draw placed elements
  const el = editor.elements;
  for (let i = 0; i < el.platforms.length; i++) {
    const p = el.platforms[i];
    X.save();
    X.fillStyle = p.type === 'bouncy' ? 'rgba(0,255,128,0.4)' : p.type === 'crumble' ? 'rgba(160,130,80,0.4)' : 'rgba(0,200,255,0.3)';
    X.strokeStyle = p.type === 'bouncy' ? '#00ff80' : p.type === 'crumble' ? '#c8a050' : '#00ccff';
    X.lineWidth = 2 * S;
    X.fillRect(p.x, p.y, p.w, p.h);
    X.strokeRect(p.x, p.y, p.w, p.h);
    X.restore();
  }
  for (let i = 0; i < el.spikes.length; i++) {
    const s = el.spikes[i];
    X.save();
    X.fillStyle = 'rgba(255,0,100,0.4)';
    X.strokeStyle = '#ff0064';
    X.lineWidth = 2 * S;
    X.fillRect(s.x, s.y, s.w, s.h);
    X.strokeRect(s.x, s.y, s.w, s.h);
    X.restore();
  }
  for (const o of el.orbs) {
    X.save();
    X.fillStyle = '#4488ff';
    X.shadowColor = '#4488ff'; X.shadowBlur = 10 * S;
    X.beginPath(); X.arc(o.x, o.y, 9 * S, 0, Math.PI * 2); X.fill();
    X.restore();
  }
  if (el.portal) {
    X.save();
    X.fillStyle = '#ffd700';
    X.shadowColor = '#ffd700'; X.shadowBlur = 15 * S;
    X.beginPath(); X.arc(el.portal.x, el.portal.y, 24 * S, 0, Math.PI * 2); X.fill();
    X.fillStyle = '#fff'; X.shadowBlur = 0;
    X.font = `${10 * S}px sans-serif`; X.textAlign = 'center';
    X.fillText('GOAL', el.portal.x, el.portal.y + 4 * S);
    X.restore();
  }

  // Drag preview
  if (editor.dragging && editor.dragStart && editor.dragEnd) {
    const tool = editor.tool;
    if (tool === 'platform' || tool === 'bouncy' || tool === 'crumble' || tool === 'spike') {
      const x1 = Math.min(editor.dragStart.x, editor.dragEnd.x);
      const y1 = Math.min(editor.dragStart.y, editor.dragEnd.y);
      const w = Math.abs(editor.dragEnd.x - editor.dragStart.x);
      const h = Math.max(8 * S, Math.abs(editor.dragEnd.y - editor.dragStart.y));
      X.save();
      X.fillStyle = 'rgba(255,255,255,0.15)';
      X.strokeStyle = '#fff';
      X.lineWidth = 1 * S;
      X.setLineDash([4 * S, 4 * S]);
      X.fillRect(x1, y1, w, h);
      X.strokeRect(x1, y1, w, h);
      X.restore();
    }
  }

  // Spawn marker (always at left)
  X.save();
  X.fillStyle = '#00ffff';
  X.shadowColor = '#00ffff'; X.shadowBlur = 8 * S;
  X.beginPath(); X.arc(W * 0.05, H * 0.4, 11 * S, 0, Math.PI * 2); X.fill();
  X.fillStyle = '#000'; X.shadowBlur = 0;
  X.font = `bold ${8 * S}px sans-serif`; X.textAlign = 'center';
  X.fillText('S', W * 0.05, H * 0.4 + 3 * S);
  X.restore();

  // Top toolbar
  X.save();
  X.fillStyle = 'rgba(0,0,0,0.6)';
  X.fillRect(0, 0, W, 55 * S);
  X.restore();

  drawNeonText('EDITOR', W / 2, 22 * S, 16, '#00ffff');

  // Tool buttons
  gs.btns.tools = [];
  const toolW = Math.min(48 * S, (W - 20 * S) / editorTools.length);
  const toolStartX = (W - editorTools.length * toolW) / 2;
  for (let i = 0; i < editorTools.length; i++) {
    const t = editorTools[i];
    const tx = toolStartX + i * toolW;
    const ty = 32 * S;
    const active = editor.tool === t.id;

    X.save();
    X.beginPath();
    X.roundRect(tx + 2 * S, ty, toolW - 4 * S, 20 * S, 3 * S);
    X.fillStyle = active ? t.color + '44' : 'rgba(255,255,255,0.05)';
    X.fill();
    if (active) {
      X.strokeStyle = t.color;
      X.lineWidth = 2 * S;
      X.stroke();
    }
    X.fillStyle = active ? t.color : '#888';
    X.font = `bold ${9 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText(t.label, tx + toolW / 2, ty + 14 * S);
    X.restore();

    gs.btns.tools.push({ x: tx + 2 * S, y: ty, w: toolW - 4 * S, h: 20 * S, id: t.id });
  }

  // Bottom bar
  X.save();
  X.fillStyle = 'rgba(0,0,0,0.6)';
  X.fillRect(0, H - 55 * S, W, 55 * S);
  X.restore();

  const bbw = 80 * S, bbh = 36 * S, bby = H - 48 * S;
  gs.btns.edBack = drawBtn(10 * S, bby, bbw, bbh, '‚Üê BACK', false);
  gs.btns.edClear = drawBtn(W / 2 - bbw / 2, bby, bbw, bbh, 'CLEAR', false);

  const canTest = el.portal && el.orbs.length > 0 && el.platforms.length > 0;
  if (canTest) {
    gs.btns.edTest = drawBtn(W - bbw - 10 * S, bby, bbw, bbh, '‚ñ∂ TEST');
  } else {
    gs.btns.edTest = null;
    X.save();
    X.fillStyle = 'rgba(255,255,255,0.2)';
    X.font = `${10 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('Need: platforms + orbs + goal', W / 2, H - 55 * S - 8 * S);
    X.restore();
  }

  // Save button
  if (canTest) {
    gs.btns.edSave = drawBtn(W - bbw - 10 * S, bby - bbh - 8 * S, bbw, bbh - 4 * S, 'SAVE', false);
  } else {
    gs.btns.edSave = null;
  }
}

function editorBuildLevel() {
  const el = editor.elements;
  const platforms = el.platforms.map(p => [p.x / W, p.y / H, p.w / W, p.h / H, p.type || 'solid']);
  const spikes = el.spikes.map(s => [s.x / W, s.y / H, s.w / W, s.h / H]);
  const orbs = el.orbs.map(o => [o.x / W, o.y / H]);
  const portal = el.portal ? [el.portal.x / W, el.portal.y / H] : [0.9, 0.5];
  return {
    name: 'Custom Level',
    stars: [20, 30, 45],
    spawn: [0.05, 0.4],
    goal: portal,
    width: 1.0,
    platforms, spikes, orbs,
    wells: [], lasers: [],
    custom: true
  };
}

function editorHandleTap(x, y) {
  // Tool bar taps
  if (gs.btns.tools) {
    for (const t of gs.btns.tools) {
      if (hit(x, y, t)) { editor.tool = t.id; sfxClick(); return; }
    }
  }
  if (hit(x, y, gs.btns.edBack)) { sfxClick(); screen = 'menu'; gs.btns = {}; return; }
  if (hit(x, y, gs.btns.edClear)) { sfxClick(); editorReset(); return; }
  if (gs.btns.edTest && hit(x, y, gs.btns.edTest)) {
    sfxClick();
    const lvlData = editorBuildLevel();
    customLevels.push(lvlData);
    saveCustomLevels();
    isCustomLevel = true;
    customLevelIndex = customLevels.length - 1;
    isInfiniteMode = false;
    startLevel(0);
    return;
  }
  if (gs.btns.edSave && hit(x, y, gs.btns.edSave)) {
    sfxClick();
    const lvlData = editorBuildLevel();
    customLevels.push(lvlData);
    saveCustomLevels();
    editor.saved = true;
    addFloatingText(W / 2, H / 2, 'SAVED!', '#00ff88', 22);
    return;
  }

  // Ignore taps in toolbar/bottom areas
  if (y < 55 * S || y > H - 55 * S) return;

  const tool = editor.tool;
  if (tool === 'orb') {
    editor.elements.orbs.push({ x, y });
    sfxClick();
  } else if (tool === 'portal') {
    editor.elements.portal = { x, y };
    sfxClick();
  } else if (tool === 'eraser') {
    // Find and remove closest element
    let minDist = 30 * S;
    let removeType = null, removeIdx = -1;
    editor.elements.orbs.forEach((o, i) => {
      const d = Math.sqrt((o.x - x) ** 2 + (o.y - y) ** 2);
      if (d < minDist) { minDist = d; removeType = 'orbs'; removeIdx = i; }
    });
    if (editor.elements.portal) {
      const d = Math.sqrt((editor.elements.portal.x - x) ** 2 + (editor.elements.portal.y - y) ** 2);
      if (d < minDist) { minDist = d; removeType = 'portal'; removeIdx = 0; }
    }
    editor.elements.platforms.forEach((p, i) => {
      if (x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h) {
        removeType = 'platforms'; removeIdx = i; minDist = 0;
      }
    });
    editor.elements.spikes.forEach((s, i) => {
      if (x >= s.x && x <= s.x + s.w && y >= s.y && y <= s.y + s.h) {
        removeType = 'spikes'; removeIdx = i; minDist = 0;
      }
    });
    if (removeType === 'portal') editor.elements.portal = null;
    else if (removeType && removeIdx >= 0) editor.elements[removeType].splice(removeIdx, 1);
    if (removeType) sfxClick();
  }
}

function editorHandleDragStart(x, y) {
  if (y < 55 * S || y > H - 55 * S) return;
  const tool = editor.tool;
  if (tool === 'platform' || tool === 'bouncy' || tool === 'crumble' || tool === 'spike') {
    editor.dragging = true;
    editor.dragStart = { x, y };
    editor.dragEnd = { x, y };
  }
}

function editorHandleDragMove(x, y) {
  if (editor.dragging) {
    editor.dragEnd = { x, y };
  }
}

function editorHandleDragEnd() {
  if (editor.dragging && editor.dragStart && editor.dragEnd) {
    const x1 = Math.min(editor.dragStart.x, editor.dragEnd.x);
    const y1 = Math.min(editor.dragStart.y, editor.dragEnd.y);
    const w = Math.abs(editor.dragEnd.x - editor.dragStart.x);
    const h = Math.max(8 * S, Math.abs(editor.dragEnd.y - editor.dragStart.y));
    if (w > 10 * S) {
      const tool = editor.tool;
      if (tool === 'spike') {
        editor.elements.spikes.push({ x: x1, y: y1, w, h });
      } else {
        editor.elements.platforms.push({ x: x1, y: y1, w, h, type: tool === 'bouncy' ? 'bouncy' : tool === 'crumble' ? 'crumble' : 'solid' });
      }
      sfxClick();
    }
    editor.dragging = false;
    editor.dragStart = null;
    editor.dragEnd = null;
  }
}

// ============================================================
// CUSTOM LEVELS SELECT
// ============================================================
function drawCustomSelect() {
  drawNeonText('CUSTOM LEVELS', W / 2, 45 * S, 22, '#00ff88');

  gs.btns = gs.btns || {};
  gs.btns.customLvls = [];

  if (customLevels.length === 0) {
    X.save();
    X.fillStyle = 'rgba(255,255,255,0.3)';
    X.font = `${14 * S}px sans-serif`;
    X.textAlign = 'center';
    X.fillText('No custom levels yet', W / 2, H * 0.4);
    X.fillText('Use the Editor to create one!', W / 2, H * 0.4 + 25 * S);
    X.restore();
  } else {
    for (let i = 0; i < Math.min(customLevels.length, 8); i++) {
      const ey = 75 * S + i * 50 * S;
      X.save();
      X.beginPath();
      X.roundRect(15 * S, ey, W - 30 * S, 42 * S, 6 * S);
      X.fillStyle = 'rgba(0,255,136,0.06)';
      X.fill();
      X.strokeStyle = '#00ff88';
      X.lineWidth = 1.5 * S;
      X.stroke();

      X.fillStyle = '#fff';
      X.font = `bold ${14 * S}px sans-serif`;
      X.textAlign = 'left';
      X.fillText(`Custom Level ${i + 1}`, 25 * S, ey + 18 * S);

      X.fillStyle = '#888';
      X.font = `${11 * S}px sans-serif`;
      const cl = customLevels[i];
      X.fillText(`${cl.platforms.length} plats  ${cl.orbs.length} orbs`, 25 * S, ey + 34 * S);

      X.restore();
      gs.btns.customLvls.push({ x: 15 * S, y: ey, w: W - 30 * S, h: 42 * S, index: i });
    }
  }

  gs.btns.back = drawBtn(W / 2 - 50 * S, H - 55 * S, 100 * S, 40 * S, '‚Üê BACK', false);
}

// ============================================================
// INPUT
// ============================================================
function handleTap(x, y) {
  ensureAudio();

  if (transAlpha > 0.1) return;

  // Initials entry screen
  if (enteringInitials) {
    if (gs.btns.letterBtns) {
      for (const btn of gs.btns.letterBtns) {
        if (hit(x, y, btn)) {
          sfxClick();
          if (initialsCursor < 3) {
            initialsText += btn.letter;
            initialsCursor++;
          }
          if (initialsCursor >= 3) {
            // Auto-complete: save and return
          }
          return;
        }
      }
    }
    if (hit(x, y, gs.btns.initialsDone)) {
      sfxClick();
      const name = initialsText.padEnd(3, 'A');
      addLeaderboardEntry(name, initialsScore, initialsLevel);
      enteringInitials = false;
      initialsText = '';
      initialsCursor = 0;
      return;
    }
    if (hit(x, y, gs.btns.initialsSkip)) {
      sfxClick();
      enteringInitials = false;
      initialsText = '';
      initialsCursor = 0;
      return;
    }
    return;
  }

  if (screen === 'menu') {
    if (hit(x, y, gs.btns.start)) {
      sfxClick();
      isInfiniteMode = false; isCustomLevel = false;
      let startLvl = 0;
      for (let i = 0; i < LEVELS.length; i++) {
        if (!progress[i] || !progress[i].completed) { startLvl = i; break; }
        if (i === LEVELS.length - 1) startLvl = 0;
      }
      startLevel(startLvl);
    }
    else if (hit(x, y, gs.btns.select)) { sfxClick(); screen = 'select'; gs.btns = {}; }
    else if (hit(x, y, gs.btns.infinite)) {
      sfxClick(); isInfiniteMode = true; isCustomLevel = false;
      startLevel(LEVELS.length);
    }
    else if (hit(x, y, gs.btns.daily)) {
      sfxClick();
      const dailyLevel = generateDailyChallenge();
      startLevel(0, dailyLevel);
    }
    else if (hit(x, y, gs.btns.editor)) { sfxClick(); editorReset(); screen = 'editor'; gs.btns = {}; }
    else if (hit(x, y, gs.btns.leaderboard)) { sfxClick(); lbLevelId = null; screen = 'leaderboard'; gs.btns = {}; }
    else if (hit(x, y, gs.btns.stats)) { sfxClick(); screen = 'stats'; gs.btns = {}; }
    else if (hit(x, y, gs.btns.leaders)) { sfxClick(); screen = 'top20'; gs.btns = {}; }
  } else if (screen === 'select') {
    if (hit(x, y, gs.btns.back)) { sfxClick(); screen = 'menu'; gs.btns = {}; }
    else if (gs.btns.customBtn && hit(x, y, gs.btns.customBtn)) { sfxClick(); screen = 'customselect'; gs.btns = {}; }
    else if (gs.btns.levelBoxes) {
      for (let i = 0; i < gs.btns.levelBoxes.length; i++) {
        const b = gs.btns.levelBoxes[i];
        if (b && b.unlocked && hit(x, y, b)) {
          sfxClick(); isInfiniteMode = false; isCustomLevel = false; startLevel(i); break;
        }
      }
    }
  } else if (screen === 'customselect') {
    if (hit(x, y, gs.btns.back)) { sfxClick(); screen = 'select'; gs.btns = {}; }
    else if (gs.btns.customLvls) {
      for (const b of gs.btns.customLvls) {
        if (hit(x, y, b)) {
          sfxClick(); isCustomLevel = true; isInfiniteMode = false;
          customLevelIndex = b.index;
          startLevel(0);
          break;
        }
      }
    }
  } else if (screen === 'editor') {
    editorHandleTap(x, y);
  } else if (screen === 'leaderboard') {
    if (hit(x, y, gs.btns.back)) { sfxClick(); screen = 'menu'; gs.btns = {}; }
    else if (gs.btns.lbTabs) {
      for (const t of gs.btns.lbTabs) {
        if (hit(x, y, t)) { sfxClick(); lbLevelId = t.id; break; }
      }
    }
  } else if (screen === 'stats' || screen === 'leaderboard' || screen === 'top20') {
    if (hit(x, y, gs.btns.back)) { sfxClick(); screen = 'menu'; gs.btns = {}; }
  } else if (screen === 'game') {
    if (!gs.dead && !gs.won) {
      gs.player.flip();
    }
  } else if (screen === 'victory') {
    if (hit(x, y, gs.btns.replay)) {
      sfxClick();
      if (gs.isDaily) {
        const dailyLevel = generateDailyChallenge();
        startLevel(0, dailyLevel);
      } else {
        startLevel(lvl);
      }
    }
    else if (hit(x, y, gs.btns.next)) {
      sfxClick();
      if (gs.isDaily) { screen = 'menu'; gs.btns = {}; }
      else if (isInfiniteMode) startLevel(lvl + 1);
      else if (isCustomLevel) { screen = 'menu'; gs.btns = {}; isCustomLevel = false; }
      else if (lvl < LEVELS.length - 1) startLevel(lvl + 1);
      else { screen = 'menu'; gs.btns = {}; }
    }
    else if (gs.btns.share && hit(x, y, gs.btns.share)) { sfxClick(); shareResult(); }
    else if (gs.btns.lbBtn && hit(x, y, gs.btns.lbBtn)) {
      sfxClick();
      const levelId = isCustomLevel ? 'custom_' + customLevelIndex : (isInfiniteMode ? 'inf_' + lvl : '' + lvl);
      lbLevelId = levelId;
      screen = 'leaderboard'; gs.btns = {};
    }
    else if (gs.btns.addScore && hit(x, y, gs.btns.addScore)) {
      sfxClick();
      enteringInitials = true;
      initialsText = '';
      initialsCursor = 0;
      initialsScore = gs.levelScore || 0;
      initialsLevel = lvl;
    }
  }
}

C.addEventListener('touchstart', e => {
  e.preventDefault();
  const tx = e.touches[0].clientX, ty = e.touches[0].clientY;
  if (screen === 'editor') editorHandleDragStart(tx, ty);
  handleTap(tx, ty);
}, { passive: false });

C.addEventListener('touchmove', e => {
  e.preventDefault();
  if (screen === 'editor') editorHandleDragMove(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });

C.addEventListener('touchend', e => {
  if (screen === 'editor') editorHandleDragEnd();
}, { passive: false });

C.addEventListener('mousedown', e => {
  if (screen === 'editor') editorHandleDragStart(e.clientX, e.clientY);
  handleTap(e.clientX, e.clientY);
});

C.addEventListener('mousemove', e => {
  if (screen === 'editor') editorHandleDragMove(e.clientX, e.clientY);
});

C.addEventListener('mouseup', e => {
  if (screen === 'editor') editorHandleDragEnd();
});

document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown') {
    e.preventDefault();
    if (screen === 'game' && !gs.dead && !gs.won) {
      gs.player.flip();
    }
  }
  if (e.code === 'KeyR' && screen === 'game') {
    startLevel(lvl);
  }
  if (e.code === 'Escape') {
    if (screen === 'game' || screen === 'victory') {
      screen = 'menu'; gs.btns = {}; isInfiniteMode = false; isCustomLevel = false;
    } else if (screen === 'editor' || screen === 'leaderboard' || screen === 'select' || screen === 'customselect') {
      screen = 'menu'; gs.btns = {};
    }
  }
});

// ============================================================
// MAIN LOOP
// ============================================================
function updateSpeedLines() {
  // Add new speed lines when in game
  if (screen === 'game' && !gs.dead && !gs.won && gs.player.alive) {
    const speed = Math.abs(gs.player.vx) + Math.abs(gs.player.vy);
    if (speed > 3 * S && Math.random() > 0.6) {
      speedLines.push({
        x: gs.player.x + W * 0.3 + Math.random() * W * 0.7,
        y: Math.random() * H,
        len: (30 + Math.random() * 60) * S,
        speed: (8 + Math.random() * 6) * S,
        life: 1, decay: 0.03 + Math.random() * 0.02,
        width: (1 + Math.random() * 2) * S
      });
    }
  }
  for (let i = speedLines.length - 1; i >= 0; i--) {
    const l = speedLines[i];
    l.x -= l.speed;
    l.life -= l.decay;
    if (l.life <= 0 || l.x + l.len < 0) speedLines.splice(i, 1);
  }
  if (speedLines.length > 30) speedLines.splice(0, speedLines.length - 30);
}

function drawSpeedLines() {
  X.save();
  for (const l of speedLines) {
    X.globalAlpha = l.life * 0.15;
    X.strokeStyle = currentAccent;
    X.lineWidth = l.width;
    X.beginPath();
    X.moveTo(l.x, l.y);
    X.lineTo(l.x + l.len, l.y);
    X.stroke();
  }
  X.restore();
}

function loop(time) {
  time /= 1000;
  dt = Math.min(time - lt, 0.05);
  lt = time;
  gt = time;
  
  // Apply slow motion
  if (slowMo > 0) {
    const realDt = dt; // save real dt before scaling
    dt *= 0.3;
    slowMo -= realDt; // decrement using real elapsed time
    if (slowMo < 0) slowMo = 0;
  }
  
  // Camera zoom lerp
  cameraZoom += (cameraZoomTarget - cameraZoom) * 0.08;
  
  updateSpeedLines();
  
  X.clearRect(0, 0, W, H);
  drawBg();
  
  drawSpeedLines();
  
  if (screen === 'menu') drawMenu();
  else if (screen === 'select') drawSelect();
  else if (screen === 'customselect') drawCustomSelect();
  else if (screen === 'editor') { drawEditor(); updateParticles(); drawParticles(); }
  else if (screen === 'stats') drawStatsScreen();
  else if (screen === 'leaderboard') drawLeaderboard();
  else if (screen === 'top20') drawLeaderboardScreen();
  else if (screen === 'game') {
    // Apply camera zoom
    if (cameraZoom !== 1) {
      X.save();
      const cx = gs.player.alive ? gs.player.x : W/2;
      const cy = gs.player.alive ? gs.player.y : H/2;
      X.translate(cx, cy);
      X.scale(cameraZoom, cameraZoom);
      X.translate(-cx, -cy);
    }
    updateGame(); drawGame();
    if (cameraZoom !== 1) X.restore();
  }
  else if (screen === 'victory') drawVictory();
  
  // Initials entry overlay
  if (enteringInitials) drawInitialsEntry();

  // Transition overlay
  if (transAlpha > 0.01 || transTarget > 0) {
    transAlpha += (transTarget - transAlpha) * 0.1;
    X.save();
    X.fillStyle = `rgba(0,0,0,${transAlpha})`;
    X.fillRect(0, 0, W, H);
    X.restore();
  }

  requestAnimationFrame(loop);
}

gs.btns = {};
requestAnimationFrame(loop);

</script>
</body>
</html>
