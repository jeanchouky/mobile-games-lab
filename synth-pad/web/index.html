<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#0a0a1a">
<title>Synth Pad</title>
<meta name="description" content="Web Audio synthesizer with pads, loops, effects, and visual waveforms">
<meta property="og:title" content="Synth Pad — Mobile Games Lab">
<meta property="og:description" content="Web Audio synthesizer with recording, layering, and visual waveform display">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Synth Pad">
<meta name="twitter:description" content="Create music with this browser-based synthesizer pad">
<link rel="manifest" href="manifest.json">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;touch-action:none;user-select:none;-webkit-user-select:none;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',system-ui,sans-serif;color:#fff}
#app{width:100%;height:100%;display:flex;flex-direction:column}

/* Splash */
#splash{position:fixed;top:0;left:0;width:100%;height:100%;background:#0a0a1a;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100;transition:opacity 0.5s}
#splash.hidden{opacity:0;pointer-events:none}
#splash h1{font-size:clamp(2rem,8vw,3.5rem);font-weight:900;background:linear-gradient(135deg,#f0f,#0ff,#ff0);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:8px}
#splash h2{color:#888;font-size:clamp(0.8rem,3vw,1rem);font-weight:400;margin-bottom:24px}
#splash .start-btn{background:linear-gradient(135deg,#f0f,#0ff);border:none;color:#000;font-weight:900;font-size:1.1rem;padding:14px 40px;border-radius:50px;cursor:pointer;text-transform:uppercase;letter-spacing:2px}
#splash .hint{color:#555;font-size:0.7rem;margin-top:16px;text-align:center;line-height:1.6}

/* Header */
#header{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;background:rgba(0,0,0,0.5);border-bottom:1px solid rgba(255,255,255,0.08);flex-shrink:0;min-height:44px}
#header h3{font-size:0.85rem;font-weight:700;background:linear-gradient(135deg,#f0f,#0ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.header-controls{display:flex;gap:6px;align-items:center}
.hbtn{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);color:#fff;font-size:0.65rem;padding:5px 10px;border-radius:14px;cursor:pointer;font-weight:600;transition:all 0.2s;white-space:nowrap}
.hbtn:hover{background:rgba(255,255,255,0.15)}
.hbtn:active{transform:scale(0.95)}
.hbtn.active{border-color:#0ff;color:#0ff;box-shadow:0 0 8px rgba(0,255,255,0.3)}
.hbtn.rec{border-color:#f44;color:#f44}
.hbtn.rec.active{background:rgba(255,68,68,0.2);box-shadow:0 0 8px rgba(255,68,68,0.4);animation:pulse-rec 1s infinite}
@keyframes pulse-rec{0%,100%{opacity:1}50%{opacity:0.6}}

/* Waveform */
#waveform-container{height:60px;background:rgba(0,0,0,0.3);border-bottom:1px solid rgba(255,255,255,0.05);flex-shrink:0;position:relative;overflow:hidden}
#waveform{width:100%;height:100%}

/* Effects Bar */
#effects{display:flex;gap:6px;padding:8px 12px;background:rgba(0,0,0,0.3);border-bottom:1px solid rgba(255,255,255,0.05);flex-shrink:0;overflow-x:auto;align-items:center}
.effect-group{display:flex;align-items:center;gap:4px;flex-shrink:0}
.effect-group label{font-size:0.6rem;color:#888;white-space:nowrap}
.effect-group input[type="range"]{width:60px;accent-color:#0ff;height:4px}
.effect-group select{background:#1a1a2e;color:#0ff;border:1px solid rgba(255,255,255,0.15);font-size:0.6rem;padding:2px 4px;border-radius:4px}

/* Pad Grid */
#pad-grid{flex:1;display:grid;grid-template-columns:repeat(4,1fr);gap:6px;padding:8px;min-height:0;overflow:hidden}
.pad{border-radius:12px;cursor:pointer;position:relative;display:flex;align-items:center;justify-content:center;flex-direction:column;transition:transform 0.1s;border:2px solid transparent;overflow:hidden}
.pad::before{content:'';position:absolute;top:0;left:0;right:0;bottom:0;background:radial-gradient(circle at center,rgba(255,255,255,0.15) 0%,transparent 70%);opacity:0;transition:opacity 0.15s}
.pad.playing::before{opacity:1}
.pad.playing{transform:scale(0.95);border-color:rgba(255,255,255,0.4)}
.pad .note{font-size:clamp(0.7rem,2vw,0.9rem);font-weight:800;color:rgba(255,255,255,0.9);text-shadow:0 0 8px currentColor;pointer-events:none}
.pad .wave-type{font-size:0.55rem;color:rgba(255,255,255,0.5);margin-top:2px;pointer-events:none}

/* Loops */
#loops-bar{display:flex;gap:6px;padding:8px 12px;background:rgba(0,0,0,0.4);border-top:1px solid rgba(255,255,255,0.05);flex-shrink:0;overflow-x:auto;align-items:center;min-height:44px}
.loop-chip{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);color:#fff;font-size:0.6rem;padding:4px 10px;border-radius:12px;cursor:pointer;display:flex;align-items:center;gap:4px;white-space:nowrap;flex-shrink:0}
.loop-chip.playing{border-color:#0f0;color:#0f0;box-shadow:0 0 6px rgba(0,255,0,0.3)}
.loop-delete{color:#f55;font-weight:bold;cursor:pointer;margin-left:4px}
#loops-label{font-size:0.6rem;color:#666;flex-shrink:0}

/* Tempo */
#tempo-bar{display:flex;align-items:center;gap:6px;padding:4px 12px;background:rgba(0,0,0,0.3);border-top:1px solid rgba(255,255,255,0.05);flex-shrink:0}
#tempo-bar label{font-size:0.6rem;color:#888}
#tempo-bar input{width:100px;accent-color:#f0f}
#tempo-bar span{font-size:0.65rem;color:#f0f;min-width:45px}
</style>
</head>
<body>
<div id="app">

<div id="splash">
  <h1>SYNTH PAD</h1>
  <h2>Create beats &amp; melodies</h2>
  <button class="start-btn" id="start-btn">START</button>
  <div class="hint">Tap pads to play sounds &bull; Record loops &bull; Layer them<br>Adjust effects in real-time</div>
</div>

<div id="header">
  <h3>SYNTH PAD</h3>
  <div class="header-controls">
    <button class="hbtn rec" id="btn-rec" onclick="toggleRecord()">REC</button>
    <button class="hbtn" id="btn-clear-rec" onclick="clearCurrentRecording()">CLEAR</button>
    <button class="hbtn" id="btn-save-loop" onclick="saveLoop()">SAVE LOOP</button>
  </div>
</div>

<canvas id="waveform"></canvas>

<div id="effects">
  <div class="effect-group">
    <label>Reverb</label>
    <input type="range" id="fx-reverb" min="0" max="100" value="30">
  </div>
  <div class="effect-group">
    <label>Delay</label>
    <input type="range" id="fx-delay" min="0" max="100" value="0">
  </div>
  <div class="effect-group">
    <label>Filter</label>
    <select id="fx-filter-type">
      <option value="lowpass">Low-pass</option>
      <option value="highpass">High-pass</option>
      <option value="bandpass">Band-pass</option>
      <option value="off" selected>Off</option>
    </select>
    <input type="range" id="fx-filter-freq" min="100" max="8000" value="2000">
  </div>
  <div class="effect-group">
    <label>Volume</label>
    <input type="range" id="fx-volume" min="0" max="100" value="70">
  </div>
</div>

<div id="pad-grid"></div>

<div id="tempo-bar">
  <label>Tempo:</label>
  <input type="range" id="tempo-slider" min="60" max="200" value="120">
  <span id="tempo-val">120 BPM</span>
</div>

<div id="loops-bar">
  <span id="loops-label">Loops:</span>
</div>

</div>

<script>
'use strict';

// ============================================================
// SYNTH PAD — Web Audio Synthesizer
// ============================================================

let audioCtx, masterGain, analyser, reverbNode, delayNode, delayFeedback, filterNode;
let analyserData;
const waveCanvas = document.getElementById('waveform');
const waveCtx = waveCanvas.getContext('2d');
const padGrid = document.getElementById('pad-grid');
const splash = document.getElementById('splash');

// Audio init on user gesture
let audioReady = false;

function initAudio() {
  if (audioReady) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Master gain
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.7;

  // Analyser
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  analyserData = new Uint8Array(analyser.frequencyBinCount);

  // Reverb (convolver with generated impulse)
  reverbNode = audioCtx.createConvolver();
  const irLength = audioCtx.sampleRate * 2;
  const irBuffer = audioCtx.createBuffer(2, irLength, audioCtx.sampleRate);
  for (let ch = 0; ch < 2; ch++) {
    const data = irBuffer.getChannelData(ch);
    for (let i = 0; i < irLength; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / irLength, 2.5);
    }
  }
  reverbNode.buffer = irBuffer;
  const reverbGain = audioCtx.createGain();
  reverbGain.gain.value = 0.3;
  reverbNode._gain = reverbGain;

  // Delay
  delayNode = audioCtx.createDelay(1.0);
  delayNode.delayTime.value = 0.3;
  delayFeedback = audioCtx.createGain();
  delayFeedback.gain.value = 0;
  const delayDry = audioCtx.createGain();
  delayDry.gain.value = 1;
  delayNode._dry = delayDry;

  // Filter
  filterNode = audioCtx.createBiquadFilter();
  filterNode.type = 'lowpass';
  filterNode.frequency.value = 2000;
  filterNode._enabled = false;

  // Chain: source -> filter -> [reverb+delay mix] -> analyser -> master -> dest
  // We'll connect pads to a common input node
  window._synthInput = audioCtx.createGain();
  window._synthInput.gain.value = 1;

  // Dry path
  const dryGain = audioCtx.createGain();
  dryGain.gain.value = 1;

  window._synthInput.connect(dryGain);
  dryGain.connect(analyser);

  // Reverb path
  window._synthInput.connect(reverbNode);
  reverbNode.connect(reverbGain);
  reverbGain.connect(analyser);

  // Delay path
  window._synthInput.connect(delayNode);
  delayNode.connect(delayFeedback);
  delayFeedback.connect(delayNode);
  delayNode.connect(analyser);

  analyser.connect(masterGain);
  masterGain.connect(audioCtx.destination);

  audioReady = true;
}

// --- Pad Configuration ---
const notes = ['C3','D3','E3','F3','G3','A3','B3','C4','D4','E4','F4','G4','A4','B4','C5','D5'];
const waveTypes = ['sine','triangle','square','sawtooth','sine','triangle','square','sawtooth','sine','triangle','square','sawtooth','sine','triangle','square','sawtooth'];
const padColors = [
  '#ff0066','#ff3388','#ff6644','#ff9922',
  '#ffcc00','#88ff00','#00ff88','#00ffcc',
  '#00ccff','#0088ff','#4444ff','#8800ff',
  '#cc00ff','#ff00cc','#ff0088','#ff4466'
];

const noteFreqs = {};
{
  const noteNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  for (let oct = 0; oct <= 8; oct++) {
    for (let n = 0; n < 12; n++) {
      const midi = oct * 12 + n + 12;
      noteFreqs[noteNames[n] + oct] = 440 * Math.pow(2, (midi - 69) / 12);
    }
  }
}

function getFreq(note) { return noteFreqs[note] || 440; }

// --- Create Pads ---
const pads = [];
function buildPads() {
  padGrid.innerHTML = '';
  for (let i = 0; i < 16; i++) {
    const div = document.createElement('div');
    div.className = 'pad';
    const hsl = padColors[i];
    div.style.background = `linear-gradient(135deg, ${hsl}, ${adjustColor(hsl, -30)})`;
    div.innerHTML = `<span class="note">${notes[i]}</span><span class="wave-type">${waveTypes[i]}</span>`;
    div.dataset.index = i;

    // Touch/click events
    const playPad = (e) => {
      e.preventDefault();
      initAudio();
      triggerPad(i);
    };
    div.addEventListener('mousedown', playPad);
    div.addEventListener('touchstart', playPad, { passive: false });

    const stopPad = (e) => {
      e.preventDefault();
      releasePad(i);
    };
    div.addEventListener('mouseup', stopPad);
    div.addEventListener('mouseleave', stopPad);
    div.addEventListener('touchend', stopPad, { passive: false });
    div.addEventListener('touchcancel', stopPad, { passive: false });

    padGrid.appendChild(div);
    pads.push({ el: div, osc: null, gain: null, active: false });
  }
}

function adjustColor(hex, amount) {
  let r = parseInt(hex.slice(1,3),16);
  let g = parseInt(hex.slice(3,5),16);
  let b = parseInt(hex.slice(5,7),16);
  r = Math.max(0, Math.min(255, r + amount));
  g = Math.max(0, Math.min(255, g + amount));
  b = Math.max(0, Math.min(255, b + amount));
  return `rgb(${r},${g},${b})`;
}

function triggerPad(index) {
  if (!audioReady) return;
  const pad = pads[index];
  pad.el.classList.add('playing');

  // Create oscillator
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = waveTypes[index];
  osc.frequency.setValueAtTime(getFreq(notes[index]), audioCtx.currentTime);

  // ADSR-like envelope
  gain.gain.setValueAtTime(0, audioCtx.currentTime);
  gain.gain.linearRampToValueAtTime(0.4, audioCtx.currentTime + 0.02);
  gain.gain.linearRampToValueAtTime(0.25, audioCtx.currentTime + 0.1);

  // Connect through filter if enabled
  if (filterNode._enabled) {
    osc.connect(filterNode);
    filterNode.connect(gain);
  } else {
    osc.connect(gain);
  }
  gain.connect(window._synthInput);

  osc.start();
  pad.osc = osc;
  pad.gain = gain;
  pad.active = true;

  // Record if recording
  if (recording) {
    recordEvents.push({ type: 'on', pad: index, time: audioCtx.currentTime - recordStartTime });
  }
}

function releasePad(index) {
  const pad = pads[index];
  pad.el.classList.remove('playing');
  if (pad.osc && pad.active) {
    const now = audioCtx.currentTime;
    pad.gain.gain.cancelScheduledValues(now);
    pad.gain.gain.setValueAtTime(pad.gain.gain.value, now);
    pad.gain.gain.linearRampToValueAtTime(0, now + 0.15);
    const osc = pad.osc;
    setTimeout(() => { try { osc.stop(); } catch(e) {} }, 200);
    pad.osc = null;
    pad.gain = null;
    pad.active = false;

    if (recording) {
      recordEvents.push({ type: 'off', pad: index, time: audioCtx.currentTime - recordStartTime });
    }
  }
}

// --- Effects Controls ---
document.getElementById('fx-reverb').addEventListener('input', (e) => {
  if (!audioReady) return;
  reverbNode._gain.gain.value = e.target.value / 100;
});

document.getElementById('fx-delay').addEventListener('input', (e) => {
  if (!audioReady) return;
  delayFeedback.gain.value = e.target.value / 100 * 0.7;
});

document.getElementById('fx-filter-type').addEventListener('change', (e) => {
  if (!audioReady) return;
  if (e.target.value === 'off') {
    filterNode._enabled = false;
  } else {
    filterNode._enabled = true;
    filterNode.type = e.target.value;
  }
});

document.getElementById('fx-filter-freq').addEventListener('input', (e) => {
  if (!audioReady) return;
  filterNode.frequency.value = parseFloat(e.target.value);
});

document.getElementById('fx-volume').addEventListener('input', (e) => {
  if (!audioReady) return;
  masterGain.gain.value = e.target.value / 100;
});

// --- Tempo ---
let tempo = 120;
const tempoSlider = document.getElementById('tempo-slider');
const tempoVal = document.getElementById('tempo-val');
tempoSlider.addEventListener('input', () => {
  tempo = parseInt(tempoSlider.value);
  tempoVal.textContent = tempo + ' BPM';
});

// --- Recording ---
let recording = false;
let recordEvents = [];
let recordStartTime = 0;

function toggleRecord() {
  const btn = document.getElementById('btn-rec');
  if (!recording) {
    initAudio();
    recording = true;
    recordEvents = [];
    recordStartTime = audioCtx.currentTime;
    btn.classList.add('active');
  } else {
    recording = false;
    btn.classList.remove('active');
  }
}

function clearCurrentRecording() {
  recording = false;
  recordEvents = [];
  document.getElementById('btn-rec').classList.remove('active');
}

// --- Loops ---
let loops = [];
let loopIdCounter = 0;

function saveLoop() {
  if (recordEvents.length === 0) return;
  recording = false;
  document.getElementById('btn-rec').classList.remove('active');

  const duration = recordEvents[recordEvents.length - 1].time + 0.1;
  const loop = {
    id: loopIdCounter++,
    events: [...recordEvents],
    duration: duration,
    playing: false,
    timeout: null,
  };
  loops.push(loop);
  recordEvents = [];
  renderLoops();
}

function playLoop(loop) {
  if (!audioReady) return;
  loop.playing = true;

  const timeScale = 120 / tempo;
  const playEvents = () => {
    if (!loop.playing) return;
    loop.events.forEach(ev => {
      const t = ev.time * timeScale;
      setTimeout(() => {
        if (!loop.playing) return;
        if (ev.type === 'on') triggerPad(ev.pad);
        else releasePad(ev.pad);
      }, t * 1000);
    });
    loop.timeout = setTimeout(() => {
      if (loop.playing) playEvents();
    }, loop.duration * timeScale * 1000);
  };
  playEvents();
  renderLoops();
}

function stopLoop(loop) {
  loop.playing = false;
  if (loop.timeout) clearTimeout(loop.timeout);
  renderLoops();
}

function toggleLoop(id) {
  const loop = loops.find(l => l.id === id);
  if (!loop) return;
  if (loop.playing) stopLoop(loop);
  else playLoop(loop);
}

function deleteLoop(id) {
  const loop = loops.find(l => l.id === id);
  if (loop) {
    stopLoop(loop);
    loops = loops.filter(l => l.id !== id);
  }
  renderLoops();
}

function renderLoops() {
  const bar = document.getElementById('loops-bar');
  bar.innerHTML = '<span id="loops-label">Loops:</span>';
  if (loops.length === 0) {
    bar.innerHTML += '<span style="font-size:0.6rem;color:#555">Record pads and save to create loops</span>';
    return;
  }
  loops.forEach((loop, i) => {
    const chip = document.createElement('div');
    chip.className = 'loop-chip' + (loop.playing ? ' playing' : '');
    chip.innerHTML = `Loop ${i + 1} (${loop.events.length} notes) <span class="loop-delete" data-id="${loop.id}">&times;</span>`;
    chip.addEventListener('click', (e) => {
      if (e.target.classList.contains('loop-delete')) {
        deleteLoop(parseInt(e.target.dataset.id));
      } else {
        toggleLoop(loop.id);
      }
    });
    bar.appendChild(chip);
  });
}

// --- Waveform Visualization ---
function resizeWaveform() {
  const rect = waveCanvas.getBoundingClientRect();
  waveCanvas.width = rect.width * (window.devicePixelRatio > 1.5 ? 1.5 : window.devicePixelRatio);
  waveCanvas.height = rect.height * (window.devicePixelRatio > 1.5 ? 1.5 : window.devicePixelRatio);
}
window.addEventListener('resize', resizeWaveform);
resizeWaveform();

function drawWaveform() {
  requestAnimationFrame(drawWaveform);
  const w = waveCanvas.width;
  const h = waveCanvas.height;
  waveCtx.fillStyle = 'rgba(10,10,26,0.3)';
  waveCtx.fillRect(0, 0, w, h);

  if (!audioReady || !analyser) return;
  analyser.getByteTimeDomainData(analyserData);

  const bufLen = analyser.frequencyBinCount;
  const sliceWidth = w / bufLen;

  // Glow effect
  waveCtx.shadowBlur = 8;
  waveCtx.shadowColor = '#0ff';
  waveCtx.strokeStyle = '#0ff';
  waveCtx.lineWidth = 2;
  waveCtx.beginPath();

  let x = 0;
  for (let i = 0; i < bufLen; i++) {
    const v = analyserData[i] / 128.0;
    const y = v * h / 2;
    if (i === 0) waveCtx.moveTo(x, y);
    else waveCtx.lineTo(x, y);
    x += sliceWidth;
  }
  waveCtx.stroke();
  waveCtx.shadowBlur = 0;

  // Frequency bars in background
  const freqData = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(freqData);
  const barCount = 32;
  const barWidth = w / barCount;
  const step = Math.floor(bufLen / barCount);
  for (let i = 0; i < barCount; i++) {
    const val = freqData[i * step] / 255;
    const barH = val * h * 0.6;
    const hue = (i / barCount) * 300;
    waveCtx.fillStyle = `hsla(${hue}, 100%, 60%, 0.15)`;
    waveCtx.fillRect(i * barWidth, h - barH, barWidth - 1, barH);
  }
}

// --- Keyboard Support ---
const keyMap = {
  '1': 0, '2': 1, '3': 2, '4': 3,
  'q': 4, 'w': 5, 'e': 6, 'r': 7,
  'a': 8, 's': 9, 'd': 10, 'f': 11,
  'z': 12, 'x': 13, 'c': 14, 'v': 15
};
const activeKeys = new Set();

document.addEventListener('keydown', (e) => {
  if (e.repeat) return;
  const idx = keyMap[e.key.toLowerCase()];
  if (idx !== undefined && !activeKeys.has(e.key.toLowerCase())) {
    activeKeys.add(e.key.toLowerCase());
    initAudio();
    triggerPad(idx);
  }
});
document.addEventListener('keyup', (e) => {
  const idx = keyMap[e.key.toLowerCase()];
  if (idx !== undefined) {
    activeKeys.delete(e.key.toLowerCase());
    releasePad(idx);
  }
});

// --- Splash ---
document.getElementById('start-btn').addEventListener('click', () => {
  initAudio();
  splash.classList.add('hidden');
  setTimeout(() => splash.style.display = 'none', 500);
});

// --- Init ---
buildPads();
renderLoops();
drawWaveform();

</script>
</body>
</html>
