<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Emoji Wars ‚öîÔ∏è</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #1a1a2e;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
}
canvas { display: block; width: 100%; height: 100%; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
'use strict';

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W, H, dpr, centerX, centerY;
let gameTime = 0, deltaTime = 0, lastTime = 0;
let gameState = 'menu';
let playerWins = 0, playerLosses = 0;
let inputEvents = [];
let shakeAmount = 0;

// Load progress
try { const s = localStorage.getItem('emojiwars'); if (s) { const d = JSON.parse(s); playerWins = d.w||0; playerLosses = d.l||0; } } catch(e){}
function saveProgress() { try { localStorage.setItem('emojiwars', JSON.stringify({w:playerWins,l:playerLosses})); } catch(e){} }

// --- EMOJI DATABASE ---
const emojiDB = {
  '‚öîÔ∏è': { name: 'Sword', type: 'melee', hp: 120, atk: 15, def: 8, spd: 1.5, cost: 3, desc: 'Balanced fighter' },
  'üó°Ô∏è': { name: 'Dagger', type: 'melee', hp: 70, atk: 12, def: 3, spd: 2.5, cost: 2, desc: 'Fast & fragile' },
  'üõ°Ô∏è': { name: 'Shield', type: 'melee', hp: 200, atk: 5, def: 25, spd: 0.8, cost: 3, desc: 'Tanky wall' },
  'ü¶Å': { name: 'Lion', type: 'melee', hp: 150, atk: 18, def: 10, spd: 2.0, cost: 4, desc: 'King of beasts' },
  'üê∫': { name: 'Wolf', type: 'melee', hp: 90, atk: 14, def: 6, spd: 2.2, cost: 2, desc: 'Pack bonus' },
  'üíÄ': { name: 'Reaper', type: 'melee', hp: 80, atk: 22, def: 3, spd: 1.2, cost: 3, desc: 'Glass cannon' },
  'üèπ': { name: 'Archer', type: 'ranged', hp: 60, atk: 13, def: 3, spd: 1.0, cost: 3, desc: 'Shoots from afar' },
  'üéØ': { name: 'Sniper', type: 'ranged', hp: 50, atk: 28, def: 2, spd: 0.6, cost: 4, desc: 'Critical hits' },
  'üí£': { name: 'Bomber', type: 'ranged', hp: 40, atk: 8, def: 2, spd: 1.0, cost: 3, desc: 'Explodes on death' },
  'ü¶Ö': { name: 'Eagle', type: 'ranged', hp: 70, atk: 10, def: 6, spd: 2.5, cost: 2, desc: 'Flying attacker' },
  'üßô': { name: 'Wizard', type: 'magic', hp: 80, atk: 20, def: 5, spd: 1.0, cost: 4, desc: 'Area damage' },
  '‚ö°': { name: 'Lightning', type: 'magic', hp: 60, atk: 16, def: 3, spd: 3.0, cost: 3, desc: 'Chain strikes' },
  'üî•': { name: 'Fire', type: 'magic', hp: 70, atk: 14, def: 5, spd: 1.5, cost: 3, desc: 'Burn damage' },
  '‚ùÑÔ∏è': { name: 'Ice', type: 'magic', hp: 90, atk: 8, def: 12, spd: 1.0, cost: 3, desc: 'Slows enemies' },
  'üêâ': { name: 'Dragon', type: 'creature', hp: 300, atk: 30, def: 20, spd: 1.2, cost: 7, desc: 'Legendary!' },
  'ü§ñ': { name: 'Robot', type: 'creature', hp: 180, atk: 15, def: 18, spd: 1.0, cost: 4, desc: 'Self-heals' },
  'üëª': { name: 'Ghost', type: 'creature', hp: 50, atk: 12, def: 2, spd: 2.5, cost: 2, desc: 'Dodges 50%' },
  'üêç': { name: 'Snake', type: 'creature', hp: 80, atk: 16, def: 5, spd: 1.8, cost: 3, desc: 'Poison bite' },
  'üåü': { name: 'Star', type: 'special', hp: 60, atk: 5, def: 5, spd: 1.5, cost: 2, desc: 'Buffs allies' },
  'üå™Ô∏è': { name: 'Tornado', type: 'special', hp: 40, atk: 20, def: 0, spd: 3.0, cost: 4, desc: 'Hits all lanes' },
};

const emojiCategories = {
  melee: ['‚öîÔ∏è', 'üó°Ô∏è', 'üõ°Ô∏è', 'ü¶Å', 'üê∫', 'üíÄ'],
  ranged: ['üèπ', 'üéØ', 'üí£', 'ü¶Ö'],
  magic: ['üßô', '‚ö°', 'üî•', '‚ùÑÔ∏è'],
  creature: ['üêâ', 'ü§ñ', 'üëª', 'üêç'],
  special: ['üåü', 'üå™Ô∏è']
};

// --- BATTLE STATE ---
let playerArmy = [];
let enemyArmy = [];
let units = [];
let particles = [];
let floatingTexts = [];
let battleTimer = 90;
let playerHP = 100;
let enemyHP = 100;
let playerEnergy = 5;
let enemyEnergy = 5;
let energyRate = 1; // per second
let selectedCard = -1;
let difficulty = 'medium';
let selectedCategory = 'melee';
let dragState = { active: false, emoji: null, x: 0, y: 0 };
let combatFlashes = [];

// --- AUDIO ---
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playTone(freq, dur, type = 'square', vol = 0.08) {
  if (!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.setValueAtTime(vol, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + dur);
}

function sfxClick() { playTone(800, 0.05, 'sine', 0.06); }
function sfxDeploy() { playTone(500, 0.08, 'square', 0.08); playTone(700, 0.06, 'sine', 0.05); }
function sfxHit() { playTone(200 + Math.random()*200, 0.08, 'sawtooth', 0.05); }
function sfxDeath() { playTone(150, 0.2, 'triangle', 0.06); playTone(80, 0.15, 'sawtooth', 0.04); }
function sfxVictory() { [523,659,784,1047].forEach((f,i) => setTimeout(() => playTone(f, 0.2, 'sine', 0.1), i*120)); }
function sfxDefeat() { playTone(400, 0.3, 'sawtooth', 0.08); setTimeout(() => playTone(200, 0.5, 'sawtooth', 0.06), 300); }
function sfxExplosion() { playTone(80, 0.3, 'sawtooth', 0.12); playTone(150, 0.2, 'square', 0.06); }
function sfxBuff() { playTone(1000, 0.1, 'sine', 0.06); playTone(1200, 0.1, 'sine', 0.04); }

// --- RESIZE ---
function resize() {
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  centerX = W / 2; centerY = H / 2;
}
window.addEventListener('resize', resize);
resize();

// --- INPUT ---
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault(); ensureAudio();
  const t = e.touches[0];
  inputEvents.push({ type: 'tap', x: t.clientX, y: t.clientY });
  dragState.active = true; dragState.x = t.clientX; dragState.y = t.clientY;
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (dragState.active) { const t = e.touches[0]; dragState.x = t.clientX; dragState.y = t.clientY; }
}, { passive: false });
canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  if (dragState.active) { inputEvents.push({ type: 'release', x: dragState.x, y: dragState.y }); dragState.active = false; }
});
canvas.addEventListener('mousedown', (e) => {
  ensureAudio();
  inputEvents.push({ type: 'tap', x: e.clientX, y: e.clientY });
  dragState.active = true; dragState.x = e.clientX; dragState.y = e.clientY;
});
canvas.addEventListener('mousemove', (e) => { if (dragState.active) { dragState.x = e.clientX; dragState.y = e.clientY; } });
canvas.addEventListener('mouseup', (e) => {
  if (dragState.active) { inputEvents.push({ type: 'release', x: e.clientX, y: e.clientY }); dragState.active = false; }
});

function hit(px, py, x, y, w, h) { return px >= x-w/2 && px <= x+w/2 && py >= y-h/2 && py <= y+h/2; }

// --- DRAWING ---
function drawRR(x, y, w, h, r, fill, stroke = null, lw = 2) {
  ctx.beginPath(); ctx.roundRect(x-w/2, y-h/2, w, h, r);
  if (fill) { ctx.fillStyle = fill; ctx.fill(); }
  if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = lw; ctx.stroke(); }
}
function drawText(text, x, y, size, color, align = 'center', weight = '400') {
  ctx.fillStyle = color;
  ctx.font = `${weight} ${size}px -apple-system, 'Segoe UI', sans-serif`;
  ctx.textAlign = align; ctx.textBaseline = 'middle';
  ctx.fillText(text, x, y);
}
function drawEmoji(emoji, x, y, size) {
  ctx.font = `${size}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(emoji, x, y);
}

// --- PARTICLES ---
function spawnP(x, y, emoji, vx = 0, vy = 0, size = 20) {
  particles.push({ x, y, emoji, vx, vy, life: 1, decay: 0.025, size });
}
function addFloat(x, y, text, color = '#fff', size = 16) {
  floatingTexts.push({ x, y, text, color, size, vy: -1.5, life: 1, decay: 0.02 });
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life -= p.decay;
    if (p.life <= 0) particles.splice(i, 1);
  }
  if (particles.length > 200) particles.splice(0, particles.length - 200);
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const f = floatingTexts[i]; f.y += f.vy; f.life -= f.decay;
    if (f.life <= 0) floatingTexts.splice(i, 1);
  }
}
function drawParticles() {
  for (const p of particles) { ctx.save(); ctx.globalAlpha = p.life; drawEmoji(p.emoji, p.x, p.y, p.size); ctx.restore(); }
  for (const f of floatingTexts) {
    ctx.save(); ctx.globalAlpha = f.life;
    ctx.fillStyle = f.color; ctx.font = `bold ${f.size}px sans-serif`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.shadowColor = f.color; ctx.shadowBlur = 4;
    ctx.fillText(f.text, f.x, f.y); ctx.restore();
  }
}

// --- SHAKE ---
function shake(amt = 5) { shakeAmount = Math.max(shakeAmount, amt); }

// ============================================================
// MENU
// ============================================================
function drawMenu() {
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#2d1b69'); grad.addColorStop(1, '#1a0a3e');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);
  
  // Animated emoji ring
  const emojis = ['‚öîÔ∏è', 'üèπ', 'üßô', 'üêâ', 'üí•', '‚ö°', 'üî•', 'üõ°Ô∏è', 'ü¶Å', 'üëª'];
  for (let i = 0; i < emojis.length; i++) {
    const a = (i / emojis.length) * Math.PI * 2 + gameTime * 0.5;
    const r = Math.min(W, H) * 0.28;
    const x = centerX + Math.cos(a) * r;
    const y = centerY - 50 + Math.sin(a) * r * 0.5;
    ctx.save(); ctx.globalAlpha = 0.4 + Math.sin(gameTime * 2 + i) * 0.2;
    drawEmoji(emojis[i], x, y, 36); ctx.restore();
  }
  
  drawText('‚öîÔ∏è EMOJI WARS ‚öîÔ∏è', centerX, centerY - 120, 42, '#ffd700', 'center', '900');
  drawText('Build armies. Deploy tactics. Win!', centerX, centerY - 75, 15, '#b8a0d4');
  
  // Start button
  drawRR(centerX, centerY + 10, 260, 65, 16, '#ff4444', '#ff6666');
  drawText('‚öîÔ∏è BUILD & BATTLE', centerX, centerY + 10, 22, '#fff', 'center', '800');
  
  // Difficulty
  drawText('Difficulty:', centerX, centerY + 70, 13, '#888');
  const diffs = ['easy', 'medium', 'hard'];
  const diffColors = { easy: '#4CAF50', medium: '#FF9800', hard: '#f44336' };
  const diffLabels = { easy: 'üòä Easy', medium: 'üò§ Medium', hard: 'üíÄ Hard' };
  diffs.forEach((d, i) => {
    const x = centerX + (i - 1) * 100;
    drawRR(x, centerY + 110, 85, 40, 10, difficulty === d ? diffColors[d] : '#333', difficulty === d ? null : '#555');
    drawText(diffLabels[d], x, centerY + 110, 13, difficulty === d ? '#fff' : '#888', 'center', '600');
  });
  
  // Record
  if (playerWins + playerLosses > 0) {
    drawText(`üèÜ ${playerWins}W - ${playerLosses}L`, centerX, H - 50, 16, '#888');
  }
}

function updateMenu() {
  for (const ev of inputEvents) {
    if (ev.type !== 'tap') continue;
    if (hit(ev.x, ev.y, centerX, centerY + 10, 260, 65)) { sfxClick(); gameState = 'armyBuilder'; initArmyBuilder(); return; }
    ['easy','medium','hard'].forEach((d, i) => {
      if (hit(ev.x, ev.y, centerX + (i-1)*100, centerY + 110, 85, 40)) { difficulty = d; sfxClick(); }
    });
  }
}

// ============================================================
// ARMY BUILDER
// ============================================================
function initArmyBuilder() {
  if (playerArmy.length === 0) playerArmy = ['‚öîÔ∏è', 'üèπ', 'üßô', 'üõ°Ô∏è', 'üêâ', '‚öîÔ∏è', 'üó°Ô∏è', 'üî•'];
  selectedCategory = 'melee';
}

function updateArmyBuilder() {
  for (const ev of inputEvents) {
    if (ev.type !== 'tap') continue;
    
    // Category tabs
    const cats = Object.keys(emojiCategories);
    cats.forEach((cat, i) => {
      const tabX = (i + 0.5) * (W / cats.length);
      if (hit(ev.x, ev.y, tabX, 160, W/cats.length - 8, 40)) { selectedCategory = cat; sfxClick(); }
    });
    
    // Emoji grid
    const emojis = emojiCategories[selectedCategory];
    const cols = Math.min(emojis.length, 4);
    const cellW = Math.min(W / cols, 110);
    const startX = centerX - (cols * cellW) / 2 + cellW / 2;
    emojis.forEach((emoji, i) => {
      const col = i % cols;
      const row = Math.floor(i / cols);
      const x = startX + col * cellW;
      const y = 230 + row * 100;
      if (hit(ev.x, ev.y, x, y, cellW - 8, 90)) {
        if (playerArmy.length < 8) { playerArmy.push(emoji); sfxDeploy(); }
      }
    });
    
    // Army slots (tap to remove)
    const slotW = W / 8;
    playerArmy.forEach((_, i) => {
      if (hit(ev.x, ev.y, i * slotW + slotW / 2, 65, slotW - 6, 80)) { playerArmy.splice(i, 1); sfxClick(); }
    });
    
    // Battle button
    if (playerArmy.length > 0 && hit(ev.x, ev.y, centerX, H - 50, 280, 60)) { sfxClick(); gameState = 'battle'; initBattle(); }
  }
}

function drawArmyBuilder() {
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1a0a3e'); grad.addColorStop(1, '#0d0520');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);
  
  drawText('BUILD YOUR ARMY', centerX, 22, 22, '#ffd700', 'center', '800');
  
  // Army slots
  const slotW = W / 8;
  for (let i = 0; i < 8; i++) {
    const x = i * slotW + slotW / 2;
    drawRR(x, 65, slotW - 6, 80, 8, 'rgba(255,255,255,0.05)', playerArmy[i] ? '#4FC3F7' : '#333');
    if (playerArmy[i]) {
      drawEmoji(playerArmy[i], x, 55, 28);
      const d = emojiDB[playerArmy[i]];
      drawText(`${d.cost}‚ö°`, x, 90, 9, '#ffd700', 'center', '600');
    }
  }
  drawText(`${playerArmy.length}/8 units`, centerX, 115, 12, '#888');
  
  // Category tabs
  const cats = Object.keys(emojiCategories);
  const tabColors = { melee: '#ff6b6b', ranged: '#4ecdc4', magic: '#a29bfe', creature: '#fd79a8', special: '#fdcb6e' };
  const tabIcons = { melee: '‚öîÔ∏è', ranged: 'üèπ', magic: '‚ú®', creature: 'üêâ', special: '‚≠ê' };
  cats.forEach((cat, i) => {
    const tabX = (i + 0.5) * (W / cats.length);
    const active = selectedCategory === cat;
    drawRR(tabX, 160, W/cats.length - 8, 40, 8, active ? tabColors[cat] : '#222', active ? null : '#444');
    drawText(`${tabIcons[cat]} ${cat.charAt(0).toUpperCase() + cat.slice(1)}`, tabX, 160, 11, active ? '#fff' : '#888', 'center', '600');
  });
  
  // Emoji grid with stats
  const emojis = emojiCategories[selectedCategory];
  const cols = Math.min(emojis.length, 4);
  const cellW = Math.min(W / cols, 110);
  const startX = centerX - (cols * cellW) / 2 + cellW / 2;
  emojis.forEach((emoji, i) => {
    const col = i % cols; const row = Math.floor(i / cols);
    const x = startX + col * cellW; const y = 230 + row * 100;
    const d = emojiDB[emoji];
    drawRR(x, y, cellW - 8, 90, 10, '#1a1a2e', tabColors[d.type]);
    drawEmoji(emoji, x, y - 15, 30);
    drawText(d.name, x, y + 15, 10, '#ccc', 'center', '600');
    drawText(`‚öî${d.atk} üõ°${d.def} ‚ö°${d.cost}`, x, y + 30, 8, '#888', 'center');
  });
  
  // Type advantages
  drawText('‚öîÔ∏è beats üèπ ‚Ä¢ üèπ beats ‚ú® ‚Ä¢ ‚ú® beats ‚öîÔ∏è', centerX, H - 100, 11, '#666');
  
  // Battle button
  if (playerArmy.length > 0) {
    const pulse = Math.sin(gameTime * 5) * 3;
    drawRR(centerX, H - 50, 280 + pulse, 60, 16, '#44ff44', '#2d2');
    drawText('‚öîÔ∏è BATTLE!', centerX, H - 50, 24, '#000', 'center', '800');
  } else {
    drawRR(centerX, H - 50, 280, 60, 16, '#333');
    drawText('Add units to battle', centerX, H - 50, 16, '#666');
  }
}

// ============================================================
// BATTLE
// ============================================================
function initBattle() {
  enemyArmy = generateEnemyArmy();
  battleTimer = 90;
  playerHP = 100; enemyHP = 100;
  playerEnergy = 5; enemyEnergy = 5;
  units = []; particles = []; floatingTexts = []; combatFlashes = [];
  selectedCard = -1;
  
  // Build hand from army
  playerHand = [...playerArmy];
  enemyHand = [...enemyArmy];
}

let playerHand = [];
let enemyHand = [];

function generateEnemyArmy() {
  const all = Object.keys(emojiDB);
  const army = [];
  const budget = difficulty === 'easy' ? 18 : difficulty === 'hard' ? 28 : 24;
  let spent = 0;
  
  while (army.length < 8 && spent < budget) {
    let pool = all;
    if (difficulty === 'easy') pool = all.filter(e => emojiDB[e].cost <= 3);
    if (difficulty === 'hard') {
      // Counter player types
      const types = {};
      playerArmy.forEach(e => { const t = emojiDB[e].type; types[t] = (types[t]||0)+1; });
      const dom = Object.keys(types).sort((a,b) => types[b]-types[a])[0];
      const counter = { melee: 'magic', ranged: 'melee', magic: 'ranged' }[dom] || 'creature';
      if (Math.random() < 0.6) pool = all.filter(e => emojiDB[e].type === counter);
    }
    const e = pool[Math.floor(Math.random() * pool.length)];
    if (spent + emojiDB[e].cost <= budget) { army.push(e); spent += emojiDB[e].cost; }
    else break;
  }
  return army;
}

function deployUnit(emoji, lane, owner) {
  const hand = owner === 'player' ? playerHand : enemyHand;
  const idx = hand.indexOf(emoji);
  if (idx === -1) return false;
  
  const d = emojiDB[emoji];
  const energy = owner === 'player' ? playerEnergy : enemyEnergy;
  if (energy < d.cost) return false;
  
  if (owner === 'player') playerEnergy -= d.cost; else enemyEnergy -= d.cost;
  hand.splice(idx, 1);
  
  const laneW = (W * 0.8) / 3;
  const laneX = W * 0.1 + lane * laneW + laneW / 2;
  const battleTop = 90; const battleBot = H - 130;
  const y = owner === 'player' ? battleBot - 20 : battleTop + 20;
  
  units.push({
    emoji, owner, lane, x: laneX, y,
    hp: d.hp, maxHp: d.hp,
    combatTimer: 0, hitFlash: 0,
    poisoned: false, slowed: false, buffed: false
  });
  
  sfxDeploy();
  spawnP(laneX, y, emoji, 0, owner === 'player' ? -2 : 2, 24);
  addFloat(laneX, y - 20, `-${d.cost}‚ö°`, '#ffd700', 14);
  return true;
}

function updateBattle() {
  battleTimer -= deltaTime;
  
  // Energy regen
  const rate = energyRate * (1 + (90 - battleTimer) * 0.005); // Accelerates over time
  playerEnergy = Math.min(10, playerEnergy + rate * deltaTime);
  enemyEnergy = Math.min(10, enemyEnergy + rate * deltaTime);
  
  // End conditions
  if (battleTimer <= 0 || playerHP <= 0 || enemyHP <= 0) {
    const won = playerHP > enemyHP;
    gameState = won ? 'victory' : 'defeat';
    if (won) { playerWins++; sfxVictory(); } else { playerLosses++; sfxDefeat(); }
    saveProgress();
    return;
  }
  
  // AI deployment
  const aiRate = difficulty === 'easy' ? 0.008 : difficulty === 'hard' ? 0.025 : 0.015;
  if (enemyHand.length > 0 && Math.random() < aiRate) {
    const affordable = enemyHand.filter(e => emojiDB[e].cost <= enemyEnergy);
    if (affordable.length > 0) {
      const emoji = affordable[Math.floor(Math.random() * affordable.length)];
      const lane = Math.floor(Math.random() * 3);
      deployUnit(emoji, lane, 'enemy');
    }
  }
  
  const battleTop = 90; const battleBot = H - 130;
  
  // Update units
  for (let i = units.length - 1; i >= 0; i--) {
    const u = units[i];
    const d = emojiDB[u.emoji];
    const spdMod = u.slowed ? 0.5 : (u.buffed ? 1.3 : 1);
    
    // Self-heal (Robot)
    if (u.emoji === 'ü§ñ' && u.hp < u.maxHp) u.hp = Math.min(u.maxHp, u.hp + 3 * deltaTime);
    
    // Poison damage
    if (u.poisoned) { u.hp -= 5 * deltaTime; u.poisoned = Math.max(0, u.poisoned - deltaTime); if (u.poisoned <= 0) u.poisoned = false; }
    
    u.hitFlash = Math.max(0, u.hitFlash - deltaTime * 5);
    
    // Find nearest enemy in lane
    let nearestEnemy = null; let nearestDist = Infinity;
    for (const u2 of units) {
      if (u2.owner === u.owner) continue;
      if (u.emoji === 'üå™Ô∏è' || u2.emoji === 'üå™Ô∏è' || u.lane === u2.lane) { // Tornado hits any lane
        const dist = Math.abs(u.y - u2.y);
        if (dist < nearestDist) { nearestDist = dist; nearestEnemy = u2; }
      }
    }
    
    // Combat range check
    const range = d.type === 'ranged' ? 120 : (d.type === 'magic' ? 80 : 40);
    
    if (nearestEnemy && nearestDist < range) {
      // Fight!
      u.combatTimer += deltaTime;
      if (u.combatTimer >= 1 / d.spd) {
        u.combatTimer = 0;
        
        // Calculate damage
        const ed = emojiDB[nearestEnemy.emoji];
        let dmg = d.atk;
        
        // Type advantage
        if ((d.type === 'melee' && ed.type === 'ranged') ||
            (d.type === 'ranged' && ed.type === 'magic') ||
            (d.type === 'magic' && ed.type === 'melee')) { dmg *= 1.5; }
        else if ((ed.type === 'melee' && d.type === 'ranged') ||
                 (ed.type === 'ranged' && d.type === 'magic') ||
                 (ed.type === 'magic' && d.type === 'melee')) { dmg *= 0.7; }
        
        // Defense reduction
        dmg = Math.max(1, dmg - ed.def * 0.3);
        
        // Ghost dodge
        if (nearestEnemy.emoji === 'üëª' && Math.random() < 0.5) {
          addFloat(nearestEnemy.x, nearestEnemy.y - 20, 'DODGE!', '#aaa', 12);
          dmg = 0;
        }
        
        // Sniper crit
        if (u.emoji === 'üéØ' && Math.random() < 0.3) { dmg *= 2; addFloat(u.x, u.y - 15, 'CRIT!', '#ff4444', 14); }
        
        // Star buff
        if (u.emoji === 'üåü') {
          units.filter(u2 => u2.owner === u.owner && u2.lane === u.lane && u2 !== u).forEach(ally => {
            ally.buffed = true;
            if (Math.random() < 0.1) { ally.hp = Math.min(ally.maxHp, ally.hp + 5); addFloat(ally.x, ally.y - 10, '+5', '#4CAF50', 10); }
          });
        }
        
        if (dmg > 0) {
          nearestEnemy.hp -= dmg;
          nearestEnemy.hitFlash = 1;
          sfxHit();
          
          // Poison (Snake)
          if (u.emoji === 'üêç') nearestEnemy.poisoned = 3;
          // Slow (Ice)
          if (u.emoji === '‚ùÑÔ∏è') nearestEnemy.slowed = true;
          // Burn (Fire)
          if (u.emoji === 'üî•') nearestEnemy.poisoned = Math.max(nearestEnemy.poisoned || 0, 2);
          
          addFloat(nearestEnemy.x + (Math.random()-0.5)*20, nearestEnemy.y - 15, `-${Math.floor(dmg)}`, '#ff4444', 12);
          combatFlashes.push({ x: nearestEnemy.x, y: nearestEnemy.y, life: 0.3 });
        }
      }
    } else {
      // March forward
      const speed = d.spd * spdMod * deltaTime * 35;
      u.y += u.owner === 'player' ? -speed : speed;
    }
    
    // Reach enemy base
    if (u.owner === 'player' && u.y < battleTop) {
      const dmg = Math.max(3, d.atk * 0.5);
      enemyHP -= dmg;
      addFloat(centerX, battleTop, `-${Math.floor(dmg)}HP`, '#ff4444', 16);
      shake(6);
      spawnP(u.x, u.y, 'üí•', 0, -2);
      sfxHit();
      units.splice(i, 1); continue;
    }
    if (u.owner === 'enemy' && u.y > battleBot) {
      const dmg = Math.max(3, d.atk * 0.5);
      playerHP -= dmg;
      addFloat(centerX, battleBot, `-${Math.floor(dmg)}HP`, '#ff4444', 16);
      shake(6);
      spawnP(u.x, u.y, 'üí•', 0, 2);
      sfxHit();
      units.splice(i, 1); continue;
    }
    
    // Death
    if (u.hp <= 0) {
      sfxDeath();
      spawnP(u.x, u.y, u.emoji, (Math.random()-0.5)*3, -4, 24);
      spawnP(u.x, u.y, 'üíÄ', 0, -2, 16);
      
      // Bomber explosion
      if (u.emoji === 'üí£') {
        sfxExplosion(); shake(8);
        units.filter(u2 => u2.owner !== u.owner && Math.abs(u2.x - u.x) < 80 && Math.abs(u2.y - u.y) < 80).forEach(u2 => {
          u2.hp -= 30;
          addFloat(u2.x, u2.y - 10, '-30', '#ff8800', 14);
        });
        for (let k = 0; k < 8; k++) spawnP(u.x, u.y, 'üí•', (Math.random()-0.5)*5, (Math.random()-0.5)*5, 20);
      }
      
      units.splice(i, 1);
    }
  }
  
  // Update combat flashes
  for (let i = combatFlashes.length - 1; i >= 0; i--) {
    combatFlashes[i].life -= deltaTime;
    if (combatFlashes[i].life <= 0) combatFlashes.splice(i, 1);
  }
  
  updateParticles();
  shakeAmount *= 0.9;
  
  // Player input
  for (const ev of inputEvents) {
    if (ev.type === 'tap') {
      // Tap a card
      const cardY = H - 65;
      const cardCount = playerHand.length;
      if (cardCount > 0) {
        const cardW = Math.min(90, (W - 20) / cardCount);
        const startX2 = centerX - (cardCount * cardW) / 2;
        for (let i = 0; i < cardCount; i++) {
          const cx = startX2 + i * cardW + cardW / 2;
          if (hit(ev.x, ev.y, cx, cardY, cardW - 4, 85)) {
            selectedCard = i;
            dragState.emoji = playerHand[i];
            sfxClick();
          }
        }
      }
    }
    if (ev.type === 'release' && dragState.emoji) {
      const battleTop2 = 90; const battleBot2 = H - 130;
      if (ev.y >= battleTop2 && ev.y <= battleBot2) {
        const lane = Math.min(2, Math.floor((ev.x - W * 0.1) / ((W * 0.8) / 3)));
        if (lane >= 0 && lane <= 2) deployUnit(dragState.emoji, lane, 'player');
      }
      dragState.emoji = null; selectedCard = -1;
    }
  }
}

function drawBattle() {
  // Background
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1a0a3e'); grad.addColorStop(1, '#0d0520');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);
  
  ctx.save();
  if (shakeAmount > 0.5) ctx.translate((Math.random()-0.5)*shakeAmount, (Math.random()-0.5)*shakeAmount);
  
  const battleTop = 90; const battleBot = H - 130;
  
  // Timer
  const secs = Math.max(0, Math.ceil(battleTimer));
  const timerColor = secs <= 15 ? '#ff4444' : '#fff';
  drawRR(centerX, 20, 80, 32, 10, '#222');
  drawText(`‚è± ${secs}s`, centerX, 20, 16, timerColor, 'center', '700');
  
  // Enemy HP bar
  const ehpRatio = Math.max(0, enemyHP / 100);
  drawRR(centerX, 55, W - 40, 28, 8, '#333');
  ctx.fillStyle = '#ff4444';
  ctx.beginPath(); ctx.roundRect(21, 55 - 14, (W - 42) * ehpRatio, 28, 8); ctx.fill();
  drawText(`üè∞ ${Math.max(0, Math.floor(enemyHP))}%`, centerX, 55, 14, '#fff', 'center', '700');
  
  // Battlefield lanes
  const laneW = (W * 0.8) / 3;
  for (let i = 0; i < 3; i++) {
    const lx = W * 0.1 + i * laneW;
    ctx.fillStyle = i % 2 === 0 ? 'rgba(255,255,255,0.04)' : 'rgba(255,255,255,0.02)';
    ctx.fillRect(lx, battleTop, laneW, battleBot - battleTop);
    ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
    ctx.strokeRect(lx, battleTop, laneW, battleBot - battleTop);
  }
  
  // Lane labels
  drawText('Lane 1', W * 0.1 + laneW * 0.5, battleTop + 12, 9, 'rgba(255,255,255,0.2)');
  drawText('Lane 2', W * 0.1 + laneW * 1.5, battleTop + 12, 9, 'rgba(255,255,255,0.2)');
  drawText('Lane 3', W * 0.1 + laneW * 2.5, battleTop + 12, 9, 'rgba(255,255,255,0.2)');
  
  // Combat flashes
  for (const f of combatFlashes) {
    ctx.save(); ctx.globalAlpha = f.life * 0.6;
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(f.x, f.y, 15, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  }
  
  // Units
  for (const u of units) {
    const d = emojiDB[u.emoji];
    ctx.save();
    
    // Hit flash
    if (u.hitFlash > 0) { ctx.globalAlpha = 0.5 + u.hitFlash * 0.5; }
    
    // Status effects
    if (u.poisoned) { ctx.shadowColor = '#44ff44'; ctx.shadowBlur = 8; }
    if (u.slowed) { ctx.shadowColor = '#44aaff'; ctx.shadowBlur = 8; }
    if (u.buffed) { ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 8; }
    
    drawEmoji(u.emoji, u.x, u.y, 28);
    ctx.restore();
    
    // HP bar
    const hpRatio = u.hp / u.maxHp;
    const barW = 26;
    ctx.fillStyle = '#333'; ctx.fillRect(u.x - barW/2, u.y - 20, barW, 3);
    ctx.fillStyle = hpRatio > 0.6 ? '#4CAF50' : hpRatio > 0.3 ? '#FF9800' : '#f44336';
    ctx.fillRect(u.x - barW/2, u.y - 20, barW * hpRatio, 3);
    
    // Owner indicator
    ctx.fillStyle = u.owner === 'player' ? 'rgba(68,255,68,0.4)' : 'rgba(255,68,68,0.4)';
    ctx.beginPath(); ctx.arc(u.x, u.y + 16, 3, 0, Math.PI * 2); ctx.fill();
  }
  
  drawParticles();
  ctx.restore(); // end shake
  
  // Player HP bar
  const phpRatio = Math.max(0, playerHP / 100);
  drawRR(centerX, battleBot + 22, W - 40, 28, 8, '#333');
  ctx.fillStyle = '#4CAF50';
  ctx.beginPath(); ctx.roundRect(21, battleBot + 22 - 14, (W - 42) * phpRatio, 28, 8); ctx.fill();
  drawText(`üõ°Ô∏è ${Math.max(0, Math.floor(playerHP))}%`, centerX, battleBot + 22, 14, '#fff', 'center', '700');
  
  // Energy bar
  const energyY = battleBot + 48;
  drawText(`‚ö° ${Math.floor(playerEnergy)}/10`, 40, energyY, 12, '#ffd700', 'left', '700');
  ctx.fillStyle = '#333'; ctx.fillRect(90, energyY - 5, W - 110, 10);
  ctx.fillStyle = '#ffd700'; ctx.fillRect(90, energyY - 5, (W - 110) * (playerEnergy / 10), 10);
  
  // Player hand
  const cardY = H - 65;
  const cardCount = playerHand.length;
  if (cardCount > 0) {
    const cardW = Math.min(90, (W - 20) / cardCount);
    const startX2 = centerX - (cardCount * cardW) / 2;
    for (let i = 0; i < cardCount; i++) {
      const cx = startX2 + i * cardW + cardW / 2;
      const emoji = playerHand[i];
      const d = emojiDB[emoji];
      const affordable = playerEnergy >= d.cost;
      const selected = selectedCard === i;
      
      ctx.save();
      if (!affordable) ctx.globalAlpha = 0.4;
      drawRR(cx, cardY, cardW - 4, 85, 8, selected ? '#334' : '#1a1a2e', affordable ? '#4FC3F7' : '#333');
      drawEmoji(emoji, cx, cardY - 12, 26);
      drawText(`${d.cost}‚ö°`, cx, cardY + 18, 10, affordable ? '#ffd700' : '#666', 'center', '700');
      drawText(d.name, cx, cardY + 32, 8, '#888');
      ctx.restore();
    }
  } else {
    drawText('No units left!', centerX, cardY, 14, '#666');
  }
  
  // Drag preview
  if (dragState.emoji && dragState.active) {
    ctx.save(); ctx.globalAlpha = 0.7;
    drawEmoji(dragState.emoji, dragState.x, dragState.y, 40);
    // Lane highlight
    if (dragState.y >= battleTop && dragState.y <= battleBot) {
      const lane = Math.min(2, Math.floor((dragState.x - W * 0.1) / laneW));
      if (lane >= 0) {
        ctx.fillStyle = 'rgba(68,255,68,0.15)';
        ctx.fillRect(W * 0.1 + lane * laneW, battleTop, laneW, battleBot - battleTop);
      }
    }
    ctx.restore();
  }
}

// ============================================================
// VICTORY / DEFEAT
// ============================================================
function drawVictoryDefeat() {
  const won = gameState === 'victory';
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, won ? '#2d1b69' : '#3e0a0a'); grad.addColorStop(1, won ? '#1a0a3e' : '#1a0505');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);
  
  // Confetti for victory
  if (won) {
    for (let i = 0; i < 15; i++) {
      const x = (W * (i / 15) + gameTime * 40) % W;
      const y = (gameTime * 60 + i * 70) % H;
      ctx.save(); ctx.globalAlpha = 0.5;
      drawEmoji(['üéâ','‚ú®','‚≠ê','üëë','üèÜ'][i%5], x, y, 20); ctx.restore();
    }
  }
  
  drawText(won ? 'üëë VICTORY! üëë' : 'üíÄ DEFEAT üíÄ', centerX, 100, 40, won ? '#ffd700' : '#ff4444', 'center', '900');
  
  drawRR(centerX, centerY, W - 60, 180, 16, 'rgba(255,255,255,0.08)');
  
  const hp = Math.max(0, Math.floor(playerHP));
  const ehp = Math.max(0, Math.floor(enemyHP));
  drawText(`üõ°Ô∏è Your HP: ${hp}%`, centerX, centerY - 50, 18, '#4CAF50', 'center', '600');
  drawText(`üè∞ Enemy HP: ${ehp}%`, centerX, centerY - 20, 18, '#ff4444', 'center', '600');
  drawText(`‚è±Ô∏è Time: ${Math.floor(90 - battleTimer)}s`, centerX, centerY + 10, 16, '#888');
  drawText(`üèÜ Record: ${playerWins}W - ${playerLosses}L`, centerX, centerY + 40, 16, '#888');
  
  // Your army vs theirs
  drawText('You: ' + playerArmy.join(''), centerX, centerY + 75, 14, '#aaa');
  drawText('vs: ' + enemyArmy.join(''), centerX, centerY + 95, 14, '#aaa');
  
  drawRR(centerX, H - 120, 260, 55, 14, '#4CAF50');
  drawText('‚öîÔ∏è BATTLE AGAIN', centerX, H - 120, 20, '#fff', 'center', '700');
  
  drawRR(centerX, H - 55, 200, 45, 12, '#333', '#555');
  drawText('üè† Menu', centerX, H - 55, 16, '#ccc', 'center', '600');
}

function updateVictoryDefeat() {
  for (const ev of inputEvents) {
    if (ev.type !== 'tap') continue;
    if (hit(ev.x, ev.y, centerX, H - 120, 260, 55)) { sfxClick(); gameState = 'armyBuilder'; initArmyBuilder(); return; }
    if (hit(ev.x, ev.y, centerX, H - 55, 200, 45)) { sfxClick(); gameState = 'menu'; return; }
  }
}

// ============================================================
// MAIN LOOP
// ============================================================
function loop(ts) {
  const now = ts / 1000;
  deltaTime = lastTime ? Math.min(now - lastTime, 0.1) : 0.016;
  lastTime = now; gameTime = now;
  
  if (gameState === 'menu') updateMenu();
  else if (gameState === 'armyBuilder') updateArmyBuilder();
  else if (gameState === 'battle') updateBattle();
  else updateVictoryDefeat();
  
  ctx.clearRect(0, 0, W, H);
  if (gameState === 'menu') drawMenu();
  else if (gameState === 'armyBuilder') drawArmyBuilder();
  else if (gameState === 'battle') drawBattle();
  else drawVictoryDefeat();
  
  inputEvents = [];
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
