<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Emoji Wars ‚öîÔ∏è</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #1a1a2e;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
}
canvas { display: block; width: 100%; height: 100%; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
'use strict';

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W, H, dpr, centerX, centerY;
let gameTime = 0, deltaTime = 0, lastTime = 0;
let gameState = 'menu';
let inputEvents = [];
let shakeAmount = 0;

// Progression
let wave = 1;
let maxWave = 1;
let playerWins = 0, playerLosses = 0;
let unlockedEmojis = new Set();
try {
  const s = localStorage.getItem('emojiwars2');
  if (s) { const d = JSON.parse(s); playerWins = d.w||0; playerLosses = d.l||0; maxWave = d.mw||1; unlockedEmojis = new Set(d.u||[]); }
} catch(e){}
function saveProgress() {
  try { localStorage.setItem('emojiwars2', JSON.stringify({w:playerWins,l:playerLosses,mw:maxWave,u:[...unlockedEmojis]})); } catch(e){}
}

// --- EMOJI DATABASE ---
const emojiDB = {
  '‚öîÔ∏è': { name: 'Sword', type: 'melee', hp: 120, atk: 15, def: 8, spd: 1.5, cost: 3, desc: 'Balanced fighter', unlock: 0 },
  'üó°Ô∏è': { name: 'Dagger', type: 'melee', hp: 70, atk: 12, def: 3, spd: 2.5, cost: 2, desc: 'Fast & fragile', unlock: 0 },
  'üõ°Ô∏è': { name: 'Shield', type: 'melee', hp: 200, atk: 5, def: 25, spd: 0.8, cost: 3, desc: 'Tanky wall', unlock: 0 },
  'ü¶Å': { name: 'Lion', type: 'melee', hp: 150, atk: 18, def: 10, spd: 2.0, cost: 4, desc: 'King of beasts', unlock: 2 },
  'üê∫': { name: 'Wolf', type: 'melee', hp: 90, atk: 14, def: 6, spd: 2.2, cost: 2, desc: 'Pack hunter', unlock: 0 },
  'üíÄ': { name: 'Reaper', type: 'melee', hp: 80, atk: 22, def: 3, spd: 1.2, cost: 3, desc: 'Glass cannon', unlock: 3 },
  'üèπ': { name: 'Archer', type: 'ranged', hp: 60, atk: 13, def: 3, spd: 1.0, cost: 3, desc: 'Shoots from afar', unlock: 0 },
  'üéØ': { name: 'Sniper', type: 'ranged', hp: 50, atk: 28, def: 2, spd: 0.6, cost: 4, desc: 'Critical hits', unlock: 3 },
  'üí£': { name: 'Bomber', type: 'ranged', hp: 40, atk: 8, def: 2, spd: 1.0, cost: 3, desc: 'Explodes on death', unlock: 1 },
  'ü¶Ö': { name: 'Eagle', type: 'ranged', hp: 70, atk: 10, def: 6, spd: 2.5, cost: 2, desc: 'Flying attacker', unlock: 1 },
  'üßô': { name: 'Wizard', type: 'magic', hp: 80, atk: 20, def: 5, spd: 1.0, cost: 4, desc: 'Area damage', unlock: 2 },
  '‚ö°': { name: 'Lightning', type: 'magic', hp: 60, atk: 16, def: 3, spd: 3.0, cost: 3, desc: 'Chain strikes', unlock: 1 },
  'üî•': { name: 'Fire', type: 'magic', hp: 70, atk: 14, def: 5, spd: 1.5, cost: 3, desc: 'Burn damage', unlock: 0 },
  '‚ùÑÔ∏è': { name: 'Ice', type: 'magic', hp: 90, atk: 8, def: 12, spd: 1.0, cost: 3, desc: 'Slows enemies', unlock: 2 },
  'üêâ': { name: 'Dragon', type: 'creature', hp: 300, atk: 30, def: 20, spd: 1.2, cost: 7, desc: 'Legendary!', unlock: 5 },
  'ü§ñ': { name: 'Robot', type: 'creature', hp: 180, atk: 15, def: 18, spd: 1.0, cost: 4, desc: 'Self-heals', unlock: 4 },
  'üëª': { name: 'Ghost', type: 'creature', hp: 50, atk: 12, def: 2, spd: 2.5, cost: 2, desc: 'Dodges 50%', unlock: 2 },
  'üêç': { name: 'Snake', type: 'creature', hp: 80, atk: 16, def: 5, spd: 1.8, cost: 3, desc: 'Poison bite', unlock: 3 },
  'üåü': { name: 'Star', type: 'special', hp: 60, atk: 5, def: 5, spd: 1.5, cost: 2, desc: 'Buffs allies', unlock: 4 },
  'üå™Ô∏è': { name: 'Tornado', type: 'special', hp: 40, atk: 20, def: 0, spd: 3.0, cost: 4, desc: 'Hits all lanes', unlock: 5 },
};

const emojiList = Object.keys(emojiDB);
const typeColors = { melee: '#ff6b6b', ranged: '#4ecdc4', magic: '#a29bfe', creature: '#fd79a8', special: '#fdcb6e' };
const typeIcons = { melee: '‚öîÔ∏è', ranged: 'üèπ', magic: '‚ú®', creature: 'üêâ', special: '‚≠ê' };

function isUnlocked(emoji) {
  const d = emojiDB[emoji];
  return d.unlock <= maxWave || unlockedEmojis.has(emoji);
}

// --- BATTLE STATE ---
let playerArmy = [];
let enemyArmy = [];
let units = [];
let particles = [];
let floatingTexts = [];
let battleTimer = 90;
let playerHP = 100;
let enemyHP = 100;
let playerEnergy = 5;
let enemyEnergy = 5;
let energyRate = 1;
let selectedCard = -1;
let difficulty = 'medium';
let dragState = { active: false, emoji: null, x: 0, y: 0 };
let combatFlashes = [];
let playerHand = [];
let enemyHand = [];
let battleMessages = [];
let killCount = 0;
let killStreak = 0;
let lastKillTime = 0;

// Army builder state
let builderScroll = 0;
let selectedCategory = 'all';

// --- AUDIO ---
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playTone(freq, dur, type = 'square', vol = 0.06) {
  if (!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.setValueAtTime(vol, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + dur);
}

function sfxClick() { playTone(800, 0.05, 'sine', 0.05); }
function sfxDeploy() { playTone(500, 0.08, 'square', 0.06); playTone(700, 0.06, 'sine', 0.04); }
function sfxHit() { playTone(200 + Math.random()*200, 0.06, 'sawtooth', 0.04); }
function sfxDeath() { playTone(150, 0.15, 'triangle', 0.05); playTone(80, 0.12, 'sawtooth', 0.03); }
function sfxVictory() { [523,659,784,1047].forEach((f,i) => setTimeout(() => playTone(f, 0.15, 'sine', 0.08), i*120)); }
function sfxDefeat() { playTone(400, 0.3, 'sawtooth', 0.06); setTimeout(() => playTone(200, 0.4, 'sawtooth', 0.05), 300); }
function sfxExplosion() { playTone(80, 0.25, 'sawtooth', 0.1); playTone(150, 0.15, 'square', 0.05); }
function sfxBuff() { playTone(1000, 0.08, 'sine', 0.05); playTone(1200, 0.06, 'sine', 0.03); }
function sfxStreak() { playTone(660, 0.06, 'sine', 0.06); playTone(880, 0.08, 'sine', 0.05); }
function sfxWave() { playTone(400, 0.1, 'triangle', 0.06); setTimeout(() => playTone(600, 0.15, 'triangle', 0.05), 150); }

// --- RESIZE ---
function resize() {
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  centerX = W / 2; centerY = H / 2;
}
window.addEventListener('resize', resize);
resize();

// --- INPUT ---
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault(); ensureAudio();
  const t = e.touches[0];
  inputEvents.push({ type: 'tap', x: t.clientX, y: t.clientY });
  dragState.active = true; dragState.x = t.clientX; dragState.y = t.clientY;
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (dragState.active) { const t = e.touches[0]; dragState.x = t.clientX; dragState.y = t.clientY; }
}, { passive: false });
canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  if (dragState.active) { inputEvents.push({ type: 'release', x: dragState.x, y: dragState.y }); dragState.active = false; }
});
canvas.addEventListener('mousedown', (e) => {
  ensureAudio();
  inputEvents.push({ type: 'tap', x: e.clientX, y: e.clientY });
  dragState.active = true; dragState.x = e.clientX; dragState.y = e.clientY;
});
canvas.addEventListener('mousemove', (e) => { if (dragState.active) { dragState.x = e.clientX; dragState.y = e.clientY; } });
canvas.addEventListener('mouseup', (e) => {
  if (dragState.active) { inputEvents.push({ type: 'release', x: e.clientX, y: e.clientY }); dragState.active = false; }
});

function hit(px, py, x, y, w, h) { return px >= x-w/2 && px <= x+w/2 && py >= y-h/2 && py <= y+h/2; }

// --- DRAWING ---
function drawRR(x, y, w, h, r, fill, stroke = null, lw = 2) {
  ctx.beginPath(); ctx.roundRect(x-w/2, y-h/2, w, h, r);
  if (fill) { ctx.fillStyle = fill; ctx.fill(); }
  if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = lw; ctx.stroke(); }
}
function drawText(text, x, y, size, color, align = 'center', weight = '400') {
  ctx.fillStyle = color;
  ctx.font = `${weight} ${size}px -apple-system, 'Segoe UI', sans-serif`;
  ctx.textAlign = align; ctx.textBaseline = 'middle';
  ctx.fillText(text, x, y);
}
function drawEmoji(emoji, x, y, size) {
  ctx.font = `${size}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(emoji, x, y);
}

// --- PARTICLES ---
function spawnP(x, y, emoji, vx = 0, vy = 0, size = 20) {
  particles.push({ x, y, emoji, vx, vy, life: 1, decay: 0.025, size });
}
function spawnDots(x, y, count, color) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = 1 + Math.random() * 3;
    particles.push({ x, y, emoji: null, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1, decay: 0.03 + Math.random()*0.02, size: 2 + Math.random()*3, color });
  }
}
function addFloat(x, y, text, color = '#fff', size = 16) {
  floatingTexts.push({ x, y, text, color, size, vy: -1.5, life: 1, decay: 0.02 });
}
function addBattleMsg(text, color = '#fff') {
  battleMessages.push({ text, color, life: 2, y: centerY - 80 });
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.15; p.life -= p.decay;
    if (p.life <= 0) particles.splice(i, 1);
  }
  if (particles.length > 300) particles.splice(0, particles.length - 300);
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const f = floatingTexts[i]; f.y += f.vy; f.life -= f.decay;
    if (f.life <= 0) floatingTexts.splice(i, 1);
  }
  for (let i = battleMessages.length - 1; i >= 0; i--) {
    const m = battleMessages[i]; m.life -= deltaTime; m.y -= 0.3;
    if (m.life <= 0) battleMessages.splice(i, 1);
  }
}
function drawParticles() {
  for (const p of particles) {
    ctx.save(); ctx.globalAlpha = p.life;
    if (p.emoji) { drawEmoji(p.emoji, p.x, p.y, p.size * p.life); }
    else { ctx.fillStyle = p.color || '#fff'; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2); ctx.fill(); }
    ctx.restore();
  }
  for (const f of floatingTexts) {
    ctx.save(); ctx.globalAlpha = f.life;
    ctx.shadowColor = f.color; ctx.shadowBlur = 4;
    drawText(f.text, f.x, f.y, f.size, f.color, 'center', '700');
    ctx.restore();
  }
  for (const m of battleMessages) {
    ctx.save(); ctx.globalAlpha = Math.min(1, m.life);
    ctx.shadowColor = m.color; ctx.shadowBlur = 8;
    drawText(m.text, centerX, m.y, 22, m.color, 'center', '900');
    ctx.restore();
  }
}

function shake(amt = 5) { shakeAmount = Math.max(shakeAmount, amt); }

// ============================================================
// MENU
// ============================================================
function drawMenu() {
  // Animated gradient background
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#2d1b69'); grad.addColorStop(0.5, '#1a0a3e'); grad.addColorStop(1, '#0d0520');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);
  
  // Floating battle emoji background
  const bgEmojis = ['‚öîÔ∏è','üèπ','üßô','üêâ','üí•','‚ö°','üî•','üõ°Ô∏è','ü¶Å','üëª','üí£','üéØ','‚ùÑÔ∏è','üêç','üåü'];
  for (let i = 0; i < bgEmojis.length; i++) {
    const a = (i / bgEmojis.length) * Math.PI * 2 + gameTime * 0.4;
    const r = Math.min(W, H) * 0.3;
    const x = centerX + Math.cos(a) * r;
    const y = centerY - 30 + Math.sin(a) * r * 0.4;
    ctx.save(); ctx.globalAlpha = 0.3 + Math.sin(gameTime * 2 + i) * 0.15;
    drawEmoji(bgEmojis[i], x, y, 30 + Math.sin(gameTime + i) * 4);
    ctx.restore();
  }
  
  // Title with shadow
  ctx.save(); ctx.shadowColor = '#ff4444'; ctx.shadowBlur = 20;
  drawText('EMOJI WARS', centerX, centerY - 130, 48, '#ffd700', 'center', '900');
  ctx.restore();
  drawText('‚öîÔ∏è', centerX - 130, centerY - 130, 40, '#fff');
  drawText('‚öîÔ∏è', centerX + 130, centerY - 130, 40, '#fff');
  
  drawText('Build armies ‚Ä¢ Deploy tactics ‚Ä¢ Win!', centerX, centerY - 85, 15, '#b8a0d4');
  
  // Wave indicator
  drawRR(centerX, centerY - 50, 200, 30, 12, 'rgba(255,255,255,0.08)');
  drawText(`üèÜ Wave ${maxWave} reached`, centerX, centerY - 50, 13, '#aaa');
  
  // Start button
  const pulse = Math.sin(gameTime * 4) * 4;
  drawRR(centerX, centerY + 20, 280 + pulse, 65, 16, '#ff4444', '#ff6666');
  drawText('‚öîÔ∏è BATTLE!', centerX, centerY + 20, 24, '#fff', 'center', '800');
  
  // Wave selector
  drawText(`Wave: ${wave}`, centerX, centerY + 85, 16, '#fff', 'center', '600');
  if (wave > 1) {
    drawRR(centerX - 80, centerY + 85, 40, 30, 8, '#333', '#555');
    drawText('‚óÄ', centerX - 80, centerY + 85, 16, '#ccc');
  }
  if (wave < maxWave) {
    drawRR(centerX + 80, centerY + 85, 40, 30, 8, '#333', '#555');
    drawText('‚ñ∂', centerX + 80, centerY + 85, 16, '#ccc');
  }
  
  // Difficulty
  const diffs = ['easy', 'medium', 'hard'];
  const diffColors = { easy: '#4CAF50', medium: '#FF9800', hard: '#f44336' };
  const diffLabels = { easy: 'üòä Easy', medium: 'üò§ Medium', hard: 'üíÄ Hard' };
  diffs.forEach((d, i) => {
    const x = centerX + (i - 1) * 100;
    drawRR(x, centerY + 135, 85, 36, 10, difficulty === d ? diffColors[d] : '#222', difficulty === d ? null : '#444');
    drawText(diffLabels[d], x, centerY + 135, 12, difficulty === d ? '#fff' : '#777', 'center', '600');
  });
  
  // Record
  if (playerWins + playerLosses > 0) {
    drawText(`Record: ${playerWins}W - ${playerLosses}L`, centerX, H - 40, 14, '#555');
  }
  
  drawText('v2.0', centerX, H - 18, 11, '#333');
}

function updateMenu() {
  for (const ev of inputEvents) {
    if (ev.type !== 'tap') continue;
    // Start
    if (hit(ev.x, ev.y, centerX, centerY + 20, 280, 65)) { sfxClick(); gameState = 'armyBuilder'; initArmyBuilder(); return; }
    // Wave selector
    if (wave > 1 && hit(ev.x, ev.y, centerX - 80, centerY + 85, 40, 30)) { wave--; sfxClick(); }
    if (wave < maxWave && hit(ev.x, ev.y, centerX + 80, centerY + 85, 40, 30)) { wave++; sfxClick(); }
    // Difficulty
    ['easy','medium','hard'].forEach((d, i) => {
      if (hit(ev.x, ev.y, centerX + (i-1)*100, centerY + 135, 85, 36)) { difficulty = d; sfxClick(); }
    });
  }
}

// ============================================================
// ARMY BUILDER
// ============================================================
function initArmyBuilder() {
  if (playerArmy.length === 0) playerArmy = ['‚öîÔ∏è', 'üèπ', 'üî•', 'üõ°Ô∏è', '‚öîÔ∏è', 'üê∫', 'üó°Ô∏è', '‚ö°'];
  selectedCategory = 'all';
}

function getAvailableEmojis() {
  if (selectedCategory === 'all') return emojiList.filter(e => isUnlocked(e));
  return emojiList.filter(e => emojiDB[e].type === selectedCategory && isUnlocked(e));
}

function updateArmyBuilder() {
  for (const ev of inputEvents) {
    if (ev.type !== 'tap') continue;
    
    // Back button
    if (hit(ev.x, ev.y, 40, 22, 60, 30)) { sfxClick(); gameState = 'menu'; return; }
    
    // Category tabs
    const cats = ['all', 'melee', 'ranged', 'magic', 'creature', 'special'];
    const tabW = W / cats.length;
    cats.forEach((cat, i) => {
      if (hit(ev.x, ev.y, i * tabW + tabW/2, 70, tabW - 4, 32)) { selectedCategory = cat; sfxClick(); }
    });
    
    // Emoji grid
    const emojis = getAvailableEmojis();
    const cols = Math.min(4, Math.max(2, Math.floor(W / 100)));
    const cellW = (W - 20) / cols;
    const cellH = 90;
    const startY = 105;
    emojis.forEach((emoji, i) => {
      const col = i % cols;
      const row = Math.floor(i / cols);
      const x = 10 + col * cellW + cellW / 2;
      const y = startY + row * cellH + cellH / 2;
      if (y > H - 160) return; // Don't overlap bottom panel
      if (hit(ev.x, ev.y, x, y, cellW - 8, cellH - 6)) {
        if (playerArmy.length < 8) { playerArmy.push(emoji); sfxDeploy(); }
      }
    });
    
    // Army slots (tap to remove)
    const slotW = (W - 20) / 8;
    playerArmy.forEach((_, i) => {
      const x = 10 + i * slotW + slotW / 2;
      if (hit(ev.x, ev.y, x, H - 110, slotW - 4, 65)) { playerArmy.splice(i, 1); sfxClick(); }
    });
    
    // Battle button
    if (playerArmy.length >= 3 && hit(ev.x, ev.y, centerX, H - 35, 280, 50)) {
      sfxClick(); gameState = 'battle'; initBattle();
    }
    
    // Clear button
    if (hit(ev.x, ev.y, W - 45, 22, 70, 30)) { playerArmy = []; sfxClick(); }
  }
}

function drawArmyBuilder() {
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1a0a3e'); grad.addColorStop(1, '#0d0520');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);
  
  // Header
  drawRR(40, 22, 60, 30, 8, '#333', '#555');
  drawText('‚Üê Back', 40, 22, 11, '#ccc');
  drawText('BUILD YOUR ARMY', centerX, 22, 18, '#ffd700', 'center', '800');
  drawRR(W - 45, 22, 70, 30, 8, '#333', '#555');
  drawText('Clear', W - 45, 22, 11, '#ccc');
  
  // Category tabs
  const cats = ['all', 'melee', 'ranged', 'magic', 'creature', 'special'];
  const catLabels = { all: 'üìã All', melee: '‚öîÔ∏è Melee', ranged: 'üèπ Range', magic: '‚ú® Magic', creature: 'üêâ Beast', special: '‚≠ê Spec' };
  const tabW = W / cats.length;
  cats.forEach((cat, i) => {
    const x = i * tabW + tabW/2;
    const active = selectedCategory === cat;
    drawRR(x, 70, tabW - 4, 32, 6, active ? (typeColors[cat] || '#555') : '#181818', active ? null : '#333');
    drawText(catLabels[cat], x, 70, 10, active ? '#fff' : '#777', 'center', '600');
  });
  
  // Emoji grid
  const emojis = getAvailableEmojis();
  const cols = Math.min(4, Math.max(2, Math.floor(W / 100)));
  const cellW = (W - 20) / cols;
  const cellH = 90;
  const startY = 105;
  
  emojis.forEach((emoji, i) => {
    const col = i % cols;
    const row = Math.floor(i / cols);
    const x = 10 + col * cellW + cellW / 2;
    const y = startY + row * cellH + cellH / 2;
    if (y > H - 170) return;
    
    const d = emojiDB[emoji];
    const inArmy = playerArmy.filter(e => e === emoji).length;
    
    drawRR(x, y, cellW - 8, cellH - 6, 10, inArmy > 0 ? '#1a2a3e' : '#111', typeColors[d.type] || '#555', inArmy > 0 ? 2 : 1);
    drawEmoji(emoji, x, y - 16, 28);
    drawText(d.name, x, y + 10, 10, '#ccc', 'center', '600');
    
    // Stats bar
    const barY = y + 24;
    drawText(`‚öî${d.atk}`, x - 22, barY, 8, '#f88', 'center');
    drawText(`üõ°${d.def}`, x, barY, 8, '#88f', 'center');
    drawText(`${d.cost}‚ö°`, x + 22, barY, 8, '#fd4', 'center');
    
    // Count in army
    if (inArmy > 0) {
      drawRR(x + cellW/2 - 14, y - cellH/2 + 10, 18, 18, 9, typeColors[d.type]);
      drawText(`${inArmy}`, x + cellW/2 - 14, y - cellH/2 + 10, 10, '#fff', 'center', '700');
    }
  });
  
  // Locked emojis preview
  const locked = emojiList.filter(e => !isUnlocked(e));
  if (locked.length > 0 && emojis.length < 8) {
    const lockedRow = Math.ceil(emojis.length / cols);
    const ly = startY + lockedRow * cellH + 20;
    if (ly < H - 170) {
      drawText(`üîí ${locked.length} units unlock at higher waves`, centerX, ly, 11, '#555');
    }
  }
  
  // Bottom panel - army slots
  const panelY = H - 145;
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, panelY, W, 145);
  
  drawText(`Army: ${playerArmy.length}/8`, centerX, panelY + 10, 12, '#aaa');
  
  const slotW = (W - 20) / 8;
  for (let i = 0; i < 8; i++) {
    const x = 10 + i * slotW + slotW / 2;
    const y = panelY + 45;
    const emoji = playerArmy[i];
    
    drawRR(x, y, slotW - 4, 55, 8, emoji ? 'rgba(255,255,255,0.06)' : 'rgba(255,255,255,0.02)', emoji ? '#4FC3F7' : '#333');
    if (emoji) {
      drawEmoji(emoji, x, y - 6, 24);
      drawText(`${emojiDB[emoji].cost}‚ö°`, x, y + 18, 8, '#fd4', 'center', '600');
    } else {
      drawText('+', x, y, 18, '#333');
    }
  }
  
  // Total cost
  const totalCost = playerArmy.reduce((s, e) => s + emojiDB[e].cost, 0);
  drawText(`Total cost: ${totalCost}‚ö°`, centerX, panelY + 82, 11, '#888');
  
  // Type advantage reminder
  drawText('‚öîÔ∏è‚Üíüèπ‚Üí‚ú®‚Üí‚öîÔ∏è  (type beats type)', centerX, panelY + 96, 10, '#555');
  
  // Battle button
  if (playerArmy.length >= 3) {
    const pulse = Math.sin(gameTime * 5) * 3;
    drawRR(centerX, H - 35, 280 + pulse, 50, 14, '#44ff44', '#2d2');
    drawText(`‚öîÔ∏è WAVE ${wave} BATTLE!`, centerX, H - 35, 18, '#000', 'center', '800');
  } else {
    drawRR(centerX, H - 35, 280, 50, 14, '#222');
    drawText('Add at least 3 units', centerX, H - 35, 14, '#555');
  }
}

// ============================================================
// BATTLE
// ============================================================
function initBattle() {
  enemyArmy = generateEnemyArmy();
  battleTimer = 90;
  playerHP = 100; enemyHP = 100;
  playerEnergy = 5; enemyEnergy = 5;
  units = []; particles = []; floatingTexts = []; combatFlashes = []; battleMessages = [];
  selectedCard = -1;
  killCount = 0; killStreak = 0; lastKillTime = 0;
  playerHand = [...playerArmy];
  enemyHand = [...enemyArmy];
}

function generateEnemyArmy() {
  const available = emojiList.filter(e => emojiDB[e].unlock <= wave);
  const army = [];
  const budget = (difficulty === 'easy' ? 16 : difficulty === 'hard' ? 28 : 22) + wave * 2;
  let spent = 0;
  
  while (army.length < 8 && spent < budget) {
    let pool = available;
    if (difficulty === 'hard') {
      // Smart counter-picking
      const types = {};
      playerArmy.forEach(e => { const t = emojiDB[e].type; types[t] = (types[t]||0)+1; });
      const dom = Object.keys(types).sort((a,b) => types[b]-types[a])[0];
      const counter = { melee: 'magic', ranged: 'melee', magic: 'ranged' }[dom] || 'creature';
      if (Math.random() < 0.5) pool = available.filter(e => emojiDB[e].type === counter);
      if (pool.length === 0) pool = available;
    }
    const e = pool[Math.floor(Math.random() * pool.length)];
    if (spent + emojiDB[e].cost <= budget) { army.push(e); spent += emojiDB[e].cost; }
    else break;
  }
  return army;
}

function deployUnit(emoji, lane, owner) {
  const hand = owner === 'player' ? playerHand : enemyHand;
  const idx = hand.indexOf(emoji);
  if (idx === -1) return false;
  
  const d = emojiDB[emoji];
  const energy = owner === 'player' ? playerEnergy : enemyEnergy;
  if (energy < d.cost) return false;
  
  if (owner === 'player') playerEnergy -= d.cost; else enemyEnergy -= d.cost;
  hand.splice(idx, 1);
  
  const laneW = (W * 0.8) / 3;
  const laneX = W * 0.1 + lane * laneW + laneW / 2;
  const battleTop = 80; const battleBot = H - 140;
  const y = owner === 'player' ? battleBot - 15 : battleTop + 15;
  
  // Wave scaling for enemies
  const waveMult = owner === 'enemy' ? 1 + (wave - 1) * 0.12 : 1;
  
  units.push({
    emoji, owner, lane, x: laneX, y,
    hp: Math.floor(d.hp * waveMult), maxHp: Math.floor(d.hp * waveMult),
    combatTimer: 0, hitFlash: 0,
    poisoned: false, slowed: false, buffed: false,
    spawnTime: gameTime
  });
  
  sfxDeploy();
  spawnP(laneX, y, emoji, 0, owner === 'player' ? -2 : 2, 22);
  addFloat(laneX, y - 20, `-${d.cost}‚ö°`, '#ffd700', 12);
  return true;
}

function updateBattle() {
  battleTimer -= deltaTime;
  
  const rate = energyRate * (1 + (90 - battleTimer) * 0.005);
  playerEnergy = Math.min(10, playerEnergy + rate * deltaTime);
  enemyEnergy = Math.min(10, enemyEnergy + rate * deltaTime);
  
  if (battleTimer <= 0 || playerHP <= 0 || enemyHP <= 0) {
    const won = playerHP > enemyHP;
    if (won) {
      playerWins++;
      if (wave >= maxWave) { maxWave = wave + 1; }
      // Unlock check
      const newUnlocks = emojiList.filter(e => emojiDB[e].unlock === wave && !unlockedEmojis.has(e));
      newUnlocks.forEach(e => unlockedEmojis.add(e));
      sfxVictory();
    } else {
      playerLosses++;
      sfxDefeat();
    }
    gameState = won ? 'victory' : 'defeat';
    saveProgress();
    return;
  }
  
  // AI deployment
  const aiRate = difficulty === 'easy' ? 0.007 : difficulty === 'hard' ? 0.02 : 0.012;
  if (enemyHand.length > 0 && Math.random() < aiRate) {
    const affordable = enemyHand.filter(e => emojiDB[e].cost <= enemyEnergy);
    if (affordable.length > 0) {
      const emoji = affordable[Math.floor(Math.random() * affordable.length)];
      // Smart lane choice: deploy where there are fewer friendly units
      const laneCounts = [0,0,0];
      units.filter(u => u.owner === 'enemy').forEach(u => laneCounts[u.lane]++);
      const minLane = laneCounts.indexOf(Math.min(...laneCounts));
      deployUnit(emoji, minLane, 'enemy');
    }
  }
  
  const battleTop = 80; const battleBot = H - 140;
  
  // Update units
  for (let i = units.length - 1; i >= 0; i--) {
    const u = units[i];
    const d = emojiDB[u.emoji];
    const spdMod = u.slowed ? 0.5 : (u.buffed ? 1.3 : 1);
    
    if (u.emoji === 'ü§ñ' && u.hp < u.maxHp) u.hp = Math.min(u.maxHp, u.hp + 3 * deltaTime);
    if (u.poisoned) { u.hp -= 5 * deltaTime; u.poisoned = Math.max(0, u.poisoned - deltaTime); if (u.poisoned <= 0) u.poisoned = false; }
    u.hitFlash = Math.max(0, u.hitFlash - deltaTime * 5);
    
    let nearestEnemy = null; let nearestDist = Infinity;
    for (const u2 of units) {
      if (u2.owner === u.owner) continue;
      if (u.emoji === 'üå™Ô∏è' || u2.emoji === 'üå™Ô∏è' || u.lane === u2.lane) {
        const dist = Math.abs(u.y - u2.y);
        if (dist < nearestDist) { nearestDist = dist; nearestEnemy = u2; }
      }
    }
    
    const range = d.type === 'ranged' ? 140 : (d.type === 'magic' ? 100 : 45);
    
    if (nearestEnemy && nearestDist < range) {
      u.combatTimer += deltaTime;
      if (u.combatTimer >= 1 / d.spd) {
        u.combatTimer = 0;
        
        const ed = emojiDB[nearestEnemy.emoji];
        let dmg = d.atk;
        
        // Type advantage
        let typeAdv = false;
        if ((d.type === 'melee' && ed.type === 'ranged') ||
            (d.type === 'ranged' && ed.type === 'magic') ||
            (d.type === 'magic' && ed.type === 'melee')) { dmg *= 1.5; typeAdv = true; }
        else if ((ed.type === 'melee' && d.type === 'ranged') ||
                 (ed.type === 'ranged' && d.type === 'magic') ||
                 (ed.type === 'magic' && d.type === 'melee')) { dmg *= 0.7; }
        
        dmg = Math.max(1, dmg - ed.def * 0.3);
        
        // Ghost dodge
        if (nearestEnemy.emoji === 'üëª' && Math.random() < 0.5) {
          addFloat(nearestEnemy.x, nearestEnemy.y - 20, 'DODGE', '#aaa', 10);
          dmg = 0;
        }
        
        // Sniper crit
        if (u.emoji === 'üéØ' && Math.random() < 0.3) { dmg *= 2; addFloat(u.x, u.y - 15, 'CRIT!', '#ff4444', 12); }
        
        // Wolf pack bonus
        if (u.emoji === 'üê∫') {
          const packSize = units.filter(u2 => u2.owner === u.owner && u2.emoji === 'üê∫' && u2 !== u).length;
          dmg *= 1 + packSize * 0.2;
        }
        
        // Star buff
        if (u.emoji === 'üåü') {
          units.filter(u2 => u2.owner === u.owner && u2.lane === u.lane && u2 !== u).forEach(ally => {
            ally.buffed = true;
            if (Math.random() < 0.1) { ally.hp = Math.min(ally.maxHp, ally.hp + 5); addFloat(ally.x, ally.y - 10, '+5', '#4CAF50', 9); sfxBuff(); }
          });
        }
        
        if (dmg > 0) {
          nearestEnemy.hp -= dmg;
          nearestEnemy.hitFlash = 1;
          sfxHit();
          
          if (u.emoji === 'üêç') nearestEnemy.poisoned = 3;
          if (u.emoji === '‚ùÑÔ∏è') nearestEnemy.slowed = true;
          if (u.emoji === 'üî•') nearestEnemy.poisoned = Math.max(nearestEnemy.poisoned || 0, 2);
          
          const dmgStr = Math.floor(dmg);
          addFloat(nearestEnemy.x + (Math.random()-0.5)*16, nearestEnemy.y - 15, 
            typeAdv ? `${dmgStr}!` : `${dmgStr}`, typeAdv ? '#ff8' : '#ff4444', typeAdv ? 13 : 11);
          
          spawnDots(nearestEnemy.x, nearestEnemy.y, 3, typeColors[d.type] || '#fff');
          combatFlashes.push({ x: (u.x + nearestEnemy.x)/2, y: (u.y + nearestEnemy.y)/2, life: 0.2 });
          
          // Ranged projectile trail
          if (d.type === 'ranged' || d.type === 'magic') {
            spawnDots(u.x, u.y, 2, typeColors[d.type]);
          }
        }
      }
    } else {
      const speed = d.spd * spdMod * deltaTime * 40;
      const moveDir = u.owner === 'player' ? -1 : 1;
      // Prevent friendly unit stacking: check for allies ahead
      let blocked = false;
      for (const u2 of units) {
        if (u2 === u || u2.owner !== u.owner || u2.lane !== u.lane) continue;
        const dy = (u2.y - u.y) * moveDir;
        if (dy > 0 && dy < 28) { blocked = true; break; }
      }
      if (!blocked) u.y += moveDir * speed;
    }
    
    // Reach enemy base
    if (u.owner === 'player' && u.y < battleTop) {
      const dmg = Math.max(3, d.atk * 0.5);
      enemyHP -= dmg;
      addFloat(centerX, battleTop + 10, `-${Math.floor(dmg)}%`, '#ff4444', 14);
      shake(6);
      spawnDots(u.x, u.y, 8, '#f44');
      sfxHit();
      units.splice(i, 1); continue;
    }
    if (u.owner === 'enemy' && u.y > battleBot) {
      const dmg = Math.max(3, d.atk * 0.5);
      playerHP -= dmg;
      addFloat(centerX, battleBot - 10, `-${Math.floor(dmg)}%`, '#ff4444', 14);
      shake(6);
      spawnDots(u.x, u.y, 8, '#f44');
      sfxHit();
      units.splice(i, 1); continue;
    }
    
    // Death
    if (u.hp <= 0) {
      sfxDeath();
      spawnP(u.x, u.y, u.emoji, (Math.random()-0.5)*3, -4, 22);
      spawnP(u.x, u.y, 'üí•', 0, -1, 14);
      spawnDots(u.x, u.y, 6, typeColors[d.type] || '#fff');
      
      // Kill tracking
      if (u.owner === 'enemy') {
        killCount++;
        if (gameTime - lastKillTime < 2) { killStreak++; } else { killStreak = 1; }
        lastKillTime = gameTime;
        if (killStreak >= 3) { addBattleMsg(`üî• ${killStreak}x STREAK!`, '#ff8800'); sfxStreak(); }
      }
      
      // Bomber explosion
      if (u.emoji === 'üí£') {
        sfxExplosion(); shake(10);
        units.filter(u2 => u2.owner !== u.owner && Math.abs(u2.x - u.x) < 90 && Math.abs(u2.y - u.y) < 90).forEach(u2 => {
          u2.hp -= 35; u2.hitFlash = 1;
          addFloat(u2.x, u2.y - 10, '-35', '#ff8800', 12);
        });
        for (let k = 0; k < 12; k++) spawnP(u.x, u.y, 'üí•', (Math.random()-0.5)*6, (Math.random()-0.5)*6, 16);
        spawnDots(u.x, u.y, 15, '#ff8800');
      }
      
      units.splice(i, 1);
    }
  }
  
  for (let i = combatFlashes.length - 1; i >= 0; i--) {
    combatFlashes[i].life -= deltaTime;
    if (combatFlashes[i].life <= 0) combatFlashes.splice(i, 1);
  }
  
  updateParticles();
  shakeAmount *= 0.9;
  
  // Player input
  for (const ev of inputEvents) {
    if (ev.type === 'tap') {
      const cardY = H - 70;
      const cardCount = playerHand.length;
      if (cardCount > 0) {
        const cardW = Math.min(80, (W - 20) / cardCount);
        const startX = centerX - (cardCount * cardW) / 2;
        for (let i = 0; i < cardCount; i++) {
          const cx = startX + i * cardW + cardW / 2;
          if (hit(ev.x, ev.y, cx, cardY, cardW - 4, 80)) {
            selectedCard = i;
            dragState.emoji = playerHand[i];
            sfxClick();
          }
        }
      }
    }
    if (ev.type === 'release' && dragState.emoji) {
      const battleTop2 = 80; const battleBot2 = H - 140;
      if (ev.y >= battleTop2 && ev.y <= battleBot2) {
        const laneW = (W * 0.8) / 3;
        const lane = Math.min(2, Math.max(0, Math.floor((ev.x - W * 0.1) / laneW)));
        deployUnit(dragState.emoji, lane, 'player');
      }
      dragState.emoji = null; selectedCard = -1;
    }
  }
}

function drawBattle() {
  // Background with subtle animation
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1a0a3e'); grad.addColorStop(1, '#0d0520');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);
  
  ctx.save();
  if (shakeAmount > 0.5) ctx.translate((Math.random()-0.5)*shakeAmount, (Math.random()-0.5)*shakeAmount);
  
  const battleTop = 80; const battleBot = H - 140;
  
  // Timer + wave counter
  const secs = Math.max(0, Math.ceil(battleTimer));
  const timerColor = secs <= 15 ? '#ff4444' : '#fff';
  drawRR(centerX, 18, 100, 28, 10, '#111', '#333');
  drawText(`‚è± ${secs}s`, centerX, 18, 13, timerColor, 'center', '700');

  // Wave counter (left side, prominent)
  drawRR(35, 18, 60, 26, 8, 'rgba(255,215,0,0.15)', '#ffd700', 1);
  drawText(`W${wave}`, 35, 18, 13, '#ffd700', 'center', '800');

  // Kill count (right side)
  if (killCount > 0) {
    drawRR(W - 35, 18, 50, 26, 8, 'rgba(255,68,68,0.1)', '#555');
    drawText(`üíÄ${killCount}`, W - 35, 18, 11, '#aaa', 'center', '600');
  }
  
  // Enemy HP bar
  const ehpRatio = Math.max(0, enemyHP / 100);
  drawRR(centerX, 48, W - 30, 24, 8, '#222');
  if (ehpRatio > 0) {
    ctx.fillStyle = '#ff4444';
    ctx.beginPath(); ctx.roundRect(16, 48 - 12, (W - 32) * ehpRatio, 24, 8); ctx.fill();
  }
  drawText(`üè∞ ${Math.max(0, Math.floor(enemyHP))}%`, centerX, 48, 12, '#fff', 'center', '700');
  
  // Battlefield
  const laneW = (W * 0.8) / 3;
  for (let i = 0; i < 3; i++) {
    const lx = W * 0.1 + i * laneW;
    // Lane gradient
    const lg = ctx.createLinearGradient(lx, battleTop, lx, battleBot);
    lg.addColorStop(0, 'rgba(255,50,50,0.06)');
    lg.addColorStop(0.5, 'rgba(255,255,255,0.02)');
    lg.addColorStop(1, 'rgba(50,255,50,0.06)');
    ctx.fillStyle = lg;
    ctx.fillRect(lx, battleTop, laneW, battleBot - battleTop);
    
    // Lane borders
    ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1;
    ctx.strokeRect(lx, battleTop, laneW, battleBot - battleTop);
    
    // Center line
    ctx.save(); ctx.globalAlpha = 0.1;
    ctx.setLineDash([5, 5]);
    ctx.beginPath(); ctx.moveTo(lx, (battleTop + battleBot)/2); ctx.lineTo(lx + laneW, (battleTop + battleBot)/2);
    ctx.strokeStyle = '#fff'; ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }
  
  // Combat flashes
  for (const f of combatFlashes) {
    ctx.save(); ctx.globalAlpha = f.life * 0.5;
    const grad2 = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, 20);
    grad2.addColorStop(0, '#fff');
    grad2.addColorStop(1, 'transparent');
    ctx.fillStyle = grad2;
    ctx.fillRect(f.x - 20, f.y - 20, 40, 40);
    ctx.restore();
  }
  
  // Units
  for (const u of units) {
    const d = emojiDB[u.emoji];
    ctx.save();
    
    // Spawn animation
    const age = gameTime - u.spawnTime;
    if (age < 0.3) {
      const scale = 0.5 + age / 0.3 * 0.5;
      ctx.translate(u.x, u.y);
      ctx.scale(scale, scale);
      ctx.translate(-u.x, -u.y);
    }
    
    // Hit flash
    if (u.hitFlash > 0) {
      ctx.globalAlpha = 0.5 + u.hitFlash * 0.5;
      ctx.shadowColor = '#fff';
      ctx.shadowBlur = u.hitFlash * 10;
    }
    
    // Status effects glow
    if (u.poisoned) { ctx.shadowColor = '#44ff44'; ctx.shadowBlur = 8; }
    if (u.slowed) { ctx.shadowColor = '#44aaff'; ctx.shadowBlur = 8; }
    if (u.buffed) { ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 8; }
    
    drawEmoji(u.emoji, u.x, u.y, 26);
    ctx.restore();
    
    // HP bar (improved: larger with border and label)
    const hpRatio = u.hp / u.maxHp;
    const barW = 30;
    const barH = 5;
    const barY2 = u.y - 20;
    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(u.x - barW/2 - 1, barY2 - 1, barW + 2, barH + 2);
    // Bar fill
    ctx.fillStyle = hpRatio > 0.6 ? '#4CAF50' : hpRatio > 0.3 ? '#FF9800' : '#f44336';
    ctx.fillRect(u.x - barW/2, barY2, barW * Math.max(0, hpRatio), barH);
    // Border
    ctx.strokeStyle = 'rgba(255,255,255,0.25)'; ctx.lineWidth = 0.5;
    ctx.strokeRect(u.x - barW/2, barY2, barW, barH);

    // Owner indicator
    ctx.fillStyle = u.owner === 'player' ? 'rgba(68,255,68,0.6)' : 'rgba(255,68,68,0.6)';
    ctx.beginPath(); ctx.arc(u.x, u.y + 16, 3, 0, Math.PI * 2); ctx.fill();
  }
  
  drawParticles();
  ctx.restore(); // end shake
  
  // Player HP bar
  const phpRatio = Math.max(0, playerHP / 100);
  const phpY = battleBot + 15;
  drawRR(centerX, phpY, W - 30, 24, 8, '#222');
  if (phpRatio > 0) {
    ctx.fillStyle = '#4CAF50';
    ctx.beginPath(); ctx.roundRect(16, phpY - 12, (W - 32) * phpRatio, 24, 8); ctx.fill();
  }
  drawText(`üõ°Ô∏è ${Math.max(0, Math.floor(playerHP))}%`, centerX, phpY, 12, '#fff', 'center', '700');
  
  // Energy
  const ey = phpY + 18;
  drawText(`‚ö° ${Math.floor(playerEnergy)}`, 20, ey, 11, '#ffd700', 'left', '700');
  ctx.fillStyle = '#222'; ctx.fillRect(60, ey - 4, W - 80, 8);
  ctx.fillStyle = '#ffd700'; ctx.fillRect(60, ey - 4, (W - 80) * (playerEnergy / 10), 8);
  
  // Streak display
  if (killStreak >= 3) {
    drawText(`üî• ${killStreak}x`, W - 20, ey, 11, '#ff8800', 'right');
  }
  
  // Player hand
  const cardY = H - 70;
  const cardCount = playerHand.length;
  if (cardCount > 0) {
    const cardW = Math.min(80, (W - 20) / cardCount);
    const startX = centerX - (cardCount * cardW) / 2;
    for (let i = 0; i < cardCount; i++) {
      const cx = startX + i * cardW + cardW / 2;
      const emoji = playerHand[i];
      const d = emojiDB[emoji];
      const affordable = playerEnergy >= d.cost;
      const selected = selectedCard === i;
      
      ctx.save();
      if (!affordable) ctx.globalAlpha = 0.35;
      drawRR(cx, cardY, cardW - 4, 75, 8, selected ? '#223' : '#111', affordable ? typeColors[d.type] : '#333', affordable ? 2 : 1);
      drawEmoji(emoji, cx, cardY - 12, 24);
      drawText(`${d.cost}‚ö°`, cx, cardY + 14, 9, affordable ? '#ffd700' : '#555', 'center', '700');
      drawText(d.name, cx, cardY + 28, 7, '#888');
      ctx.restore();
    }
  } else {
    drawText('No units left!', centerX, cardY, 13, '#555');
  }
  
  // Drag preview
  if (dragState.emoji && dragState.active) {
    ctx.save(); ctx.globalAlpha = 0.7;
    drawEmoji(dragState.emoji, dragState.x, dragState.y, 40);
    if (dragState.y >= battleTop && dragState.y <= battleBot) {
      const lane = Math.min(2, Math.max(0, Math.floor((dragState.x - W * 0.1) / laneW)));
      ctx.fillStyle = 'rgba(68,255,68,0.12)';
      ctx.fillRect(W * 0.1 + lane * laneW, battleTop, laneW, battleBot - battleTop);
    }
    ctx.restore();
  }
}

// ============================================================
// VICTORY / DEFEAT
// ============================================================
function drawVictoryDefeat() {
  const won = gameState === 'victory';
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, won ? '#1a2a1a' : '#3e0a0a'); grad.addColorStop(1, won ? '#0a1a0a' : '#1a0505');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H);
  
  if (won) {
    for (let i = 0; i < 20; i++) {
      const x = (W * (i / 20) + gameTime * 50) % W;
      const y = (gameTime * 70 + i * 60) % H;
      ctx.save(); ctx.globalAlpha = 0.4;
      drawEmoji(['üéâ','‚ú®','‚≠ê','üëë','üèÜ'][i%5], x, y, 18); ctx.restore();
    }
  }
  
  // Title
  drawText(won ? 'üëë VICTORY! üëë' : 'üíÄ DEFEAT üíÄ', centerX, 80, 38, won ? '#ffd700' : '#ff4444', 'center', '900');
  
  // Stats card
  drawRR(centerX, centerY - 10, W - 50, 200, 16, 'rgba(255,255,255,0.06)', '#333');
  
  drawText(`Wave ${wave}`, centerX, centerY - 70, 16, '#aaa');
  drawText(`üõ°Ô∏è Your HP: ${Math.max(0, Math.floor(playerHP))}%`, centerX, centerY - 40, 16, '#4CAF50', 'center', '600');
  drawText(`üè∞ Enemy HP: ${Math.max(0, Math.floor(enemyHP))}%`, centerX, centerY - 15, 16, '#ff4444', 'center', '600');
  drawText(`üíÄ Kills: ${killCount}`, centerX, centerY + 10, 14, '#888');
  drawText(`‚è±Ô∏è Time: ${Math.floor(90 - battleTimer)}s`, centerX, centerY + 32, 14, '#888');
  
  // Armies
  drawText('You: ' + playerArmy.join(' '), centerX, centerY + 60, 12, '#aaa');
  drawText('vs: ' + enemyArmy.join(' '), centerX, centerY + 78, 12, '#aaa');
  
  // Unlock notification
  if (won) {
    const newUnlocks = emojiList.filter(e => emojiDB[e].unlock === wave);
    if (newUnlocks.length > 0) {
      drawRR(centerX, centerY + 115, W - 60, 40, 10, '#224', '#4af');
      drawText(`üîì Unlocked: ${newUnlocks.map(e => `${e} ${emojiDB[e].name}`).join(', ')}`, centerX, centerY + 115, 12, '#4af');
    }
    
    drawText(`üèÜ Next: Wave ${wave + 1}`, centerX, centerY + 145, 13, '#888');
  }
  
  // Buttons
  const btnY1 = H - 110;
  const btnY2 = H - 50;
  
  if (won) {
    drawRR(centerX, btnY1, 260, 50, 14, '#4CAF50');
    drawText(`‚öîÔ∏è WAVE ${wave + 1}`, centerX, btnY1, 18, '#fff', 'center', '700');
  }
  
  drawRR(centerX, won ? btnY2 : btnY1, 200, 42, 12, '#333', '#555');
  drawText('üîÑ Rebuild Army', centerX, won ? btnY2 : btnY1, 14, '#ccc', 'center', '600');
  
  if (!won) {
    drawRR(centerX, btnY2, 200, 42, 12, '#222', '#444');
    drawText('üè† Menu', centerX, btnY2, 14, '#888', 'center', '600');
  }
}

function updateVictoryDefeat() {
  const won = gameState === 'victory';
  for (const ev of inputEvents) {
    if (ev.type !== 'tap') continue;
    const btnY1 = H - 110;
    const btnY2 = H - 50;
    
    if (won && hit(ev.x, ev.y, centerX, btnY1, 260, 50)) {
      wave++;
      sfxWave();
      gameState = 'armyBuilder';
      initArmyBuilder();
      return;
    }
    
    if (hit(ev.x, ev.y, centerX, won ? btnY2 : btnY1, 200, 42)) {
      sfxClick();
      gameState = 'armyBuilder';
      initArmyBuilder();
      return;
    }
    
    if (!won && hit(ev.x, ev.y, centerX, btnY2, 200, 42)) {
      sfxClick();
      gameState = 'menu';
      return;
    }
  }
}

// ============================================================
// MAIN LOOP
// ============================================================
function loop(ts) {
  const now = ts / 1000;
  deltaTime = lastTime ? Math.min(now - lastTime, 0.1) : 0.016;
  lastTime = now; gameTime = now;
  
  if (gameState === 'menu') updateMenu();
  else if (gameState === 'armyBuilder') updateArmyBuilder();
  else if (gameState === 'battle') updateBattle();
  else updateVictoryDefeat();
  
  ctx.clearRect(0, 0, W, H);
  if (gameState === 'menu') drawMenu();
  else if (gameState === 'armyBuilder') drawArmyBuilder();
  else if (gameState === 'battle') drawBattle();
  else drawVictoryDefeat();
  
  inputEvents = [];
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
