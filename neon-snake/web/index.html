<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>Neon Snake</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#0a0a1a">
<meta name="description" content="Neon-styled snake game with power-ups, obstacles, and AI opponent mode">
<meta property="og:title" content="Neon Snake â€” Mobile Games Lab">
<meta property="og:description" content="Classic snake reimagined with neon visuals and power-ups">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Neon Snake">
<meta name="twitter:description" content="Neon snake game with power-ups and AI opponent">
<link rel="manifest" href="manifest.json">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:-apple-system,system-ui,sans-serif;touch-action:none;user-select:none}
canvas{display:block;position:absolute;top:0;left:0}
#ui{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}
#score{position:absolute;top:16px;left:16px;color:#0ff;font-size:1.4rem;font-weight:900;text-shadow:0 0 10px #0ff;transition:transform 0.1s}
#score.bump{transform:scale(1.3)}
#highscore{position:absolute;top:16px;right:16px;color:#f0f;font-size:0.9rem;font-weight:700;text-shadow:0 0 8px #f0f}
#powerup-indicator{position:absolute;top:48px;left:16px;color:#ff0;font-size:0.8rem;font-weight:600}
#pause-hint{position:absolute;bottom:16px;right:16px;color:rgba(255,255,255,0.2);font-size:0.7rem}
.overlay{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(10,10,26,0.92);pointer-events:auto;z-index:20}
.overlay h1{font-size:clamp(2rem,8vw,4rem);font-weight:900;background:linear-gradient(135deg,#0ff,#f0f,#ff0);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:8px}
.overlay h2{color:#fff;font-size:1.2rem;margin-bottom:24px;font-weight:400}
.overlay .sub{color:#888;font-size:0.85rem;margin-bottom:16px}
.overlay .final-score{color:#0ff;font-size:2.5rem;font-weight:900;margin:8px 0;text-shadow:0 0 20px #0ff}
.overlay .score-breakdown{color:#aaa;font-size:0.8rem;margin:4px 0}
.btn{pointer-events:auto;background:linear-gradient(135deg,#0ff,#f0f);border:none;color:#000;font-weight:900;font-size:1.1rem;padding:14px 40px;border-radius:50px;cursor:pointer;margin:8px;text-transform:uppercase;letter-spacing:2px;transition:transform 0.15s,box-shadow 0.15s}
.btn:hover{box-shadow:0 0 30px rgba(0,255,255,0.3)}
.btn:active{transform:scale(0.95)}
.controls-hint{color:#666;font-size:0.75rem;margin-top:20px;line-height:1.6}
.hidden{display:none!important}
.toggle-wrap{display:flex;align-items:center;gap:8px;margin-top:12px;cursor:pointer;color:#888;font-size:0.85rem}
.toggle-wrap input{display:none}
.toggle-wrap .track{width:40px;height:22px;border-radius:11px;background:rgba(255,255,255,0.15);position:relative;transition:background 0.2s}
.toggle-wrap .track::after{content:'';position:absolute;width:18px;height:18px;border-radius:50%;background:#fff;top:2px;left:2px;transition:transform 0.2s}
.toggle-wrap input:checked+.track{background:#0ff}
.toggle-wrap input:checked+.track::after{transform:translateX(18px)}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div id="score">0</div>
  <div id="highscore"></div>
  <div id="powerup-indicator"></div>
  <div id="pause-hint">Space to pause</div>
</div>

<div class="overlay" id="menu">
  <h1>NEON SNAKE</h1>
  <h2>Slither through the void</h2>
  <button class="btn" onclick="startGame(false)">PLAY</button>
  <button class="btn" onclick="startGame(true)" style="background:linear-gradient(135deg,#f80,#f0f)">VS AI ðŸ¤–</button>
  <label class="toggle-wrap"><input type="checkbox" id="wrap-toggle" onchange="wrapMode=this.checked"><span class="track"></span>Wrap-around walls</label>
  <label class="toggle-wrap"><input type="checkbox" id="obstacle-toggle" onchange="obstacleMode=this.checked"><span class="track"></span>Obstacles</label>
  <div class="controls-hint">Arrow keys / WASD to move â€¢ Swipe on mobile<br>Collect food â€¢ Avoid walls & yourself<br>Space to pause</div>
</div>

<div class="overlay hidden" id="paused">
  <h2>PAUSED</h2>
  <button class="btn" onclick="resumeGame()">RESUME</button>
  <button class="btn" onclick="showMenu()" style="background:rgba(255,255,255,0.1);color:#fff">QUIT</button>
</div>

<div class="overlay hidden" id="gameover">
  <h2>GAME OVER</h2>
  <div class="final-score" id="final-score">0</div>
  <div class="score-breakdown" id="go-breakdown"></div>
  <div class="sub" id="go-highscore"></div>
  <button class="btn" onclick="startGame()">RETRY</button>
  <button class="btn" onclick="showMenu()" style="background:rgba(255,255,255,0.1);color:#fff">MENU</button>
</div>

<script>
const canvas=document.getElementById('c'),ctx=canvas.getContext('2d');
const scoreEl=document.getElementById('score'),hsEl=document.getElementById('highscore'),puEl=document.getElementById('powerup-indicator');
const menuEl=document.getElementById('menu'),goEl=document.getElementById('gameover'),pauseEl=document.getElementById('paused');

let W,H,CELL,COLS,ROWS;
let snake,dir,nextDir,food,particles,score,highScore,gameLoop,speed,activeEffects;
let shakeX=0,shakeY=0,shakeT=0;
let paused=false,gameActive=false;
let foodEaten=0,powerupsCollected=0,maxLength=3;
let wrapMode=false;
let obstacleMode=false;
let audioCtx;
let bgPulse=0;

// AI opponent
let aiEnabled=false;
let aiSnake=[];
let aiDir={x:-1,y:0};
let aiScore=0;
let aiAlive=true;
let aiActiveEffects={};

// Obstacles
let obstacles=[];
let movingObstacles=[];

// Standalone power-up spawns
let powerupItems=[];
let powerupSpawnTimer=0;
const POWERUP_DEFS=[
  {id:'speed',icon:'âš¡',color:'#f80',glow:'#f80',duration:50,desc:'SPEED BOOST'},
  {id:'ghost',icon:'ðŸ‘»',color:'#0ff',glow:'#0ff',duration:40,desc:'GHOST MODE'},
  {id:'magnet',icon:'ðŸ§²',color:'#ff0',glow:'#ff0',duration:40,desc:'MAGNET'},
];

function initAudio(){if(!audioCtx)audioCtx=new(window.AudioContext||window.webkitAudioContext)()}
function playTone(f,d=0.1,t='sine',v=0.15){
  if(!audioCtx)return;
  const o=audioCtx.createOscillator(),g=audioCtx.createGain();
  o.type=t;o.frequency.value=f;g.gain.setValueAtTime(v,audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+d);
  o.connect(g);g.connect(audioCtx.destination);o.start();o.stop(audioCtx.currentTime+d);
}
function playEat(){
  const base=440+Math.min(foodEaten*15,400);
  playTone(base,0.12,'square',0.08);
  setTimeout(()=>playTone(base*1.25,0.1,'square',0.06),50);
}
function playDie(){
  playTone(200,0.4,'sawtooth',0.2);
  setTimeout(()=>playTone(100,0.5,'sawtooth',0.15),150);
  setTimeout(()=>playTone(60,0.6,'sawtooth',0.1),350);
}
function playPowerup(){playTone(660,0.1,'sine',0.12);setTimeout(()=>playTone(880,0.1,'sine',0.12),80);setTimeout(()=>playTone(1100,0.15,'sine',0.12),160)}
function playMilestone(){playTone(523,0.12,'sine',0.1);setTimeout(()=>playTone(659,0.1,'sine',0.1),80);setTimeout(()=>playTone(784,0.1,'sine',0.1),160);setTimeout(()=>playTone(1047,0.2,'sine',0.12),240)}

function resize(){
  W=canvas.width=window.innerWidth;H=canvas.height=window.innerHeight;
  CELL=Math.floor(Math.min(W,H)/25);
  COLS=Math.floor(W/CELL);ROWS=Math.floor(H/CELL);
}
window.addEventListener('resize',resize);resize();

highScore=parseInt(localStorage.getItem('neonsnake_hs'))||0;
hsEl.textContent=highScore?'BEST: '+highScore:'';

const FOOD_TYPES=[
  {color:'#0f0',glow:'#0f0',points:1,grow:1,name:'apple',emoji:'â—'},
  {color:'#ff0',glow:'#ff0',points:3,grow:2,name:'star',emoji:'â˜…'},
  {color:'#f0f',glow:'#f0f',points:5,grow:3,name:'diamond',emoji:'â—†'},
  {color:'#0ff',glow:'#0ff',points:2,grow:1,name:'power',emoji:'âš¡',powerup:'speed'},
  {color:'#f80',glow:'#f80',points:2,grow:1,name:'ghost',emoji:'ðŸ‘»',powerup:'ghost'},
  {color:'#ff0',glow:'#ff0',points:2,grow:1,name:'magnet',emoji:'ðŸ§²',powerup:'magnet'},
];

function spawnFood(){
  let x,y,attempts=0;
  do{x=Math.floor(Math.random()*COLS);y=Math.floor(Math.random()*ROWS);attempts++}
  while(snake.some(s=>s.x===x&&s.y===y)&&attempts<100);
  let typeIdx=0;
  const r=Math.random();
  if(score>30&&r<0.08)typeIdx=5;
  else if(score>20&&r<0.15)typeIdx=4;
  else if(score>15&&r<0.22)typeIdx=3;
  else if(score>10&&r<0.3)typeIdx=2;
  else if(score>5&&r<0.45)typeIdx=1;
  food={x,y,...FOOD_TYPES[typeIdx],pulse:0,spawnTime:Date.now()};
}

function addParticles(x,y,color,count=12){
  for(let i=0;i<count;i++){
    const a=Math.random()*Math.PI*2,sp=1+Math.random()*3;
    particles.push({x:x*CELL+CELL/2,y:y*CELL+CELL/2,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:1,color,size:2+Math.random()*3});
  }
}

function addScorePopup(x,y,text,color){
  particles.push({x:x*CELL+CELL/2,y:y*CELL+CELL/2,vx:0,vy:-1.5,life:1,color,size:0,text});
}

function shake(intensity=4){shakeT=10;shakeX=(Math.random()-0.5)*intensity;shakeY=(Math.random()-0.5)*intensity}

function startGame(withAI){
  initAudio();
  aiEnabled=!!withAI;
  menuEl.classList.add('hidden');goEl.classList.add('hidden');pauseEl.classList.add('hidden');
  resize();
  const cx=Math.floor(COLS/2),cy=Math.floor(ROWS/2);
  snake=[{x:cx,y:cy},{x:cx-1,y:cy},{x:cx-2,y:cy}];
  dir={x:1,y:0};nextDir={x:1,y:0};
  score=0;speed=120;particles=[];activeEffects={};
  foodEaten=0;powerupsCollected=0;maxLength=3;
  paused=false;gameActive=true;
  powerupItems=[];powerupSpawnTimer=0;
  scoreEl.textContent='0';

  // AI setup
  if(aiEnabled){
    const ax=Math.floor(COLS/2),ay=Math.floor(ROWS/2)-4;
    aiSnake=[{x:ax,y:ay},{x:ax+1,y:ay},{x:ax+2,y:ay}];
    aiDir={x:-1,y:0};aiScore=0;aiAlive=true;aiActiveEffects={};
  }else{
    aiSnake=[];aiAlive=false;
  }

  // Obstacles
  obstacles=[];movingObstacles=[];
  if(obstacleMode){
    // Static walls
    for(let i=0;i<4+Math.floor(Math.random()*3);i++){
      const ox=3+Math.floor(Math.random()*(COLS-6));
      const oy=3+Math.floor(Math.random()*(ROWS-6));
      const horizontal=Math.random()>0.5;
      const len=2+Math.floor(Math.random()*3);
      for(let j=0;j<len;j++){
        const wx=horizontal?ox+j:ox;
        const wy=horizontal?oy:oy+j;
        if(!snake.some(s=>s.x===wx&&s.y===wy)){
          obstacles.push({x:wx,y:wy});
        }
      }
    }
    // Moving barriers
    for(let i=0;i<2;i++){
      movingObstacles.push({
        x:Math.floor(Math.random()*COLS),
        y:4+Math.floor(Math.random()*(ROWS-8)),
        dx:Math.random()>0.5?1:-1,dy:0,
        timer:0,interval:3+Math.floor(Math.random()*4)
      });
    }
  }

  spawnFood();
  if(gameLoop)clearInterval(gameLoop);
  gameLoop=setInterval(tick,speed);
}

function showMenu(){
  if(gameLoop){clearInterval(gameLoop);gameLoop=null}
  gameActive=false;paused=false;
  goEl.classList.add('hidden');pauseEl.classList.add('hidden');
  menuEl.classList.remove('hidden');
}

function pauseGame(){
  if(!gameActive||!gameLoop)return;
  paused=true;clearInterval(gameLoop);gameLoop=null;
  pauseEl.classList.remove('hidden');
}
function resumeGame(){
  if(!gameActive)return;
  paused=false;pauseEl.classList.add('hidden');
  gameLoop=setInterval(tick,speed);
}

function isBlocked(x,y,ignoreGhost){
  if(x<0||x>=COLS||y<0||y>=ROWS)return!wrapMode;
  if(obstacles.some(o=>o.x===x&&o.y===y))return true;
  if(movingObstacles.some(o=>o.x===x&&o.y===y))return true;
  return false;
}

function tick(){
  dir={...nextDir};
  const head={x:snake[0].x+dir.x,y:snake[0].y+dir.y};

  if(activeEffects.ghost||wrapMode){
    head.x=(head.x+COLS)%COLS;head.y=(head.y+ROWS)%ROWS;
  }else if(head.x<0||head.x>=COLS||head.y<0||head.y>=ROWS){
    die();return;
  }

  if(!activeEffects.ghost&&snake.some(s=>s.x===head.x&&s.y===head.y)){
    die();return;
  }

  // Obstacle collision
  if(!activeEffects.ghost&&isBlocked(head.x,head.y)){
    die();return;
  }

  // AI snake collision
  if(!activeEffects.ghost&&aiAlive&&aiSnake.some(s=>s.x===head.x&&s.y===head.y)){
    die();return;
  }

  snake.unshift(head);

  if(activeEffects.magnet&&food){
    const dx=head.x-food.x,dy=head.y-food.y;
    if(Math.abs(dx)<=4&&Math.abs(dy)<=4){
      food.x+=Math.sign(dx);food.y+=Math.sign(dy);
    }
  }

  if(food&&head.x===food.x&&head.y===food.y){
    score+=food.points;foodEaten++;
    scoreEl.textContent=score;
    scoreEl.classList.add('bump');setTimeout(()=>scoreEl.classList.remove('bump'),100);
    addParticles(food.x,food.y,food.color,20);
    addScorePopup(food.x,food.y,'+'+food.points,food.color);
    shake(3);playEat();bgPulse=1;
    for(let i=1;i<food.grow;i++)snake.push({...snake[snake.length-1]});
    maxLength=Math.max(maxLength,snake.length);
    if(food.powerup){
      activeEffects[food.powerup]=40;
      powerupsCollected++;
      playPowerup();
    }
    if(score%25===0&&score>0)playMilestone();
    if(foodEaten%5===0&&speed>55){
      speed-=3;clearInterval(gameLoop);gameLoop=setInterval(tick,speed);
    }
    spawnFood();
  }else{
    snake.pop();
  }

  // Power-up item collection
  for(let i=powerupItems.length-1;i>=0;i--){
    const pu=powerupItems[i];
    pu.life--;
    if(pu.life<=0){powerupItems.splice(i,1);continue}
    if(head.x===pu.x&&head.y===pu.y){
      activeEffects[pu.id]=pu.duration;
      powerupsCollected++;
      playPowerup();
      addParticles(pu.x,pu.y,pu.color,15);
      addScorePopup(pu.x,pu.y,pu.desc,pu.color);
      powerupItems.splice(i,1);
    }
  }

  // Spawn power-ups periodically
  powerupSpawnTimer++;
  if(powerupSpawnTimer>=80&&powerupItems.length<2){
    powerupSpawnTimer=0;
    if(Math.random()<0.4){
      const def=POWERUP_DEFS[Math.floor(Math.random()*POWERUP_DEFS.length)];
      let px,py,ok=false;
      for(let a=0;a<50;a++){
        px=Math.floor(Math.random()*COLS);py=Math.floor(Math.random()*ROWS);
        if(!snake.some(s=>s.x===px&&s.y===py)&&!obstacles.some(o=>o.x===px&&o.y===py)){ok=true;break}
      }
      if(ok)powerupItems.push({...def,x:px,y:py,life:120,pulse:0});
    }
  }

  // Moving obstacles
  for(const mo of movingObstacles){
    mo.timer++;
    if(mo.timer>=mo.interval){
      mo.timer=0;
      mo.x+=mo.dx;mo.y+=mo.dy;
      if(mo.x<=0||mo.x>=COLS-1)mo.dx*=-1;
      if(mo.y<=0||mo.y>=ROWS-1)mo.dy*=-1;
      // Kill player if moved into
      if(!activeEffects.ghost&&head.x===mo.x&&head.y===mo.y){die();return}
    }
  }

  for(const k in activeEffects){
    activeEffects[k]--;
    if(activeEffects[k]<=0)delete activeEffects[k];
  }

  if(Math.random()<0.5)addParticles(head.x,head.y,activeEffects.ghost?'rgba(0,255,255,0.3)':activeEffects.speed?'#f80':'#0ff',1);

  // AI snake tick
  if(aiEnabled&&aiAlive)tickAI();
}

function tickAI(){
  // Simple AI: move toward food, avoid walls/self/player
  const head=aiSnake[0];
  let bestDir=aiDir;
  let bestDist=Infinity;

  const target=food||{x:Math.floor(COLS/2),y:Math.floor(ROWS/2)};
  const dirs=[{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];

  // Don't reverse
  const validDirs=dirs.filter(d=>!(d.x===-aiDir.x&&d.y===-aiDir.y));

  for(const d of validDirs){
    const nx=(head.x+d.x+COLS)%COLS,ny=(head.y+d.y+ROWS)%ROWS;
    // Check safe
    const blocked=aiSnake.some(s=>s.x===nx&&s.y===ny)||
      snake.some(s=>s.x===nx&&s.y===ny)||
      obstacles.some(o=>o.x===nx&&o.y===ny)||
      (!wrapMode&&(nx<0||nx>=COLS||ny<0||ny>=ROWS));
    if(blocked)continue;
    const dist=Math.abs(nx-target.x)+Math.abs(ny-target.y);
    // Add randomness to make AI imperfect
    const jitter=Math.random()*3;
    if(dist+jitter<bestDist){bestDist=dist+jitter;bestDir=d}
  }

  aiDir=bestDir;
  const newHead={x:head.x+aiDir.x,y:head.y+aiDir.y};
  if(wrapMode){newHead.x=(newHead.x+COLS)%COLS;newHead.y=(newHead.y+ROWS)%ROWS}

  // AI death check
  if(newHead.x<0||newHead.x>=COLS||newHead.y<0||newHead.y>=ROWS||
    aiSnake.some(s=>s.x===newHead.x&&s.y===newHead.y)||
    snake.some(s=>s.x===newHead.x&&s.y===newHead.y)||
    obstacles.some(o=>o.x===newHead.x&&o.y===newHead.y)){
    aiAlive=false;
    aiSnake.forEach((s,i)=>setTimeout(()=>addParticles(s.x,s.y,'#f80',3),i*15));
    return;
  }

  aiSnake.unshift(newHead);

  // AI eats food
  if(food&&newHead.x===food.x&&newHead.y===food.y){
    aiScore+=food.points;
    addParticles(food.x,food.y,'#f80',10);
    for(let i=1;i<food.grow;i++)aiSnake.push({...aiSnake[aiSnake.length-1]});
    spawnFood();
  }else{
    aiSnake.pop();
  }

  // AI collects power-ups
  for(let i=powerupItems.length-1;i>=0;i--){
    const pu=powerupItems[i];
    if(newHead.x===pu.x&&newHead.y===pu.y){
      aiActiveEffects[pu.id]=pu.duration;
      addParticles(pu.x,pu.y,pu.color,10);
      powerupItems.splice(i,1);
    }
  }

  for(const k in aiActiveEffects){aiActiveEffects[k]--;if(aiActiveEffects[k]<=0)delete aiActiveEffects[k]}
  if(Math.random()<0.3)addParticles(newHead.x,newHead.y,'rgba(255,136,0,0.3)',1);
}

function die(){
  clearInterval(gameLoop);gameLoop=null;gameActive=false;
  playDie();shake(10);
  snake.forEach((s,i)=>setTimeout(()=>addParticles(s.x,s.y,'#f00',4),i*20));
  if(score>highScore){highScore=score;localStorage.setItem('neonsnake_hs',highScore);hsEl.textContent='BEST: '+highScore}
  setTimeout(()=>{
    document.getElementById('final-score').textContent=score;
    let breakdown=`ðŸŽ ${foodEaten} eaten â€¢ ðŸ Length ${maxLength} â€¢ âš¡ ${powerupsCollected} powerups`;
    if(aiEnabled){
      const won=score>aiScore;
      const tied=score===aiScore;
      breakdown+=`\nðŸ¤– AI Score: ${aiScore}`;
      document.getElementById('go-highscore').textContent=tied?'ðŸ¤ TIE GAME!':won?'ðŸ† YOU WIN!':'ðŸ’€ AI WINS!';
    }else{
      document.getElementById('go-highscore').textContent=score>0&&score>=highScore?'ðŸŽ‰ NEW HIGH SCORE!':'Best: '+highScore;
    }
    document.getElementById('go-breakdown').textContent=breakdown;
    // Update retry button to remember AI mode
    const retryBtn=goEl.querySelector('.btn');
    retryBtn.setAttribute('onclick',`startGame(${aiEnabled})`);
    goEl.classList.remove('hidden');
  },800);
}

// Controls
let touchStart=null;
document.addEventListener('touchstart',e=>{e.preventDefault();touchStart={x:e.touches[0].clientX,y:e.touches[0].clientY}},{passive:false});
document.addEventListener('touchmove',e=>e.preventDefault(),{passive:false});
document.addEventListener('touchend',e=>{
  if(!touchStart||!gameLoop)return;
  const dx=e.changedTouches[0].clientX-touchStart.x,dy=e.changedTouches[0].clientY-touchStart.y;
  if(Math.abs(dx)<10&&Math.abs(dy)<10)return;
  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>0&&dir.x!==(-1))nextDir={x:1,y:0};
    else if(dx<0&&dir.x!==1)nextDir={x:-1,y:0};
  }else{
    if(dy>0&&dir.y!==(-1))nextDir={x:0,y:1};
    else if(dy<0&&dir.y!==1)nextDir={x:0,y:-1};
  }
  touchStart=null;
});

document.addEventListener('keydown',e=>{
  if(e.key===' '||e.key==='Escape'){
    e.preventDefault();
    if(paused)resumeGame();
    else if(gameActive&&gameLoop)pauseGame();
    return;
  }
  if(!gameLoop||paused)return;
  const k=e.key.toLowerCase();
  if((k==='arrowup'||k==='w')&&dir.y!==1)nextDir={x:0,y:-1};
  if((k==='arrowdown'||k==='s')&&dir.y!==(-1))nextDir={x:0,y:1};
  if((k==='arrowleft'||k==='a')&&dir.x!==1)nextDir={x:-1,y:0};
  if((k==='arrowright'||k==='d')&&dir.x!==(-1))nextDir={x:1,y:0};
});

// Render
function draw(){
  requestAnimationFrame(draw);
  ctx.save();
  if(shakeT>0){ctx.translate(shakeX,shakeY);shakeT--;shakeX*=0.85;shakeY*=0.85}
  
  // Clear with trail + bg pulse
  const bgAlpha=0.25+bgPulse*0.15;
  bgPulse*=0.92;
  ctx.fillStyle=`rgba(10,10,26,${bgAlpha})`;ctx.fillRect(0,0,W,H);
  
  // Subtle grid
  ctx.strokeStyle='rgba(255,255,255,0.015)';ctx.lineWidth=0.5;
  for(let x=0;x<COLS;x++){ctx.beginPath();ctx.moveTo(x*CELL,0);ctx.lineTo(x*CELL,H);ctx.stroke()}
  for(let y=0;y<ROWS;y++){ctx.beginPath();ctx.moveTo(0,y*CELL);ctx.lineTo(W,y*CELL);ctx.stroke()}
  
  // Wall danger glow when snake is near edge (no ghost)
  if(snake&&!activeEffects.ghost&&!wrapMode){
    const h=snake[0];
    if(h.x<=1||h.x>=COLS-2||h.y<=1||h.y>=ROWS-2){
      ctx.fillStyle='rgba(233,69,96,0.03)';ctx.fillRect(0,0,W,H);
    }
  }
  
  // Obstacles
  for(const o of obstacles){
    ctx.fillStyle='rgba(233,69,96,0.8)';
    ctx.shadowBlur=12;ctx.shadowColor='#e94560';
    ctx.beginPath();ctx.roundRect(o.x*CELL+1,o.y*CELL+1,CELL-2,CELL-2,3);ctx.fill();
    ctx.shadowBlur=0;
  }
  for(const mo of movingObstacles){
    const pulse=0.6+Math.sin(Date.now()*0.005)*0.3;
    ctx.fillStyle=`rgba(255,100,50,${pulse})`;
    ctx.shadowBlur=16;ctx.shadowColor='#f64';
    ctx.beginPath();ctx.roundRect(mo.x*CELL,mo.y*CELL,CELL,CELL,4);ctx.fill();
    ctx.shadowBlur=0;
  }

  // Power-up items
  for(const pu of powerupItems){
    pu.pulse=(pu.pulse+0.08)%(Math.PI*2);
    const s=1+Math.sin(pu.pulse)*0.25;
    const px=pu.x*CELL+CELL/2,py=pu.y*CELL+CELL/2;
    const fadeAlpha=pu.life<30?pu.life/30:1;
    ctx.save();ctx.globalAlpha=fadeAlpha;
    ctx.translate(px,py);ctx.scale(s,s);
    ctx.shadowBlur=20;ctx.shadowColor=pu.glow;
    ctx.fillStyle=pu.color;
    ctx.beginPath();ctx.arc(0,0,CELL/2.2,0,Math.PI*2);ctx.fill();
    ctx.shadowBlur=0;
    ctx.fillStyle='#fff';ctx.font=`${CELL*0.55}px sans-serif`;ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(pu.icon,0,1);
    ctx.restore();
  }

  // Food
  if(food){
    food.pulse=(food.pulse+0.06)%(Math.PI*2);
    const s=1+Math.sin(food.pulse)*0.2;
    const fx=food.x*CELL+CELL/2,fy=food.y*CELL+CELL/2;
    // Food glow ring
    const age=Math.min(1,(Date.now()-food.spawnTime)/300);
    ctx.save();ctx.translate(fx,fy);ctx.scale(s*age,s*age);
    ctx.shadowBlur=25;ctx.shadowColor=food.glow;
    ctx.fillStyle=food.color;
    ctx.beginPath();ctx.arc(0,0,CELL/2.5,0,Math.PI*2);ctx.fill();
    ctx.shadowBlur=0;
    ctx.fillStyle='#fff';ctx.font=`${CELL*0.5}px sans-serif`;ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(food.emoji,0,1);
    ctx.restore();
  }
  
  // Snake
  if(snake){
    snake.forEach((s,i)=>{
      const t=i/snake.length;
      const alpha=activeEffects.ghost?0.4:1;
      let hue=180+t*120;
      if(activeEffects.speed)hue=30+t*30;
      if(activeEffects.magnet)hue=60+t*40;
      ctx.fillStyle=`hsla(${hue},100%,60%,${alpha})`;
      ctx.shadowBlur=i===0?18:8;
      ctx.shadowColor=`hsla(${hue},100%,60%,0.8)`;
      const pad=i===0?1:2;
      const r=i===0?CELL/3:CELL/4;
      // Smooth body wiggle
      const wiggle=Math.sin(Date.now()*0.008+i*0.5)*0.5;
      ctx.beginPath();
      ctx.roundRect(s.x*CELL+pad+wiggle,s.y*CELL+pad,CELL-pad*2,CELL-pad*2,r);
      ctx.fill();
      ctx.shadowBlur=0;
    });
    // Eyes
    if(snake.length>0){
      const h=snake[0];
      ctx.fillStyle='#fff';
      const ex=h.x*CELL+CELL/2,ey=h.y*CELL+CELL/2;
      const ed=CELL*0.15;
      ctx.beginPath();ctx.arc(ex+dir.x*ed-dir.y*ed*0.6,ey+dir.y*ed-dir.x*ed*0.6,2.5,0,Math.PI*2);ctx.fill();
      ctx.beginPath();ctx.arc(ex+dir.x*ed+dir.y*ed*0.6,ey+dir.y*ed+dir.x*ed*0.6,2.5,0,Math.PI*2);ctx.fill();
      // Pupils
      ctx.fillStyle='#000';
      ctx.beginPath();ctx.arc(ex+dir.x*ed*1.3-dir.y*ed*0.6,ey+dir.y*ed*1.3-dir.x*ed*0.6,1.2,0,Math.PI*2);ctx.fill();
      ctx.beginPath();ctx.arc(ex+dir.x*ed*1.3+dir.y*ed*0.6,ey+dir.y*ed*1.3+dir.x*ed*0.6,1.2,0,Math.PI*2);ctx.fill();
    }
  }
  
  // AI snake
  if(aiEnabled&&aiAlive&&aiSnake.length>0){
    aiSnake.forEach((s,i)=>{
      const t=i/aiSnake.length;
      const hue=25+t*25;
      ctx.fillStyle=`hsla(${hue},100%,55%,0.9)`;
      ctx.shadowBlur=i===0?16:6;
      ctx.shadowColor=`hsla(${hue},100%,55%,0.7)`;
      const pad=i===0?1:2;
      const r=i===0?CELL/3:CELL/4;
      const wiggle=Math.sin(Date.now()*0.008+i*0.5)*0.5;
      ctx.beginPath();
      ctx.roundRect(s.x*CELL+pad+wiggle,s.y*CELL+pad,CELL-pad*2,CELL-pad*2,r);
      ctx.fill();
      ctx.shadowBlur=0;
    });
    // AI eyes
    const ah=aiSnake[0];
    ctx.fillStyle='#fff';
    const aex=ah.x*CELL+CELL/2,aey=ah.y*CELL+CELL/2;
    const aed=CELL*0.15;
    ctx.beginPath();ctx.arc(aex+aiDir.x*aed-aiDir.y*aed*0.6,aey+aiDir.y*aed-aiDir.x*aed*0.6,2.5,0,Math.PI*2);ctx.fill();
    ctx.beginPath();ctx.arc(aex+aiDir.x*aed+aiDir.y*aed*0.6,aey+aiDir.y*aed+aiDir.x*aed*0.6,2.5,0,Math.PI*2);ctx.fill();
    ctx.fillStyle='#200';
    ctx.beginPath();ctx.arc(aex+aiDir.x*aed*1.3-aiDir.y*aed*0.6,aey+aiDir.y*aed*1.3-aiDir.x*aed*0.6,1.2,0,Math.PI*2);ctx.fill();
    ctx.beginPath();ctx.arc(aex+aiDir.x*aed*1.3+aiDir.y*aed*0.6,aey+aiDir.y*aed*1.3+aiDir.x*aed*0.6,1.2,0,Math.PI*2);ctx.fill();
  }

  // AI score display
  if(aiEnabled){
    ctx.fillStyle='#f80';ctx.font='bold 16px sans-serif';ctx.textAlign='right';
    ctx.shadowBlur=8;ctx.shadowColor='#f80';
    ctx.fillText('ðŸ¤– '+aiScore,W-16,48);
    ctx.shadowBlur=0;
    if(!aiAlive){
      ctx.fillStyle='rgba(255,136,0,0.5)';ctx.font='11px sans-serif';
      ctx.fillText('ELIMINATED',W-16,64);
    }
  }

  // Particles + score popups
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx;p.y+=p.vy;p.vx*=0.96;p.vy*=0.96;p.life-=0.025;
    if(p.life<=0){particles.splice(i,1);continue}
    ctx.globalAlpha=p.life;
    if(p.text){
      ctx.fillStyle=p.color;ctx.font='bold 14px sans-serif';ctx.textAlign='center';
      ctx.fillText(p.text,p.x,p.y);
    }else{
      ctx.fillStyle=p.color;
      ctx.shadowBlur=6;ctx.shadowColor=p.color;
      ctx.beginPath();ctx.arc(p.x,p.y,p.size*p.life,0,Math.PI*2);ctx.fill();
      ctx.shadowBlur=0;
    }
    ctx.globalAlpha=1;
  }
  
  // Power-up indicator with timer bars
  const puTexts=[];
  if(activeEffects.ghost)puTexts.push('ðŸ‘» GHOST');
  if(activeEffects.speed)puTexts.push('âš¡ SPEED');
  if(activeEffects.magnet)puTexts.push('ðŸ§² MAGNET');
  puEl.textContent=puTexts.join('  ');
  
  ctx.restore();
}
draw();
</script>
</body>
</html>
