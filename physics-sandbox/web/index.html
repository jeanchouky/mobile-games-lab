<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#0a0a1a">
<title>Physics Sandbox</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;touch-action:none;user-select:none;-webkit-user-select:none;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',system-ui,sans-serif;color:#fff}

canvas{display:block;position:absolute;top:0;left:0}
#ui{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}

/* Splash */
#splash{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(10,10,26,0.95);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100;pointer-events:auto;transition:opacity 0.5s}
#splash.hidden{opacity:0;pointer-events:none}
#splash h1{font-size:clamp(2rem,8vw,3.5rem);font-weight:900;background:linear-gradient(135deg,#ff6644,#ffcc00,#00ff88);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:8px}
#splash h2{color:#888;font-size:clamp(0.8rem,3vw,1rem);font-weight:400;margin-bottom:24px}
#splash .start-btn{background:linear-gradient(135deg,#ff6644,#ffcc00);border:none;color:#000;font-weight:900;font-size:1.1rem;padding:14px 40px;border-radius:50px;cursor:pointer;text-transform:uppercase;letter-spacing:2px}
#splash .hint{color:#555;font-size:0.7rem;margin-top:16px;text-align:center;line-height:1.6}

/* Toolbar */
#toolbar{position:absolute;top:8px;left:8px;right:8px;display:flex;gap:4px;pointer-events:auto;flex-wrap:wrap;align-items:center}
.tbtn{background:rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.15);color:#fff;font-size:0.65rem;padding:6px 10px;border-radius:14px;cursor:pointer;font-weight:600;transition:all 0.2s;backdrop-filter:blur(8px);white-space:nowrap;display:flex;align-items:center;gap:4px}
.tbtn:hover{background:rgba(255,255,255,0.12)}
.tbtn:active{transform:scale(0.95)}
.tbtn.active{border-color:#0ff;color:#0ff;box-shadow:0 0 8px rgba(0,255,255,0.3)}
.tbtn .icon{font-size:0.9rem}
.separator{width:1px;height:20px;background:rgba(255,255,255,0.1);margin:0 2px;flex-shrink:0}

/* Side panel */
#side-panel{position:absolute;right:8px;top:52px;pointer-events:auto;display:flex;flex-direction:column;gap:6px;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.1);border-radius:12px;padding:10px;backdrop-filter:blur(8px);width:150px}
#side-panel.hidden{display:none}
.slider-row{display:flex;flex-direction:column;gap:2px}
.slider-row label{font-size:0.6rem;color:#888;display:flex;justify-content:space-between}
.slider-row label span{color:#0ff}
.slider-row input{width:100%;accent-color:#0ff}
.panel-title{font-size:0.7rem;font-weight:700;color:#fff;border-bottom:1px solid rgba(255,255,255,0.1);padding-bottom:4px;margin-bottom:2px}

/* Material indicator */
#material-info{position:absolute;bottom:12px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.15);color:#fff;font-size:0.7rem;padding:6px 16px;border-radius:20px;pointer-events:none;backdrop-filter:blur(8px);text-align:center}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div id="toolbar"></div>
  <div id="side-panel" class="hidden">
    <div class="panel-title">Gravity</div>
    <div class="slider-row">
      <label>X: <span id="gx-val">0</span></label>
      <input type="range" id="gravity-x" min="-2" max="2" value="0" step="0.1">
    </div>
    <div class="slider-row">
      <label>Y: <span id="gy-val">1</span></label>
      <input type="range" id="gravity-y" min="-2" max="2" value="1" step="0.1">
    </div>
    <div class="panel-title" style="margin-top:6px">Spawn Size</div>
    <div class="slider-row">
      <label>Size: <span id="size-val">30</span></label>
      <input type="range" id="spawn-size" min="10" max="80" value="30" step="5">
    </div>
  </div>
  <div id="material-info"></div>
</div>

<div id="splash">
  <h1>PHYSICS SANDBOX</h1>
  <h2>Play with physics!</h2>
  <button class="start-btn" id="start-btn">PLAY</button>
  <div class="hint">Select a shape &bull; Tap to spawn &bull; Drag to throw<br>Try different materials &bull; Adjust gravity</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
'use strict';

// ============================================================
// PHYSICS SANDBOX — Matter.js Playground
// ============================================================

const { Engine, Render, Runner, Bodies, Body, Composite, Mouse, MouseConstraint, Events, Vector, Vertices, Common } = Matter;

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const toolbar = document.getElementById('toolbar');
const sidePanel = document.getElementById('side-panel');
const materialInfo = document.getElementById('material-info');
const splash = document.getElementById('splash');

let W, H;

// --- Engine setup ---
const engine = Engine.create();
engine.gravity.y = 1;
engine.gravity.x = 0;

// --- State ---
let currentTool = 'circle'; // circle, rect, triangle, polygon, platform, draw, drag
let currentMaterial = 'normal'; // normal, bouncy, heavy, fragile, ice
let spawnSize = 30;
let paused = false;
let showPanel = false;
let bodies = [];
let trails = [];
let drawingPoints = [];
let isDrawing = false;
let dragStart = null;
let dragPreview = null;
let groundBodies = [];

// Colors for shapes
const shapeColors = [
  '#ff4466','#ff6644','#ffaa22','#ffcc00','#88ff00',
  '#00ff88','#00ffcc','#00ccff','#4488ff','#8844ff',
  '#cc44ff','#ff44cc','#ff4488','#ff6688','#44ffaa',
  '#ffdd44'
];
let colorIndex = 0;
function nextColor() {
  const c = shapeColors[colorIndex % shapeColors.length];
  colorIndex++;
  return c;
}

// Material presets
const materials = {
  normal:  { restitution: 0.3, friction: 0.5, density: 0.001, label: 'Normal' },
  bouncy:  { restitution: 0.95, friction: 0.1, density: 0.0005, label: 'Bouncy' },
  heavy:   { restitution: 0.1, friction: 0.8, density: 0.005, label: 'Heavy' },
  fragile: { restitution: 0.05, friction: 0.3, density: 0.0003, label: 'Fragile' },
  ice:     { restitution: 0.2, friction: 0.01, density: 0.001, label: 'Ice' },
};

function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  const dpr = Math.min(window.devicePixelRatio, 2);
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // Rebuild walls
  rebuildWalls();
}

function rebuildWalls() {
  groundBodies.forEach(b => Composite.remove(engine.world, b));
  groundBodies = [];

  const thickness = 60;
  const opts = { isStatic: true, render: { visible: false }, friction: 0.5, restitution: 0.3 };
  const ground = Bodies.rectangle(W/2, H + thickness/2, W + 200, thickness, opts);
  const wallL = Bodies.rectangle(-thickness/2, H/2, thickness, H + 200, opts);
  const wallR = Bodies.rectangle(W + thickness/2, H/2, thickness, H + 200, opts);

  groundBodies = [ground, wallL, wallR];
  Composite.add(engine.world, groundBodies);
}

window.addEventListener('resize', resize);
resize();

// --- Toolbar ---
function buildToolbar() {
  const items = [
    { id: 'circle', icon: '\u25cf', label: 'Circle', tool: true },
    { id: 'rect', icon: '\u25a0', label: 'Rect', tool: true },
    { id: 'triangle', icon: '\u25b2', label: 'Tri', tool: true },
    { id: 'polygon', icon: '\u2b23', label: 'Poly', tool: true },
    { id: 'platform', icon: '\u2501', label: 'Platform', tool: true },
    { id: 'draw', icon: '\u270e', label: 'Draw', tool: true },
    { id: 'drag', icon: '\u21c5', label: 'Drag', tool: true },
    { type: 'sep' },
    { id: 'mat-normal', label: 'Normal', mat: 'normal' },
    { id: 'mat-bouncy', label: 'Bouncy', mat: 'bouncy' },
    { id: 'mat-heavy', label: 'Heavy', mat: 'heavy' },
    { id: 'mat-fragile', label: 'Fragile', mat: 'fragile' },
    { id: 'mat-ice', label: 'Ice', mat: 'ice' },
    { type: 'sep' },
    { id: 'settings', icon: '\u2699', label: 'Settings', action: togglePanel },
    { id: 'pause', icon: '\u23f8', label: 'Pause', action: togglePause },
    { id: 'clear', icon: '\u2715', label: 'Clear', action: clearAll },
  ];

  toolbar.innerHTML = '';
  items.forEach(item => {
    if (item.type === 'sep') {
      const sep = document.createElement('div');
      sep.className = 'separator';
      toolbar.appendChild(sep);
      return;
    }
    const btn = document.createElement('button');
    btn.className = 'tbtn';
    btn.id = 'tbtn-' + item.id;
    btn.innerHTML = (item.icon ? `<span class="icon">${item.icon}</span>` : '') + item.label;
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      if (item.tool) {
        currentTool = item.id;
        updateToolbar();
      } else if (item.mat) {
        currentMaterial = item.mat;
        updateToolbar();
      } else if (item.action) {
        item.action();
      }
    });
    toolbar.appendChild(btn);
  });
  updateToolbar();
}

function updateToolbar() {
  document.querySelectorAll('.tbtn').forEach(btn => {
    const id = btn.id.replace('tbtn-', '');
    const isToolActive = id === currentTool;
    const isMatActive = id === 'mat-' + currentMaterial;
    const isPauseActive = id === 'pause' && paused;
    const isSettingsActive = id === 'settings' && showPanel;
    btn.classList.toggle('active', isToolActive || isMatActive || isPauseActive || isSettingsActive);
  });
  materialInfo.textContent = `${materials[currentMaterial].label} material \u2022 ${currentTool === 'draw' ? 'Draw mode' : currentTool === 'drag' ? 'Drag mode' : currentTool + ' tool'}`;
}

function togglePanel() {
  showPanel = !showPanel;
  sidePanel.classList.toggle('hidden', !showPanel);
  updateToolbar();
}

function togglePause() {
  paused = !paused;
  updateToolbar();
}

function clearAll() {
  const toRemove = Composite.allBodies(engine.world).filter(b => !b.isStatic);
  toRemove.forEach(b => Composite.remove(engine.world, b));
  bodies = [];
  trails = [];
}

// --- Gravity sliders ---
document.getElementById('gravity-x').addEventListener('input', (e) => {
  engine.gravity.x = parseFloat(e.target.value);
  document.getElementById('gx-val').textContent = e.target.value;
});
document.getElementById('gravity-y').addEventListener('input', (e) => {
  engine.gravity.y = parseFloat(e.target.value);
  document.getElementById('gy-val').textContent = e.target.value;
});
document.getElementById('spawn-size').addEventListener('input', (e) => {
  spawnSize = parseInt(e.target.value);
  document.getElementById('size-val').textContent = e.target.value;
});

// --- Spawn shapes ---
function spawnShape(x, y, vx, vy) {
  const mat = materials[currentMaterial];
  const color = nextColor();
  const opts = {
    restitution: mat.restitution,
    friction: mat.friction,
    density: mat.density,
    _color: color,
    _material: currentMaterial,
    _born: Date.now(),
  };
  let body;
  const s = spawnSize;

  switch (currentTool) {
    case 'circle':
      body = Bodies.circle(x, y, s, opts);
      break;
    case 'rect':
      body = Bodies.rectangle(x, y, s * 2, s * 1.4, opts);
      break;
    case 'triangle':
      body = Bodies.polygon(x, y, 3, s, opts);
      break;
    case 'polygon':
      const sides = 5 + Math.floor(Math.random() * 4);
      body = Bodies.polygon(x, y, sides, s, opts);
      break;
    case 'platform':
      body = Bodies.rectangle(x, y, s * 4, 12, { ...opts, isStatic: true });
      break;
    default: return;
  }

  if (vx || vy) Body.setVelocity(body, { x: vx * 0.1, y: vy * 0.1 });

  Composite.add(engine.world, body);
  bodies.push(body);

  // Limit body count for performance
  if (bodies.length > 200) {
    const old = bodies.shift();
    Composite.remove(engine.world, old);
  }
}

function spawnDrawnShape(points) {
  if (points.length < 3) return;
  // Simplify points
  const simplified = [];
  for (let i = 0; i < points.length; i += 3) {
    simplified.push(points[i]);
  }
  if (simplified.length < 3) return;

  // Get centroid
  let cx = 0, cy = 0;
  simplified.forEach(p => { cx += p.x; cy += p.y; });
  cx /= simplified.length;
  cy /= simplified.length;

  // Make vertices relative to centroid
  const verts = simplified.map(p => ({ x: p.x - cx, y: p.y - cy }));

  try {
    // Ensure clockwise winding
    const mat = materials[currentMaterial];
    const body = Bodies.fromVertices(cx, cy, verts, {
      restitution: mat.restitution,
      friction: mat.friction,
      density: mat.density,
      _color: nextColor(),
      _material: currentMaterial,
      _born: Date.now(),
    });
    if (body) {
      Composite.add(engine.world, body);
      bodies.push(body);
    }
  } catch(e) {
    // Fallback: create circle at centroid
    spawnShape(cx, cy, 0, 0);
  }
}

// --- Fragile break mechanic ---
Events.on(engine, 'collisionStart', (event) => {
  event.pairs.forEach(pair => {
    [pair.bodyA, pair.bodyB].forEach(body => {
      if (body._material === 'fragile' && !body.isStatic) {
        const speed = Vector.magnitude(body.velocity);
        if (speed > 8) {
          // Break into smaller pieces
          const pos = body.position;
          const size = Math.max(body.circleRadius || 15, 10);
          Composite.remove(engine.world, body);
          bodies = bodies.filter(b => b !== body);

          for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            const ox = Math.cos(angle) * size * 0.4;
            const oy = Math.sin(angle) * size * 0.4;
            const piece = Bodies.circle(pos.x + ox, pos.y + oy, size * 0.3, {
              restitution: 0.2,
              friction: 0.3,
              density: 0.0003,
              _color: body._color,
              _material: 'normal',
              _born: Date.now(),
            });
            Body.setVelocity(piece, {
              x: body.velocity.x * 0.5 + (Math.random() - 0.5) * 5,
              y: body.velocity.y * 0.5 + (Math.random() - 0.5) * 5
            });
            Composite.add(engine.world, piece);
            bodies.push(piece);
          }

          // Particle burst
          for (let i = 0; i < 12; i++) {
            trails.push({
              x: pos.x, y: pos.y,
              vx: (Math.random() - 0.5) * 8,
              vy: (Math.random() - 0.5) * 8,
              life: 1,
              color: body._color,
              size: 3 + Math.random() * 4,
            });
          }
        }
      }
    });
  });
});

// --- Input ---
let pointerDown = false;
let pointerX = 0, pointerY = 0;
let pointerStartX = 0, pointerStartY = 0;
let draggingBody = null;
let mouseConstraint = null;

function getXY(e) {
  if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  return { x: e.clientX, y: e.clientY };
}

function isOverUI(x, y) {
  return y < 50 || (!sidePanel.classList.contains('hidden') && x > W - 170 && y < 300);
}

canvas.addEventListener('mousedown', onDown);
canvas.addEventListener('touchstart', onDown, { passive: false });
canvas.addEventListener('mousemove', onMove);
canvas.addEventListener('touchmove', onMove, { passive: false });
canvas.addEventListener('mouseup', onUp);
canvas.addEventListener('touchend', onUp, { passive: false });
canvas.addEventListener('touchcancel', onUp, { passive: false });

function onDown(e) {
  e.preventDefault();
  const p = getXY(e);
  if (isOverUI(p.x, p.y)) return;
  pointerDown = true;
  pointerStartX = p.x;
  pointerStartY = p.y;
  pointerX = p.x;
  pointerY = p.y;

  if (currentTool === 'draw') {
    isDrawing = true;
    drawingPoints = [{ x: p.x, y: p.y }];
  } else if (currentTool === 'drag') {
    // Find body under cursor
    const allBodies = Composite.allBodies(engine.world);
    for (let i = allBodies.length - 1; i >= 0; i--) {
      const body = allBodies[i];
      if (body.isStatic) continue;
      if (Matter.Bounds.contains(body.bounds, { x: p.x, y: p.y })) {
        if (Matter.Vertices.contains(body.vertices, { x: p.x, y: p.y })) {
          draggingBody = body;
          break;
        }
      }
    }
  }
}

function onMove(e) {
  e.preventDefault();
  if (!pointerDown) return;
  const p = getXY(e);
  pointerX = p.x;
  pointerY = p.y;

  if (currentTool === 'draw' && isDrawing) {
    drawingPoints.push({ x: p.x, y: p.y });
  } else if (currentTool === 'drag' && draggingBody) {
    Body.setPosition(draggingBody, { x: p.x, y: p.y });
    Body.setVelocity(draggingBody, { x: 0, y: 0 });
  }
}

function onUp(e) {
  e.preventDefault();
  if (!pointerDown) return;

  if (currentTool === 'draw' && isDrawing) {
    spawnDrawnShape(drawingPoints);
    drawingPoints = [];
    isDrawing = false;
  } else if (currentTool === 'drag') {
    if (draggingBody) {
      // Give velocity based on movement
      const vx = (pointerX - pointerStartX) * 0.05;
      const vy = (pointerY - pointerStartY) * 0.05;
      Body.setVelocity(draggingBody, { x: vx, y: vy });
      draggingBody = null;
    }
  } else if (currentTool !== 'drag') {
    const dx = pointerX - pointerStartX;
    const dy = pointerY - pointerStartY;
    spawnShape(pointerStartX, pointerStartY, dx, dy);
  }

  pointerDown = false;
}

// --- Rendering ---
function hexToRgb(hex) {
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return { r, g, b };
}

function renderScene() {
  ctx.clearRect(0, 0, W, H);

  // Background grid
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 1;
  const gridSize = 40;
  for (let x = 0; x < W; x += gridSize) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
  }
  for (let y = 0; y < H; y += gridSize) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
  }

  // Trail particles
  trails.forEach((t, i) => {
    t.x += t.vx;
    t.y += t.vy;
    t.vy += 0.1;
    t.life -= 0.02;
    if (t.life <= 0) { trails.splice(i, 1); return; }
    ctx.globalAlpha = t.life;
    ctx.fillStyle = t.color;
    ctx.beginPath();
    ctx.arc(t.x, t.y, t.size * t.life, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Draw all bodies
  const allBodies = Composite.allBodies(engine.world);
  allBodies.forEach(body => {
    if (body.isStatic && !body._color) {
      // Ground/walls — draw subtle border
      ctx.fillStyle = 'rgba(255,255,255,0.05)';
      ctx.beginPath();
      const v = body.vertices;
      ctx.moveTo(v[0].x, v[0].y);
      for (let i = 1; i < v.length; i++) ctx.lineTo(v[i].x, v[i].y);
      ctx.closePath();
      ctx.fill();
      return;
    }

    const color = body._color || '#888';
    const rgb = hexToRgb(color);
    const verts = body.vertices;

    // Glow
    ctx.shadowBlur = 12;
    ctx.shadowColor = color;

    // Fill
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(verts[0].x, verts[0].y);
    for (let i = 1; i < verts.length; i++) ctx.lineTo(verts[i].x, verts[i].y);
    ctx.closePath();
    ctx.fill();

    // Inner highlight
    ctx.fillStyle = `rgba(255,255,255,0.15)`;
    ctx.fill();

    // Border
    ctx.shadowBlur = 0;
    ctx.strokeStyle = `rgba(255,255,255,0.3)`;
    ctx.lineWidth = 1;
    ctx.stroke();

    // Material indicator
    if (body._material === 'bouncy') {
      ctx.strokeStyle = `rgba(0,255,0,0.4)`;
      ctx.lineWidth = 2;
      ctx.stroke();
    } else if (body._material === 'heavy') {
      ctx.strokeStyle = `rgba(255,100,0,0.4)`;
      ctx.lineWidth = 3;
      ctx.stroke();
    } else if (body._material === 'ice') {
      ctx.fillStyle = `rgba(150,220,255,0.2)`;
      ctx.fill();
    } else if (body._material === 'fragile') {
      // Draw crack lines
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 1;
      const cx = body.position.x, cy = body.position.y;
      for (let i = 0; i < 3; i++) {
        const a = (i / 3) * Math.PI * 2 + body.angle;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(a) * 15, cy + Math.sin(a) * 15);
        ctx.stroke();
      }
    }

    // Speed trail
    const speed = Vector.magnitude(body.velocity);
    if (speed > 3 && !body.isStatic) {
      ctx.globalAlpha = Math.min(speed / 20, 0.4);
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(body.position.x, body.position.y);
      ctx.lineTo(body.position.x - body.velocity.x * 3, body.position.y - body.velocity.y * 3);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
  });

  // Draw mode preview
  if (currentTool === 'draw' && isDrawing && drawingPoints.length > 1) {
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 2;
    ctx.shadowBlur = 8;
    ctx.shadowColor = '#0ff';
    ctx.beginPath();
    ctx.moveTo(drawingPoints[0].x, drawingPoints[0].y);
    drawingPoints.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  // Throw preview
  if (pointerDown && currentTool !== 'draw' && currentTool !== 'drag') {
    const dx = pointerX - pointerStartX;
    const dy = pointerY - pointerStartY;
    if (Math.abs(dx) + Math.abs(dy) > 10) {
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(pointerStartX, pointerStartY);
      ctx.lineTo(pointerX, pointerY);
      ctx.stroke();
      ctx.setLineDash([]);

      // Arrow head
      const angle = Math.atan2(dy, dx);
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.moveTo(pointerX, pointerY);
      ctx.lineTo(pointerX - 10 * Math.cos(angle - 0.4), pointerY - 10 * Math.sin(angle - 0.4));
      ctx.lineTo(pointerX - 10 * Math.cos(angle + 0.4), pointerY - 10 * Math.sin(angle + 0.4));
      ctx.closePath();
      ctx.fill();
    }
  }

  // Body count
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.font = '11px system-ui';
  ctx.fillText(`Bodies: ${bodies.length}`, 10, H - 10);
}

// --- Main Loop ---
let lastTime = 0;
function loop(time) {
  requestAnimationFrame(loop);
  const dt = Math.min(time - lastTime, 32);
  lastTime = time;

  if (!paused) {
    Engine.update(engine, dt);
  }

  // Remove off-screen bodies
  bodies = bodies.filter(b => {
    if (b.position.y > H + 200 || b.position.x < -200 || b.position.x > W + 200) {
      Composite.remove(engine.world, b);
      return false;
    }
    return true;
  });

  renderScene();
}

// --- Splash ---
document.getElementById('start-btn').addEventListener('click', () => {
  splash.classList.add('hidden');
  setTimeout(() => splash.style.display = 'none', 500);
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === ' ') { e.preventDefault(); togglePause(); }
  if (e.key === 'c' || e.key === 'C') clearAll();
  if (e.key === '1') { currentTool = 'circle'; updateToolbar(); }
  if (e.key === '2') { currentTool = 'rect'; updateToolbar(); }
  if (e.key === '3') { currentTool = 'triangle'; updateToolbar(); }
  if (e.key === '4') { currentTool = 'polygon'; updateToolbar(); }
  if (e.key === '5') { currentTool = 'platform'; updateToolbar(); }
  if (e.key === '6') { currentTool = 'draw'; updateToolbar(); }
  if (e.key === '7') { currentTool = 'drag'; updateToolbar(); }
});

// --- Init ---
buildToolbar();
requestAnimationFrame(loop);

</script>
</body>
</html>
